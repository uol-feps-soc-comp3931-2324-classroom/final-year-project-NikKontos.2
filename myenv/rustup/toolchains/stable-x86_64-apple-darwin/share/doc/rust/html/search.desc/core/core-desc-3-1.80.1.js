searchState.loadedDescShard("core", 3, "Store multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore SIMD&amp;FP register (immediate offset)\nSubtract\nSubtract\nSubtract\nSubtract\nSubtract\nSubtract\nSubtract\nSubtract\nSubtract\nSubtract returning high narrow\nSubtract returning high narrow\nSubtract returning high narrow\nSubtract returning high narrow\nSubtract returning high narrow\nSubtract returning high narrow\nSubtract returning high narrow\nSubtract returning high narrow\nSubtract returning high narrow\nSubtract returning high narrow\nSubtract returning high narrow\nSubtract returning high narrow\nSigned Subtract Long\nSigned Subtract Long\nSigned Subtract Long\nUnsigned Subtract Long\nUnsigned Subtract Long\nUnsigned Subtract Long\nSubtract\nSubtract\nSubtract\nSubtract\nSubtract\nSubtract\nSubtract\nSubtract\nSubtract\nSigned Subtract Wide\nSigned Subtract Wide\nSigned Subtract Wide\nUnsigned Subtract Wide\nUnsigned Subtract Wide\nUnsigned Subtract Wide\nDot product index form with signed and unsigned integers\nDot product index form with signed and unsigned integers\nTable look-up\nTable look-up\nTable look-up\nTable look-up\nTable look-up\nTable look-up\nTable look-up\nTable look-up\nTable look-up\nTable look-up\nTable look-up\nTable look-up\nExtended table look-up\nExtended table look-up\nExtended table look-up\nExtended table look-up\nExtended table look-up\nExtended table look-up\nExtended table look-up\nExtended table look-up\nExtended table look-up\nExtended table look-up\nExtended table look-up\nExtended table look-up\nTranspose elements\nTranspose elements\nTranspose elements\nTranspose elements\nTranspose elements\nTranspose elements\nTranspose elements\nTranspose elements\nTranspose elements\nTranspose elements\nTranspose elements\nTranspose elements\nTranspose elements\nTranspose elements\nTranspose elements\nTranspose elements\nTranspose elements\nTranspose elements\nSigned compare bitwise Test bits nonzero\nSigned compare bitwise Test bits nonzero\nSigned compare bitwise Test bits nonzero\nSigned compare bitwise Test bits nonzero\nSigned compare bitwise Test bits nonzero\nUnsigned compare bitwise Test bits nonzero\nUnsigned compare bitwise Test bits nonzero\nUnsigned compare bitwise Test bits nonzero\nSigned compare bitwise Test bits nonzero\nSigned compare bitwise Test bits nonzero\nSigned compare bitwise Test bits nonzero\nSigned compare bitwise Test bits nonzero\nSigned compare bitwise Test bits nonzero\nUnsigned compare bitwise Test bits nonzero\nUnsigned compare bitwise Test bits nonzero\nUnsigned compare bitwise Test bits nonzero\nDot product index form with unsigned and signed integers\nDot product vector form with unsigned and signed integers\nDot product index form with unsigned and signed integers\nDot product vector form with unsigned and signed integers\nUnsigned and signed 8-bit integer matrix …\nUnzip vectors\nUnzip vectors\nUnzip vectors\nUnzip vectors\nUnzip vectors\nUnzip vectors\nUnzip vectors\nUnzip vectors\nUnzip vectors\nUnzip vectors\nUnzip vectors\nUnzip vectors\nUnzip vectors\nUnzip vectors\nUnzip vectors\nUnzip vectors\nUnzip vectors\nUnzip vectors\nZip vectors\nZip vectors\nZip vectors\nZip vectors\nZip vectors\nZip vectors\nZip vectors\nZip vectors\nZip vectors\nZip vectors\nZip vectors\nZip vectors\nZip vectors\nZip vectors\nZip vectors\nZip vectors\nZip vectors\nZip vectors\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nLOONGARCH-specific 256-bit wide vector of 16 packed <code>i16</code>.\nLOONGARCH-specific 128-bit wide vector of 16 packed <code>i8</code>.\nLOONGARCH-specific 256-bit wide vector of 16 packed <code>u16</code>.\nLOONGARCH-specific 128-bit wide vector of 16 packed <code>u8</code>.\nLOONGARCH-specific 128-bit wide vector of 2 packed <code>f64</code>.\nLOONGARCH-specific 128-bit wide vector of 2 packed <code>i64</code>.\nLOONGARCH-specific 128-bit wide vector of 2 packed <code>u64</code>.\nLOONGARCH-specific 256-bit wide vector of 32 packed <code>i8</code>.\nLOONGARCH-specific 256-bit wide vector of 32 packed <code>u8</code>.\nLOONGARCH-specific 128-bit wide vector of 4 packed <code>f32</code>.\nLOONGARCH-specific 256-bit wide vector of 4 packed <code>f64</code>.\nLOONGARCH-specific 128-bit wide vector of 4 packed <code>i32</code>.\nLOONGARCH-specific 256-bit wide vector of 4 packed <code>i64</code>.\nLOONGARCH-specific 128-bit wide vector of 4 packed <code>u32</code>.\nLOONGARCH-specific 256-bit wide vector of 4 packed <code>u64</code>.\nLOONGARCH-specific 128-bit wide vector of 8 packed <code>f32</code>.\nLOONGARCH-specific 128-bit wide vector of 8 packed <code>i16</code>.\nLOONGARCH-specific 256-bit wide vector of 8 packed <code>i32</code>.\nLOONGARCH-specific 128-bit wide vector of 8 packed <code>u16</code>.\nLOONGARCH-specific 256-bit wide vector of 8 packed <code>u32</code>.\nGenerates the trap instruction <code>BREAK</code>\nGenerates the trap instruction <code>BREAK</code>\nSyscall to be used whenever the <em>assert expression produces </em>…\nx-th thread-block dimension.\ny-th thread-block dimension.\nz-th thread-block dimension.\nx-th thread-block index.\ny-th thread-block index.\nz-th thread-block index.\nx-th block-grid dimension.\ny-th block-grid dimension.\nz-th block-grid dimension.\nSynchronizes all threads in the block.\nx-th thread index.\ny-th thread index.\nz-th thread index.\nFree previously dynamically allocated memory.\nAllocate memory dynamically from a fixed-size heap in …\nGenerates the trap instruction <code>TRAP</code>\nPrint formatted output from a kernel to a host-side output …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nGenerates the trap instruction <code>TRAP</code>\nVector abs.\nVector abss.\nVector add.\nVector addc.\nVector Add Extended\nVector adds.\nVector All Elements Equal\nVector All Elements Greater or Equal\nVector All Elements Greater Than\nVector All In\nVector All Elements Less Than or Equal\nVector All Elements Less Than\nAll Elements Not a Number\nVector All Elements Not Equal\nAll Elements Not Greater Than or Equal\nAll Elements Not Greater Than\nAll Elements Not Less Than or Equal\nAll Elements Not Less Than\nAll Elements Numeric\nVector and.\nVector andc.\nVector All Elements Equal\nVector Any Element Greater or Equal\nVector Any Element Greater Than\nVector Any Element Less Than or Equal\nVector Any Element Less Than\nAny Elements Not a Number\nVector Any Elements Not Equal\nAny Elements Not Greater Than or Equal\nAny Elements Not Greater Than\nAny Elements Not Less Than or Equal\nAny Elements Not Less Than\nAny Elements Numeric\nAny Element Out of Bounds\nVector avg.\nVector ceil.\nVector cmpb.\nVector cmpeq.\nVector cmpge.\nVector cmpgt.\nVector cmple.\nVector cmplt.\nVector Compare Not Equal\nVector Count Leading Zeros\nVector Convert to Floating-Point\nVector Convert to Signed Integer\nVector Convert to Signed Integer\nVector expte.\nVector Extract\nVector floor.\nVector Insert\nVector Load Indexed.\nVector Load Element Indexed.\nVector Load Indexed Least Recently Used.\nVector Base-2 Logarithm Estimate\nVector Multiply Add\nVector Multiply Add Saturated\nVector max.\nVector Merge Even\nVector Merge High\nVector Merge Low\nVector Merge Odd\nMove From Vector Status and Control Register.\nVector min.\nVector Multiply Low and Add Unsigned Half Word\nVector Multiply Round and Add Saturated\nVector Multiply Sum\nVector Multiply Sum Saturated\nVector Multiply\nVector Multiply Even\nVector Multiply Odd\nVector NAND\nVector Negative Multiply Subtract\nVector nor.\nVector or.\nVector OR with Complement\nVector Pack\nVector Pack Saturated\nVector Pack Saturated Unsigned\nVector permute.\nVector Rotate Left\nVector Round\nVector Select\nVector Shift Left\nVector Shift Left Double\nVector Shift Left Double by Words\nVector Shift Left Long\nVector Shift Left by Octets\nVector Shift Left Variable\nVector Splat\nVector Splat to Signed Halfword\nVector Splat to Signed Word\nVector Splat to Signed Byte\nVector Splat to Unsigned Halfword\nVector Splat to Unsigned Word\nVector Splat to Unsigned Byte\nVector splats.\nVector Shift Right\nVector Shift Right Algebraic\nVector Shift Right Long\nVector Shift Right by Octets\nVector Shift Right Variable\nVector Store Indexed\nVector Store Element Indexed\nVector Store Indexed Least Recently Used\nVector sub.\nVector Subtract Carryout\nVector subs.\nVector Sum Across Partial (1/2) Saturated\nVector Sum Across Partial (1/4) Saturated\nVector Unpack High\nVector Unpack Low\nVSX Unaligned Load\nVector xor.\nVSX Unaligned Store\nVector permute.\nPowerPC-specific 128-bit wide vector mask of sixteen …\nPowerPC-specific 128-bit wide vector mask of four packed …\nPowerPC-specific 128-bit wide vector mask of two <code>i64</code>\nPowerPC-specific 128-bit wide vector mask of eight packed …\nPowerPC-specific 128-bit wide vector of two packed <code>f64</code>\nPowerPC-specific 128-bit wide vector of four packed <code>f32</code>\nPowerPC-specific 128-bit wide vector of sixteen packed <code>i8</code>\nPowerPC-specific 128-bit wide vector of four packed <code>i32</code>\nPowerPC-specific 128-bit wide vector of two packed <code>i64</code>\nPowerPC-specific 128-bit wide vector of eight packed <code>i16</code>\nPowerPC-specific 128-bit wide vector of sixteen packed <code>u8</code>\nPowerPC-specific 128-bit wide vector of four packed <code>u32</code>\nPowerPC-specific 128-bit wide vector of two packed <code>u64</code>\nPowerPC-specific 128-bit wide vector of eight packed <code>u16</code>\nGenerates the trap instruction <code>TRAP</code>\nVector abs.\nVector abss.\nVector add.\nVector addc.\nVector Add Extended\nVector adds.\nVector All Elements Equal\nVector All Elements Greater or Equal\nVector All Elements Greater Than\nVector All In\nVector All Elements Less Than or Equal\nVector All Elements Less Than\nAll Elements Not a Number\nVector All Elements Not Equal\nAll Elements Not Greater Than or Equal\nAll Elements Not Greater Than\nAll Elements Not Less Than or Equal\nAll Elements Not Less Than\nAll Elements Numeric\nVector and.\nVector andc.\nVector All Elements Equal\nVector Any Element Greater or Equal\nVector Any Element Greater Than\nVector Any Element Less Than or Equal\nVector Any Element Less Than\nAny Elements Not a Number\nVector Any Elements Not Equal\nAny Elements Not Greater Than or Equal\nAny Elements Not Greater Than\nAny Elements Not Less Than or Equal\nAny Elements Not Less Than\nAny Elements Numeric\nAny Element Out of Bounds\nVector avg.\nVector ceil.\nVector cmpb.\nVector cmpeq.\nVector cmpge.\nVector cmpgt.\nVector cmple.\nVector cmplt.\nVector Compare Not Equal\nVector Count Leading Zeros\nVector Convert to Floating-Point\nVector Convert to Signed Integer\nVector Convert to Signed Integer\nVector expte.\nVector Extract\nVector floor.\nVector Insert\nVector Load Indexed.\nVector Load Element Indexed.\nVector Load Indexed Least Recently Used.\nVector Base-2 Logarithm Estimate\nVector Multiply Add\nVector Multiply Add Saturated\nVector max.\nVector Merge Even\nVector Merge High\nVector Merge Low\nVector Merge Odd\nMove From Vector Status and Control Register.\nVector min.\nVector Multiply Low and Add Unsigned Half Word\nVector Multiply Round and Add Saturated\nVector Multiply Sum\nVector Multiply Sum Saturated\nVector Multiply\nVector Multiply Even\nVector Multiply Odd\nVector NAND\nVector Negative Multiply Subtract\nVector nor.\nVector or.\nVector OR with Complement\nVector Pack\nVector Pack Saturated\nVector Pack Saturated Unsigned\nVector permute.\nVector Rotate Left\nVector Round\nVector Select\nVector Shift Left\nVector Shift Left Double\nVector Shift Left Double by Words\nVector Shift Left Long\nVector Shift Left by Octets\nVector Shift Left Variable\nVector Splat\nVector Splat to Signed Halfword\nVector Splat to Signed Word\nVector Splat to Signed Byte\nVector Splat to Unsigned Halfword\nVector Splat to Unsigned Word\nVector Splat to Unsigned Byte\nVector splats.\nVector Shift Right\nVector Shift Right Algebraic\nVector Shift Right Long\nVector Shift Right by Octets\nVector Shift Right Variable\nVector Store Indexed\nVector Store Element Indexed\nVector Store Indexed Least Recently Used\nVector sub.\nVector Subtract Carryout\nVector subs.\nVector Sum Across Partial (1/2) Saturated\nVector Sum Across Partial (1/4) Saturated\nVector Unpack High\nVector Unpack Low\nVSX Unaligned Load\nVector Load with Length\nVector xor.\nVSX Unaligned Store\nVector Store with Length\nVector permute.\nPowerPC-specific 128-bit wide vector mask of sixteen …\nPowerPC-specific 128-bit wide vector mask of four packed …\nPowerPC-specific 128-bit wide vector mask of two <code>i64</code>\nPowerPC-specific 128-bit wide vector mask of eight packed …\nPowerPC-specific 128-bit wide vector of two packed <code>f64</code>\nPowerPC-specific 128-bit wide vector of four packed <code>f32</code>\nPowerPC-specific 128-bit wide vector of sixteen packed <code>i8</code>\nPowerPC-specific 128-bit wide vector of four packed <code>i32</code>\nPowerPC-specific 128-bit wide vector of two packed <code>i64</code>\nPowerPC-specific 128-bit wide vector of eight packed <code>i16</code>\nPowerPC-specific 128-bit wide vector of sixteen packed <code>u8</code>\nPowerPC-specific 128-bit wide vector of four packed <code>u32</code>\nPowerPC-specific 128-bit wide vector of two packed <code>u64</code>\nPowerPC-specific 128-bit wide vector of eight packed <code>u16</code>\nAdds packed 16-bit signed numbers, discarding overflow bits\nAdds packed 8-bit signed numbers, discarding overflow bits\nAES final round decryption instruction for RV32.\nAES middle round decryption instruction for RV32.\nAES final round encryption instruction for RV32.\nAES middle round encryption instruction for RV32 with.\nCarry-less multiply (low-part)\nCarry-less multiply (high-part)\nCarry-less multiply (reversed)\nCount the number of redundant sign bits of the packed …\nCount the number of redundant sign bits of the packed …\nCount the number of redundant sign bits of the packed …\nCount the number of leading zero bits of the packed 16-bit …\nCount the number of leading zero bits of the packed 32-bit …\nCount the number of leading zero bits of the packed 8-bit …\nCompare equality for packed 16-bit elements\nCompare equality for packed 8-bit elements\nCross adds and subtracts packed 16-bit signed numbers, …\nCross subtracts and adds packed 16-bit signed numbers, …\nGenerates the <code>FENCE.I</code> instruction\nReads the floating-point rounding mode register <code>frm</code>\nHypervisor memory management fence for guest physical …\nHypervisor memory management fence for all virtual …\nHypervisor memory management fence for guest physical …\nHypervisor memory management fence for given virtual …\nHypervisor memory management fence for given guest virtual …\nHypervisor memory management fence for all guest address …\nHypervisor memory management fence for given guest address …\nHypervisor memory management fence for given guest virtual …\nInvalidate hypervisor translation cache for guest physical …\nInvalidate hypervisor translation cache for all virtual …\nInvalidate hypervisor translation cache for guest physical …\nInvalidate hypervisor translation cache for given virtual …\nInvalidate hypervisor translation cache for given guest …\nInvalidate hypervisor translation cache for all guest …\nInvalidate hypervisor translation cache for given guest …\nInvalidate hypervisor translation cache for given guest …\nLoads virtual machine memory by signed byte integer\nLoads virtual machine memory by unsigned byte integer\nLoads virtual machine memory by signed half integer\nLoads virtual machine memory by unsigned half integer\nLoads virtual machine memory by signed word integer\nAccesses virtual machine instruction by unsigned half …\nAccesses virtual machine instruction by unsigned word …\nStores virtual machine memory by byte integer\nStores virtual machine memory by half integer\nStores virtual machine memory by word integer\nCompute the absolute value of packed 16-bit signed integers\nCompute the absolute value of packed 8-bit signed integers\nAdds packed 16-bit signed numbers, saturating at the …\nAdds packed 8-bit signed numbers, saturating at the …\nAdds signed lower 16-bit content of two registers with Q15 …\nCross adds and subtracts packed 16-bit signed numbers, …\nCross subtracts and adds packed 16-bit signed numbers, …\nLogical left shift packed 16-bit elements, saturating at …\nLogical left shift packed 8-bit elements, saturating at …\nLogical saturating left then arithmetic right shift packed …\nLogical saturating left then arithmetic right shift packed …\nLogical saturating left then arithmetic right shift packed …\nLogical saturating left then arithmetic right shift packed …\nStraight adds and subtracts packed 16-bit signed numbers, …\nStraight subtracts and adds packed 16-bit signed numbers, …\nSubtracts packed 16-bit signed numbers, saturating at the …\nSubtracts packed 8-bit signed numbers, saturating at the …\nSubtracts signed lower 16-bit content of two registers …\nGenerates the <code>NOP</code> instruction\nBitwise OR-Combine, byte granule\nGenerates the <code>PAUSE</code> instruction\nCalculate the sum of absolute difference of unsigned 8-bit …\nCalculate and accumulate the sum of absolute difference of …\nPack two 16-bit data from bottom and top half from 32-bit …\nPack two 16-bit data from top and bottom half from 32-bit …\nHalves the sum of packed 16-bit signed numbers, dropping …\nHalves the sum of packed 8-bit signed numbers, dropping …\nCross halves of adds and subtracts packed 16-bit signed …\nCross halves of subtracts and adds packed 16-bit signed …\nStraight halves of adds and subtracts packed 16-bit signed …\nStraight halves of subtracts and adds packed 16-bit signed …\nHalves the subtraction result of packed 16-bit signed …\nHalves the subtraction result of packed 8-bit signed …\nCompare whether 16-bit packed signed integers are less …\nCompare whether 8-bit packed signed integers are less than …\nCompare whether 16-bit packed signed integers are less …\nCompare whether 8-bit packed signed integers are less than …\nGenerates the <code>SFENCE.INVAL.IR</code> instruction\nSupervisor memory management fence for given virtual …\nSupervisor memory management fence for all address spaces …\nSupervisor memory management fence for given address space\nSupervisor memory management fence for given virtual …\nGenerates the <code>SFENCE.W.INVAL</code> instruction\nImplements the Sigma0 transformation function as used in …\nImplements the Sigma1 transformation function as used in …\nImplements the Sum0 transformation function as used in the …\nImplements the Sum1 transformation function as used in the …\nImplements the high half of the Sigma0 transformation, as …\nImplements the low half of the Sigma0 transformation, as …\nImplements the high half of the Sigma1 transformation, as …\nImplements the low half of the Sigma1 transformation, as …\nImplements the Sum0 transformation, as used in the …\nImplements the Sum1 transformation, as used in the …\nInvalidate supervisor translation cache for given virtual …\nInvalidate supervisor translation cache for all address …\nInvalidate supervisor translation cache for given address …\nInvalidate supervisor translation cache for given virtual …\nLogical left shift packed 16-bit elements, discarding …\nLogical left shift packed 8-bit elements, discarding …\nImplements the P0 transformation function as used in the …\nImplements the P1 transformation function as used in the …\nAccelerates the block encrypt/decrypt operation of the SM4 …\nAccelerates the Key Schedule operation of the SM4 block …\nMultiply signed 8-bit elements and add 16-bit elements on …\nMultiply signed to unsigned 8-bit and add 16-bit elements …\nGet maximum values from 16-bit packed signed integers\nGet maximum values from 8-bit packed signed integers\nGet minimum values from 16-bit packed signed integers\nGet minimum values from 8-bit packed signed integers\nArithmetic right shift packed 16-bit elements without …\nArithmetic right shift packed 16-bit elements with …\nArithmetic right shift packed 8-bit elements without …\nArithmetic right shift packed 8-bit elements with rounding …\nLogical right shift packed 16-bit elements without …\nLogical right shift packed 16-bit elements with rounding up\nLogical right shift packed 8-bit elements without rounding …\nLogical right shift packed 8-bit elements with rounding up\nStraight adds and subtracts packed 16-bit signed numbers, …\nStraight subtracts and adds packed 16-bit signed numbers, …\nSubtracts packed 16-bit signed numbers, discarding …\nSubtracts packed 8-bit signed numbers, discarding overflow …\nUnpack first and zeroth into two 16-bit signed halfwords …\nUnpack second and zeroth into two 16-bit signed halfwords …\nUnpack third and zeroth into two 16-bit signed halfwords …\nUnpack third and first into two 16-bit signed halfwords in …\nUnpack third and second into two 16-bit signed halfwords …\nSwap the 16-bit halfwords within each 32-bit word of a …\nSwap the 8-bit bytes within each 16-bit halfword of a …\nCompare whether 16-bit packed unsigned integers are less …\nCompare whether 8-bit packed unsigned integers are less …\nCompare whether 16-bit packed unsigned integers are less …\nCompare whether 8-bit packed unsigned integers are less …\nAdds packed 16-bit unsigned numbers, saturating at the …\nAdds packed 8-bit unsigned numbers, saturating at the …\nAdds signed lower 16-bit content of two registers with U16 …\nCross adds and subtracts packed 16-bit unsigned numbers, …\nCross subtracts and adds packed 16-bit unsigned numbers, …\nStraight adds and subtracts packed 16-bit unsigned …\nStraight subtracts and adds packed 16-bit unsigned …\nSubtracts packed 16-bit unsigned numbers, saturating at …\nSubtracts packed 8-bit unsigned numbers, saturating at the …\nSubtracts signed lower 16-bit content of two registers …\nMultiply unsigned 8-bit elements and add 16-bit elements …\nGet maximum values from 16-bit packed unsigned integers\nGet maximum values from 8-bit packed unsigned integers\nGet minimum values from 16-bit packed unsigned integers\nGet minimum values from 8-bit packed unsigned integers\nPlace odd and even bits of the source word into …\nHalves the sum of packed 16-bit unsigned numbers, dropping …\nHalves the sum of packed 8-bit unsigned numbers, dropping …\nCross halves of adds and subtracts packed 16-bit unsigned …\nCross halves of subtracts and adds packed 16-bit unsigned …\nStraight halves of adds and subtracts packed 16-bit …\nStraight halves of subtracts and adds packed 16-bit …\nHalves the subtraction result of packed 16-bit unsigned …\nHalves the subtraction result of packed 8-bit unsigned …\nGenerates the <code>WFI</code> instruction\nNibble-wise lookup of indicies into a vector.\nByte-wise lookup of indicies into a vector in registers.\nPlace upper/lower halves of the source register into …\nUnpack first and zeroth into two 16-bit unsigned halfwords …\nUnpack second and zeroth into two 16-bit unsigned …\nUnpack third and zeroth into two 16-bit unsigned halfwords …\nUnpack third and first into two 16-bit unsigned halfwords …\nUnpack third and second into two 16-bit unsigned halfwords …\nAdds packed 16-bit signed numbers, discarding overflow bits\nAdds packed 8-bit signed numbers, discarding overflow bits\nAES final round decryption instruction for RV64.\nAES middle round decryption instruction for RV64.\nAES final round encryption instruction for RV64.\nAES middle round encryption instruction for RV64.\nThis instruction accelerates the inverse MixColumns step …\nThis instruction implements part of the KeySchedule …\nThis instruction implements part of the KeySchedule …\nCarry-less multiply (low-part)\nCarry-less multiply (high-part)\nCarry-less multiply (reversed)\nCount the number of redundant sign bits of the packed …\nCount the number of redundant sign bits of the packed …\nCount the number of redundant sign bits of the packed …\nCount the number of leading zero bits of the packed 16-bit …\nCount the number of leading zero bits of the packed 32-bit …\nCount the number of leading zero bits of the packed 8-bit …\nCompare equality for packed 16-bit elements\nCompare equality for packed 8-bit elements\nCross adds and subtracts packed 16-bit signed numbers, …\nCross subtracts and adds packed 16-bit signed numbers, …\nGenerates the <code>FENCE.I</code> instruction\nReads the floating-point rounding mode register <code>frm</code>\nHypervisor memory management fence for guest physical …\nHypervisor memory management fence for all virtual …\nHypervisor memory management fence for guest physical …\nHypervisor memory management fence for given virtual …\nHypervisor memory management fence for given guest virtual …\nHypervisor memory management fence for all guest address …\nHypervisor memory management fence for given guest address …\nHypervisor memory management fence for given guest virtual …\nInvalidate hypervisor translation cache for guest physical …\nInvalidate hypervisor translation cache for all virtual …\nInvalidate hypervisor translation cache for guest physical …\nInvalidate hypervisor translation cache for given virtual …\nInvalidate hypervisor translation cache for given guest …\nInvalidate hypervisor translation cache for all guest …\nInvalidate hypervisor translation cache for given guest …\nInvalidate hypervisor translation cache for given guest …\nLoads virtual machine memory by signed byte integer\nLoads virtual machine memory by unsigned byte integer\nLoads virtual machine memory by double integer\nLoads virtual machine memory by signed half integer\nLoads virtual machine memory by unsigned half integer\nLoads virtual machine memory by signed word integer\nLoads virtual machine memory by unsigned word integer\nAccesses virtual machine instruction by unsigned half …\nAccesses virtual machine instruction by unsigned word …\nStores virtual machine memory by byte integer\nStores virtual machine memory by double integer\nStores virtual machine memory by half integer\nStores virtual machine memory by word integer\nCompute the absolute value of packed 16-bit signed integers\nCompute the absolute value of packed 8-bit signed integers\nAdds packed 16-bit signed numbers, saturating at the …\nAdds packed 8-bit signed numbers, saturating at the …\nAdds signed lower 16-bit content of two registers with Q15 …\nCross adds and subtracts packed 16-bit signed numbers, …\nCross subtracts and adds packed 16-bit signed numbers, …\nLogical left shift packed 16-bit elements, saturating at …\nLogical left shift packed 8-bit elements, saturating at …\nLogical saturating left then arithmetic right shift packed …\nLogical saturating left then arithmetic right shift packed …\nLogical saturating left then arithmetic right shift packed …\nLogical saturating left then arithmetic right shift packed …\nStraight adds and subtracts packed 16-bit signed numbers, …\nStraight subtracts and adds packed 16-bit signed numbers, …\nSubtracts packed 16-bit signed numbers, saturating at the …\nSubtracts packed 8-bit signed numbers, saturating at the …\nSubtracts signed lower 16-bit content of two registers …\nGenerates the <code>NOP</code> instruction\nBitwise OR-Combine, byte granule\nGenerates the <code>PAUSE</code> instruction\nCalculate the sum of absolute difference of unsigned 8-bit …\nCalculate and accumulate the sum of absolute difference of …\nPack two 16-bit data from bottom and top half from 32-bit …\nPack two 16-bit data from top and bottom half from 32-bit …\nHalves the sum of packed 16-bit signed numbers, dropping …\nHalves the sum of packed 8-bit signed numbers, dropping …\nCross halves of adds and subtracts packed 16-bit signed …\nCross halves of subtracts and adds packed 16-bit signed …\nStraight halves of adds and subtracts packed 16-bit signed …\nStraight halves of subtracts and adds packed 16-bit signed …\nHalves the subtraction result of packed 16-bit signed …\nHalves the subtraction result of packed 8-bit signed …\nCompare whether 16-bit packed signed integers are less …\nCompare whether 8-bit packed signed integers are less than …\nCompare whether 16-bit packed signed integers are less …\nCompare whether 8-bit packed signed integers are less than …\nGenerates the <code>SFENCE.INVAL.IR</code> instruction\nSupervisor memory management fence for given virtual …\nSupervisor memory management fence for all address spaces …\nSupervisor memory management fence for given address space\nSupervisor memory management fence for given virtual …\nGenerates the <code>SFENCE.W.INVAL</code> instruction\nImplements the Sigma0 transformation function as used in …\nImplements the Sigma1 transformation function as used in …\nImplements the Sum0 transformation function as used in the …\nImplements the Sum1 transformation function as used in the …\nImplements the Sigma0 transformation function as used in …\nImplements the Sigma1 transformation function as used in …\nImplements the Sum0 transformation function as used in the …\nImplements the Sum1 transformation function as used in the …\nInvalidate supervisor translation cache for given virtual …\nInvalidate supervisor translation cache for all address …\nInvalidate supervisor translation cache for given address …\nInvalidate supervisor translation cache for given virtual …\nLogical left shift packed 16-bit elements, discarding …\nLogical left shift packed 8-bit elements, discarding …\nImplements the P0 transformation function as used in the …\nImplements the P1 transformation function as used in the …\nAccelerates the block encrypt/decrypt operation of the SM4 …\nAccelerates the Key Schedule operation of the SM4 block …\nMultiply signed 8-bit elements and add 16-bit elements on …\nMultiply signed to unsigned 8-bit and add 16-bit elements …\nGet maximum values from 16-bit packed signed integers\nGet maximum values from 8-bit packed signed integers\nGet minimum values from 16-bit packed signed integers\nGet minimum values from 8-bit packed signed integers\nArithmetic right shift packed 16-bit elements without …\nArithmetic right shift packed 16-bit elements with …\nArithmetic right shift packed 8-bit elements without …\nArithmetic right shift packed 8-bit elements with rounding …\nLogical right shift packed 16-bit elements without …\nLogical right shift packed 16-bit elements with rounding up\nLogical right shift packed 8-bit elements without rounding …\nLogical right shift packed 8-bit elements with rounding up\nStraight adds and subtracts packed 16-bit signed numbers, …\nStraight subtracts and adds packed 16-bit signed numbers, …\nSubtracts packed 16-bit signed numbers, discarding …\nSubtracts packed 8-bit signed numbers, discarding overflow …\nUnpack first and zeroth into two 16-bit signed halfwords …\nUnpack second and zeroth into two 16-bit signed halfwords …\nUnpack third and zeroth into two 16-bit signed halfwords …\nUnpack third and first into two 16-bit signed halfwords in …\nUnpack third and second into two 16-bit signed halfwords …\nSwap the 16-bit halfwords within each 32-bit word of a …\nSwap the 8-bit bytes within each 16-bit halfword of a …\nCompare whether 16-bit packed unsigned integers are less …\nCompare whether 8-bit packed unsigned integers are less …\nCompare whether 16-bit packed unsigned integers are less …\nCompare whether 8-bit packed unsigned integers are less …\nAdds packed 16-bit unsigned numbers, saturating at the …\nAdds packed 8-bit unsigned numbers, saturating at the …\nAdds signed lower 16-bit content of two registers with U16 …\nCross adds and subtracts packed 16-bit unsigned numbers, …\nCross subtracts and adds packed 16-bit unsigned numbers, …\nStraight adds and subtracts packed 16-bit unsigned …\nStraight subtracts and adds packed 16-bit unsigned …\nSubtracts packed 16-bit unsigned numbers, saturating at …\nSubtracts packed 8-bit unsigned numbers, saturating at the …\nSubtracts signed lower 16-bit content of two registers …\nMultiply unsigned 8-bit elements and add 16-bit elements …\nGet maximum values from 16-bit packed unsigned integers\nGet maximum values from 8-bit packed unsigned integers\nGet minimum values from 16-bit packed unsigned integers\nGet minimum values from 8-bit packed unsigned integers\nHalves the sum of packed 16-bit unsigned numbers, dropping …\nHalves the sum of packed 8-bit unsigned numbers, dropping …\nCross halves of adds and subtracts packed 16-bit unsigned …\nCross halves of subtracts and adds packed 16-bit unsigned …\nStraight halves of adds and subtracts packed 16-bit …\nStraight halves of subtracts and adds packed 16-bit …\nHalves the subtraction result of packed 16-bit unsigned …\nHalves the subtraction result of packed 8-bit unsigned …\nGenerates the <code>WFI</code> instruction\nNibble-wise lookup of indicies into a vector.\nByte-wise lookup of indicies into a vector in registers.\nUnpack first and zeroth into two 16-bit unsigned halfwords …\nUnpack second and zeroth into two 16-bit unsigned …\nUnpack third and zeroth into two 16-bit unsigned halfwords …\nUnpack third and first into two 16-bit unsigned halfwords …\nUnpack third and second into two 16-bit unsigned halfwords …\nMaterializes a SIMD value from the provided operands.\nCalculates the absolute value of each lane of a 128-bit …\nLane-wise addition of two 128-bit vectors interpreted as …\nLane-wise rounding to the nearest integral value not …\nConverts a 128-bit vector interpreted as four 32-bit …\nConverts a 128-bit vector interpreted as four 32-bit …\nConversion of the two double-precision floating point …\nLane-wise division of two 128-bit vectors interpreted as …\nCompares two 128-bit vectors as if they were two vectors …\nExtracts a lane from a 128-bit vector interpreted as 4 …\nLane-wise rounding to the nearest integral value not …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCalculates the lane-wise minimum of two 128-bit vectors …\nCalculates the lane-wise minimum of two 128-bit vectors …\nLane-wise multiplication of two 128-bit vectors …\nCompares two 128-bit vectors as if they were two vectors …\nLane-wise rounding to the nearest integral value; if two …\nNegates each lane of a 128-bit vector interpreted as four …\nLane-wise maximum value, defined as <code>a &lt; b ? b : a</code>\nLane-wise minimum value, defined as <code>b &lt; a ? b : a</code>\nComputes <code>a * b + c</code> with either one rounding or two …\nA relaxed version of <code>f32x4_max</code> which is either <code>f32x4_max</code> or\nA relaxed version of <code>f32x4_min</code> which is either <code>f32x4_min</code> or\nComputes <code>-a * b + c</code> with either one rounding or two …\nReplaces a lane from a 128-bit vector interpreted as 4 …\nCreates a vector with identical lanes.\nCalculates the square root of each lane of a 128-bit …\nLane-wise subtraction of two 128-bit vectors interpreted …\nLane-wise rounding to the nearest integral value with the …\nMaterializes a SIMD value from the provided operands.\nCalculates the absolute value of each lane of a 128-bit …\nLane-wise add of two 128-bit vectors interpreted as two …\nLane-wise rounding to the nearest integral value not …\nLane-wise conversion from integer to floating point.\nLane-wise conversion from integer to floating point.\nLane-wise divide of two 128-bit vectors interpreted as two …\nCompares two 128-bit vectors as if they were two vectors …\nExtracts a lane from a 128-bit vector interpreted as 2 …\nLane-wise rounding to the nearest integral value not …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCalculates the lane-wise maximum of two 128-bit vectors …\nCalculates the lane-wise minimum of two 128-bit vectors …\nLane-wise multiply of two 128-bit vectors interpreted as …\nCompares two 128-bit vectors as if they were two vectors …\nLane-wise rounding to the nearest integral value; if two …\nNegates each lane of a 128-bit vector interpreted as two …\nLane-wise maximum value, defined as <code>a &lt; b ? b : a</code>\nLane-wise minimum value, defined as <code>b &lt; a ? b : a</code>\nConversion of the two lower single-precision floating …\nComputes <code>a * b + c</code> with either one rounding or two …\nA relaxed version of <code>f64x2_max</code> which is either <code>f64x2_max</code> or\nA relaxed version of <code>f64x2_min</code> which is either <code>f64x2_min</code> or\nComputes <code>-a * b + c</code> with either one rounding or two …\nReplaces a lane from a 128-bit vector interpreted as 2 …\nCreates a vector with identical lanes.\nCalculates the square root of each lane of a 128-bit …\nLane-wise subtract of two 128-bit vectors interpreted as …\nLane-wise rounding to the nearest integral value with the …\nMaterializes a SIMD value from the provided operands.\nLane-wise wrapping absolute value.\nAdds two 128-bit vectors as if they were two packed eight …\nAdds two 128-bit vectors as if they were two packed eight …\nReturns true if all lanes are non-zero, false otherwise.\nExtracts the high bit for each lane in <code>a</code> and produce a …\nCompares two 128-bit vectors as if they were two vectors …\nInteger extended pairwise addition producing extended …\nInteger extended pairwise addition producing extended …\nConverts high half of the smaller lane vector to a larger …\nConverts high half of the smaller lane vector to a larger …\nConverts low half of the smaller lane vector to a larger …\nConverts low half of the smaller lane vector to a larger …\nLane-wise integer extended multiplication producing twice …\nLane-wise integer extended multiplication producing twice …\nLane-wise integer extended multiplication producing twice …\nLane-wise integer extended multiplication producing twice …\nExtracts a lane from a 128-bit vector interpreted as 8 …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nLoad eight 8-bit integers and sign extend each one to a …\nLoad eight 8-bit integers and zero extend each one to a …\nCompares two 128-bit vectors as if they were two vectors …\nCompares lane-wise signed integers, and returns the …\nCompares lane-wise signed integers, and returns the …\nMultiplies two 128-bit vectors as if they were two packed …\nConverts two input vectors into a smaller lane vector by …\nCompares two 128-bit vectors as if they were two vectors …\nNegates a 128-bit vectors interpreted as eight 16-bit …\nLane-wise saturating rounding multiplication in Q15 format.\nA relaxed dot-product instruction.\nA relaxed version of <code>v128_bitselect</code> where this either …\nA relaxed version of <code>i16x8_relaxed_q15mulr</code> where if both …\nReplaces a lane from a 128-bit vector interpreted as 8 …\nShifts each lane to the left by the specified number of …\nShifts each lane to the right by the specified number of …\nSame as <code>i8x16_shuffle</code>, except operates as if the inputs …\nCreates a vector with identical lanes.\nSubtracts two 128-bit vectors as if they were two packed …\nSubtracts two 128-bit vectors as if they were two packed …\nMaterializes a SIMD value from the provided operands.\nLane-wise wrapping absolute value.\nAdds two 128-bit vectors as if they were two packed four …\nReturns true if all lanes are non-zero, false otherwise.\nExtracts the high bit for each lane in <code>a</code> and produce a …\nLane-wise multiply signed 16-bit integers in the two input …\nCompares two 128-bit vectors as if they were two vectors …\nInteger extended pairwise addition producing extended …\nInteger extended pairwise addition producing extended …\nConverts high half of the smaller lane vector to a larger …\nConverts high half of the smaller lane vector to a larger …\nConverts low half of the smaller lane vector to a larger …\nConverts low half of the smaller lane vector to a larger …\nLane-wise integer extended multiplication producing twice …\nLane-wise integer extended multiplication producing twice …\nLane-wise integer extended multiplication producing twice …\nLane-wise integer extended multiplication producing twice …\nExtracts a lane from a 128-bit vector interpreted as 4 …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nLoad four 16-bit integers and sign extend each one to a …\nLoad four 16-bit integers and zero extend each one to a …\nCompares two 128-bit vectors as if they were two vectors …\nCompares lane-wise signed integers, and returns the …\nCompares lane-wise signed integers, and returns the …\nMultiplies two 128-bit vectors as if they were two packed …\nCompares two 128-bit vectors as if they were two vectors …\nNegates a 128-bit vectors interpreted as four 32-bit …\nSimilar to <code>i16x8_relaxed_dot_i8x16_i7x16</code> except that the …\nA relaxed version of <code>v128_bitselect</code> where this either …\nA relaxed version of <code>i32x4_trunc_sat_f32x4(a)</code> converts the …\nA relaxed version of <code>i32x4_trunc_sat_f64x2_zero(a)</code> …\nReplaces a lane from a 128-bit vector interpreted as 4 …\nShifts each lane to the left by the specified number of …\nShifts each lane to the right by the specified number of …\nSame as <code>i8x16_shuffle</code>, except operates as if the inputs …\nCreates a vector with identical lanes.\nSubtracts two 128-bit vectors as if they were two packed …\nConverts a 128-bit vector interpreted as four 32-bit …\nSaturating conversion of the two double-precision floating …\nMaterializes a SIMD value from the provided operands.\nLane-wise wrapping absolute value.\nAdds two 128-bit vectors as if they were two packed two …\nReturns true if all lanes are non-zero, false otherwise.\nExtracts the high bit for each lane in <code>a</code> and produce a …\nCompares two 128-bit vectors as if they were two vectors …\nConverts high half of the smaller lane vector to a larger …\nConverts high half of the smaller lane vector to a larger …\nConverts low half of the smaller lane vector to a larger …\nConverts low half of the smaller lane vector to a larger …\nLane-wise integer extended multiplication producing twice …\nLane-wise integer extended multiplication producing twice …\nLane-wise integer extended multiplication producing twice …\nLane-wise integer extended multiplication producing twice …\nExtracts a lane from a 128-bit vector interpreted as 2 …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nLoad two 32-bit integers and sign extend each one to a …\nLoad two 32-bit integers and zero extend each one to a …\nCompares two 128-bit vectors as if they were two vectors …\nMultiplies two 128-bit vectors as if they were two packed …\nCompares two 128-bit vectors as if they were two vectors …\nNegates a 128-bit vectors interpreted as two 64-bit signed …\nA relaxed version of <code>v128_bitselect</code> where this either …\nReplaces a lane from a 128-bit vector interpreted as 2 …\nShifts each lane to the left by the specified number of …\nShifts each lane to the right by the specified number of …\nSame as <code>i8x16_shuffle</code>, except operates as if the inputs …\nCreates a vector with identical lanes.\nSubtracts two 128-bit vectors as if they were two packed …\nMaterializes a SIMD value from the provided operands.\nLane-wise wrapping absolute value.\nAdds two 128-bit vectors as if they were two packed …\nAdds two 128-bit vectors as if they were two packed …\nReturns true if all lanes are non-zero, false otherwise.\nExtracts the high bit for each lane in <code>a</code> and produce a …\nCompares two 128-bit vectors as if they were two vectors …\nExtracts a lane from a 128-bit vector interpreted as 16 …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares lane-wise signed integers, and returns the …\nCompares lane-wise signed integers, and returns the …\nConverts two input vectors into a smaller lane vector by …\nCompares two 128-bit vectors as if they were two vectors …\nNegates a 128-bit vectors interpreted as sixteen 8-bit …\nCount the number of bits set to one within each lane.\nA relaxed version of <code>v128_bitselect</code> where this either …\nA relaxed version of <code>i8x16_swizzle(a, s)</code> which selects …\nReplaces a lane from a 128-bit vector interpreted as 16 …\nShifts each lane to the left by the specified number of …\nShifts each lane to the right by the specified number of …\nReturns a new vector with lanes selected from the lanes of …\nCreates a vector with identical lanes.\nSubtracts two 128-bit vectors as if they were two packed …\nSubtracts two 128-bit vectors as if they were two packed …\nReturns a new vector with lanes selected from the lanes of …\nCorresponding intrinsic to wasm’s <code>memory.atomic.notify</code> …\nCorresponding intrinsic to wasm’s <code>memory.atomic.wait32</code> …\nCorresponding intrinsic to wasm’s <code>memory.atomic.wait64</code> …\nCorresponding intrinsic to wasm’s <code>memory.grow</code> instruction\nCorresponding intrinsic to wasm’s <code>memory.size</code> instruction\nGenerates the <code>throw</code> instruction from the …\nMaterializes a SIMD value from the provided operands.\nAdds two 128-bit vectors as if they were two packed eight …\nAdds two 128-bit vectors as if they were two packed eight …\nReturns true if all lanes are non-zero, false otherwise.\nLane-wise rounding average.\nExtracts the high bit for each lane in <code>a</code> and produce a …\nCompares two 128-bit vectors as if they were two vectors …\nInteger extended pairwise addition producing extended …\nConverts high half of the smaller lane vector to a larger …\nConverts low half of the smaller lane vector to a larger …\nLane-wise integer extended multiplication producing twice …\nLane-wise integer extended multiplication producing twice …\nExtracts a lane from a 128-bit vector interpreted as 8 …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nLoad eight 8-bit integers and zero extend each one to a …\nCompares two 128-bit vectors as if they were two vectors …\nCompares lane-wise unsigned integers, and returns the …\nCompares lane-wise unsigned integers, and returns the …\nMultiplies two 128-bit vectors as if they were two packed …\nConverts two input vectors into a smaller lane vector by …\nCompares two 128-bit vectors as if they were two vectors …\nReplaces a lane from a 128-bit vector interpreted as 8 …\nShifts each lane to the left by the specified number of …\nShifts each lane to the right by the specified number of …\nSame as <code>i8x16_shuffle</code>, except operates as if the inputs …\nCreates a vector with identical lanes.\nSubtracts two 128-bit vectors as if they were two packed …\nSubtracts two 128-bit vectors as if they were two packed …\nMaterializes a SIMD value from the provided operands.\nAdds two 128-bit vectors as if they were two packed four …\nReturns true if all lanes are non-zero, false otherwise.\nExtracts the high bit for each lane in <code>a</code> and produce a …\nCompares two 128-bit vectors as if they were two vectors …\nInteger extended pairwise addition producing extended …\nConverts high half of the smaller lane vector to a larger …\nConverts low half of the smaller lane vector to a larger …\nLane-wise integer extended multiplication producing twice …\nLane-wise integer extended multiplication producing twice …\nExtracts a lane from a 128-bit vector interpreted as 4 …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nLoad four 16-bit integers and zero extend each one to a …\nCompares two 128-bit vectors as if they were two vectors …\nCompares lane-wise unsigned integers, and returns the …\nCompares lane-wise unsigned integers, and returns the …\nMultiplies two 128-bit vectors as if they were two packed …\nCompares two 128-bit vectors as if they were two vectors …\nA relaxed version of <code>u32x4_trunc_sat_f32x4(a)</code> converts the …\nA relaxed version of <code>u32x4_trunc_sat_f64x2_zero(a)</code> …\nReplaces a lane from a 128-bit vector interpreted as 4 …\nShifts each lane to the left by the specified number of …\nShifts each lane to the right by the specified number of …\nSame as <code>i8x16_shuffle</code>, except operates as if the inputs …\nCreates a vector with identical lanes.\nSubtracts two 128-bit vectors as if they were two packed …\nConverts a 128-bit vector interpreted as four 32-bit …\nSaturating conversion of the two double-precision floating …\nMaterializes a SIMD value from the provided operands.\nAdds two 128-bit vectors as if they were two packed two …\nReturns true if all lanes are non-zero, false otherwise.\nExtracts the high bit for each lane in <code>a</code> and produce a …\nCompares two 128-bit vectors as if they were two vectors …\nConverts high half of the smaller lane vector to a larger …\nConverts low half of the smaller lane vector to a larger …\nLane-wise integer extended multiplication producing twice …\nLane-wise integer extended multiplication producing twice …\nExtracts a lane from a 128-bit vector interpreted as 2 …\nLoad two 32-bit integers and zero extend each one to a …\nMultiplies two 128-bit vectors as if they were two packed …\nCompares two 128-bit vectors as if they were two vectors …\nReplaces a lane from a 128-bit vector interpreted as 2 …\nShifts each lane to the left by the specified number of …\nShifts each lane to the right by the specified number of …\nSame as <code>i8x16_shuffle</code>, except operates as if the inputs …\nCreates a vector with identical lanes.\nSubtracts two 128-bit vectors as if they were two packed …\nMaterializes a SIMD value from the provided operands.\nAdds two 128-bit vectors as if they were two packed …\nAdds two 128-bit vectors as if they were two packed …\nReturns true if all lanes are non-zero, false otherwise.\nLane-wise rounding average.\nExtracts the high bit for each lane in <code>a</code> and produce a …\nCompares two 128-bit vectors as if they were two vectors …\nExtracts a lane from a 128-bit vector interpreted as 16 …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares lane-wise unsigned integers, and returns the …\nCompares lane-wise unsigned integers, and returns the …\nConverts two input vectors into a smaller lane vector by …\nCompares two 128-bit vectors as if they were two vectors …\nCount the number of bits set to one within each lane.\nReplaces a lane from a 128-bit vector interpreted as 16 …\nShifts each lane to the left by the specified number of …\nShifts each lane to the right by the specified number of …\nReturns a new vector with lanes selected from the lanes of …\nCreates a vector with identical lanes.\nSubtracts two 128-bit vectors as if they were two packed …\nSubtracts two 128-bit vectors as if they were two packed …\nReturns a new vector with lanes selected from the lanes of …\nGenerates the <code>unreachable</code> instruction, which causes an …\nWASM-specific 128-bit wide SIMD vector type.\nPerforms a bitwise and of the two input 128-bit vectors, …\nBitwise AND of bits of <code>a</code> and the logical inverse of bits …\nReturns <code>true</code> if any bit in <code>a</code> is set, or <code>false</code> otherwise.\nUse the bitmask in <code>c</code> to select bits from <code>v1</code> when 1 and <code>v2</code> …\nLoads a <code>v128</code> vector from the given heap address.\nLoads a 16-bit value from <code>m</code> and sets lane <code>L</code> of <code>v</code> to that …\nLoad a single element and splat to all lanes of a v128 …\nLoads a 32-bit value from <code>m</code> and sets lane <code>L</code> of <code>v</code> to that …\nLoad a single element and splat to all lanes of a v128 …\nLoad a 32-bit element into the low bits of the vector and …\nLoads a 64-bit value from <code>m</code> and sets lane <code>L</code> of <code>v</code> to that …\nLoad a single element and splat to all lanes of a v128 …\nLoad a 64-bit element into the low bits of the vector and …\nLoads an 8-bit value from <code>m</code> and sets lane <code>L</code> of <code>v</code> to that …\nLoad a single element and splat to all lanes of a v128 …\nFlips each bit of the 128-bit input vector.\nPerforms a bitwise or of the two input 128-bit vectors, …\nStores a <code>v128</code> vector to the given heap address.\nStores the 16-bit value from lane <code>L</code> of <code>v</code> into <code>m</code>\nStores the 32-bit value from lane <code>L</code> of <code>v</code> into <code>m</code>\nStores the 64-bit value from lane <code>L</code> of <code>v</code> into <code>m</code>\nStores the 8-bit value from lane <code>L</code> of <code>v</code> into <code>m</code>\nPerforms a bitwise xor of the two input 128-bit vectors, …\nMaterializes a SIMD value from the provided operands.\nCalculates the absolute value of each lane of a 128-bit …\nLane-wise addition of two 128-bit vectors interpreted as …\nLane-wise rounding to the nearest integral value not …\nConverts a 128-bit vector interpreted as four 32-bit …\nConverts a 128-bit vector interpreted as four 32-bit …\nConversion of the two double-precision floating point …\nLane-wise division of two 128-bit vectors interpreted as …\nCompares two 128-bit vectors as if they were two vectors …\nExtracts a lane from a 128-bit vector interpreted as 4 …\nLane-wise rounding to the nearest integral value not …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCalculates the lane-wise minimum of two 128-bit vectors …\nCalculates the lane-wise minimum of two 128-bit vectors …\nLane-wise multiplication of two 128-bit vectors …\nCompares two 128-bit vectors as if they were two vectors …\nLane-wise rounding to the nearest integral value; if two …\nNegates each lane of a 128-bit vector interpreted as four …\nLane-wise maximum value, defined as <code>a &lt; b ? b : a</code>\nLane-wise minimum value, defined as <code>b &lt; a ? b : a</code>\nComputes <code>a * b + c</code> with either one rounding or two …\nA relaxed version of <code>f32x4_max</code> which is either <code>f32x4_max</code> or\nA relaxed version of <code>f32x4_min</code> which is either <code>f32x4_min</code> or\nComputes <code>-a * b + c</code> with either one rounding or two …\nReplaces a lane from a 128-bit vector interpreted as 4 …\nCreates a vector with identical lanes.\nCalculates the square root of each lane of a 128-bit …\nLane-wise subtraction of two 128-bit vectors interpreted …\nLane-wise rounding to the nearest integral value with the …\nMaterializes a SIMD value from the provided operands.\nCalculates the absolute value of each lane of a 128-bit …\nLane-wise add of two 128-bit vectors interpreted as two …\nLane-wise rounding to the nearest integral value not …\nLane-wise conversion from integer to floating point.\nLane-wise conversion from integer to floating point.\nLane-wise divide of two 128-bit vectors interpreted as two …\nCompares two 128-bit vectors as if they were two vectors …\nExtracts a lane from a 128-bit vector interpreted as 2 …\nLane-wise rounding to the nearest integral value not …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCalculates the lane-wise maximum of two 128-bit vectors …\nCalculates the lane-wise minimum of two 128-bit vectors …\nLane-wise multiply of two 128-bit vectors interpreted as …\nCompares two 128-bit vectors as if they were two vectors …\nLane-wise rounding to the nearest integral value; if two …\nNegates each lane of a 128-bit vector interpreted as two …\nLane-wise maximum value, defined as <code>a &lt; b ? b : a</code>\nLane-wise minimum value, defined as <code>b &lt; a ? b : a</code>\nConversion of the two lower single-precision floating …\nComputes <code>a * b + c</code> with either one rounding or two …\nA relaxed version of <code>f64x2_max</code> which is either <code>f64x2_max</code> or\nA relaxed version of <code>f64x2_min</code> which is either <code>f64x2_min</code> or\nComputes <code>-a * b + c</code> with either one rounding or two …\nReplaces a lane from a 128-bit vector interpreted as 2 …\nCreates a vector with identical lanes.\nCalculates the square root of each lane of a 128-bit …\nLane-wise subtract of two 128-bit vectors interpreted as …\nLane-wise rounding to the nearest integral value with the …\nReturns the argument unchanged.\nMaterializes a SIMD value from the provided operands.\nLane-wise wrapping absolute value.\nAdds two 128-bit vectors as if they were two packed eight …\nAdds two 128-bit vectors as if they were two packed eight …\nReturns true if all lanes are non-zero, false otherwise.\nExtracts the high bit for each lane in <code>a</code> and produce a …\nCompares two 128-bit vectors as if they were two vectors …\nInteger extended pairwise addition producing extended …\nInteger extended pairwise addition producing extended …\nConverts high half of the smaller lane vector to a larger …\nConverts high half of the smaller lane vector to a larger …\nConverts low half of the smaller lane vector to a larger …\nConverts low half of the smaller lane vector to a larger …\nLane-wise integer extended multiplication producing twice …\nLane-wise integer extended multiplication producing twice …\nLane-wise integer extended multiplication producing twice …\nLane-wise integer extended multiplication producing twice …\nExtracts a lane from a 128-bit vector interpreted as 8 …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nLoad eight 8-bit integers and sign extend each one to a …\nLoad eight 8-bit integers and zero extend each one to a …\nCompares two 128-bit vectors as if they were two vectors …\nCompares lane-wise signed integers, and returns the …\nCompares lane-wise signed integers, and returns the …\nMultiplies two 128-bit vectors as if they were two packed …\nConverts two input vectors into a smaller lane vector by …\nCompares two 128-bit vectors as if they were two vectors …\nNegates a 128-bit vectors interpreted as eight 16-bit …\nLane-wise saturating rounding multiplication in Q15 format.\nA relaxed dot-product instruction.\nA relaxed version of <code>v128_bitselect</code> where this either …\nA relaxed version of <code>i16x8_relaxed_q15mulr</code> where if both …\nReplaces a lane from a 128-bit vector interpreted as 8 …\nShifts each lane to the left by the specified number of …\nShifts each lane to the right by the specified number of …\nSame as <code>i8x16_shuffle</code>, except operates as if the inputs …\nCreates a vector with identical lanes.\nSubtracts two 128-bit vectors as if they were two packed …\nSubtracts two 128-bit vectors as if they were two packed …\nMaterializes a SIMD value from the provided operands.\nLane-wise wrapping absolute value.\nAdds two 128-bit vectors as if they were two packed four …\nReturns true if all lanes are non-zero, false otherwise.\nExtracts the high bit for each lane in <code>a</code> and produce a …\nLane-wise multiply signed 16-bit integers in the two input …\nCompares two 128-bit vectors as if they were two vectors …\nInteger extended pairwise addition producing extended …\nInteger extended pairwise addition producing extended …\nConverts high half of the smaller lane vector to a larger …\nConverts high half of the smaller lane vector to a larger …\nConverts low half of the smaller lane vector to a larger …\nConverts low half of the smaller lane vector to a larger …\nLane-wise integer extended multiplication producing twice …\nLane-wise integer extended multiplication producing twice …\nLane-wise integer extended multiplication producing twice …\nLane-wise integer extended multiplication producing twice …\nExtracts a lane from a 128-bit vector interpreted as 4 …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nLoad four 16-bit integers and sign extend each one to a …\nLoad four 16-bit integers and zero extend each one to a …\nCompares two 128-bit vectors as if they were two vectors …\nCompares lane-wise signed integers, and returns the …\nCompares lane-wise signed integers, and returns the …\nMultiplies two 128-bit vectors as if they were two packed …\nCompares two 128-bit vectors as if they were two vectors …\nNegates a 128-bit vectors interpreted as four 32-bit …\nSimilar to <code>i16x8_relaxed_dot_i8x16_i7x16</code> except that the …\nA relaxed version of <code>v128_bitselect</code> where this either …\nA relaxed version of <code>i32x4_trunc_sat_f32x4(a)</code> converts the …\nA relaxed version of <code>i32x4_trunc_sat_f64x2_zero(a)</code> …\nReplaces a lane from a 128-bit vector interpreted as 4 …\nShifts each lane to the left by the specified number of …\nShifts each lane to the right by the specified number of …\nSame as <code>i8x16_shuffle</code>, except operates as if the inputs …\nCreates a vector with identical lanes.\nSubtracts two 128-bit vectors as if they were two packed …\nConverts a 128-bit vector interpreted as four 32-bit …\nSaturating conversion of the two double-precision floating …\nMaterializes a SIMD value from the provided operands.\nLane-wise wrapping absolute value.\nAdds two 128-bit vectors as if they were two packed two …\nReturns true if all lanes are non-zero, false otherwise.\nExtracts the high bit for each lane in <code>a</code> and produce a …\nCompares two 128-bit vectors as if they were two vectors …\nConverts high half of the smaller lane vector to a larger …\nConverts high half of the smaller lane vector to a larger …\nConverts low half of the smaller lane vector to a larger …\nConverts low half of the smaller lane vector to a larger …\nLane-wise integer extended multiplication producing twice …\nLane-wise integer extended multiplication producing twice …\nLane-wise integer extended multiplication producing twice …\nLane-wise integer extended multiplication producing twice …\nExtracts a lane from a 128-bit vector interpreted as 2 …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nLoad two 32-bit integers and sign extend each one to a …\nLoad two 32-bit integers and zero extend each one to a …\nCompares two 128-bit vectors as if they were two vectors …\nMultiplies two 128-bit vectors as if they were two packed …\nCompares two 128-bit vectors as if they were two vectors …\nNegates a 128-bit vectors interpreted as two 64-bit signed …\nA relaxed version of <code>v128_bitselect</code> where this either …\nReplaces a lane from a 128-bit vector interpreted as 2 …\nShifts each lane to the left by the specified number of …\nShifts each lane to the right by the specified number of …\nSame as <code>i8x16_shuffle</code>, except operates as if the inputs …\nCreates a vector with identical lanes.\nSubtracts two 128-bit vectors as if they were two packed …\nMaterializes a SIMD value from the provided operands.\nLane-wise wrapping absolute value.\nAdds two 128-bit vectors as if they were two packed …\nAdds two 128-bit vectors as if they were two packed …\nReturns true if all lanes are non-zero, false otherwise.\nExtracts the high bit for each lane in <code>a</code> and produce a …\nCompares two 128-bit vectors as if they were two vectors …\nExtracts a lane from a 128-bit vector interpreted as 16 …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares lane-wise signed integers, and returns the …\nCompares lane-wise signed integers, and returns the …\nConverts two input vectors into a smaller lane vector by …\nCompares two 128-bit vectors as if they were two vectors …\nNegates a 128-bit vectors interpreted as sixteen 8-bit …\nCount the number of bits set to one within each lane.\nA relaxed version of <code>v128_bitselect</code> where this either …\nA relaxed version of <code>i8x16_swizzle(a, s)</code> which selects …\nReplaces a lane from a 128-bit vector interpreted as 16 …\nShifts each lane to the left by the specified number of …\nShifts each lane to the right by the specified number of …\nReturns a new vector with lanes selected from the lanes of …\nCreates a vector with identical lanes.\nSubtracts two 128-bit vectors as if they were two packed …\nSubtracts two 128-bit vectors as if they were two packed …\nReturns a new vector with lanes selected from the lanes of …\nCalls <code>U::from(self)</code>.\nCorresponding intrinsic to wasm’s <code>memory.atomic.notify</code> …\nCorresponding intrinsic to wasm’s <code>memory.atomic.wait32</code> …\nCorresponding intrinsic to wasm’s <code>memory.atomic.wait64</code> …\nCorresponding intrinsic to wasm’s <code>memory.grow</code> instruction\nCorresponding intrinsic to wasm’s <code>memory.size</code> instruction\nGenerates the <code>throw</code> instruction from the …\nMaterializes a SIMD value from the provided operands.\nAdds two 128-bit vectors as if they were two packed eight …\nAdds two 128-bit vectors as if they were two packed eight …\nReturns true if all lanes are non-zero, false otherwise.\nLane-wise rounding average.\nExtracts the high bit for each lane in <code>a</code> and produce a …\nCompares two 128-bit vectors as if they were two vectors …\nInteger extended pairwise addition producing extended …\nConverts high half of the smaller lane vector to a larger …\nConverts low half of the smaller lane vector to a larger …\nLane-wise integer extended multiplication producing twice …\nLane-wise integer extended multiplication producing twice …\nExtracts a lane from a 128-bit vector interpreted as 8 …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nLoad eight 8-bit integers and zero extend each one to a …\nCompares two 128-bit vectors as if they were two vectors …\nCompares lane-wise unsigned integers, and returns the …\nCompares lane-wise unsigned integers, and returns the …\nMultiplies two 128-bit vectors as if they were two packed …\nConverts two input vectors into a smaller lane vector by …\nCompares two 128-bit vectors as if they were two vectors …\nReplaces a lane from a 128-bit vector interpreted as 8 …\nShifts each lane to the left by the specified number of …\nShifts each lane to the right by the specified number of …\nSame as <code>i8x16_shuffle</code>, except operates as if the inputs …\nCreates a vector with identical lanes.\nSubtracts two 128-bit vectors as if they were two packed …\nSubtracts two 128-bit vectors as if they were two packed …\nMaterializes a SIMD value from the provided operands.\nAdds two 128-bit vectors as if they were two packed four …\nReturns true if all lanes are non-zero, false otherwise.\nExtracts the high bit for each lane in <code>a</code> and produce a …\nCompares two 128-bit vectors as if they were two vectors …\nInteger extended pairwise addition producing extended …\nConverts high half of the smaller lane vector to a larger …\nConverts low half of the smaller lane vector to a larger …\nLane-wise integer extended multiplication producing twice …\nLane-wise integer extended multiplication producing twice …\nExtracts a lane from a 128-bit vector interpreted as 4 …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nLoad four 16-bit integers and zero extend each one to a …\nCompares two 128-bit vectors as if they were two vectors …\nCompares lane-wise unsigned integers, and returns the …\nCompares lane-wise unsigned integers, and returns the …\nMultiplies two 128-bit vectors as if they were two packed …\nCompares two 128-bit vectors as if they were two vectors …\nA relaxed version of <code>u32x4_trunc_sat_f32x4(a)</code> converts the …\nA relaxed version of <code>u32x4_trunc_sat_f64x2_zero(a)</code> …\nReplaces a lane from a 128-bit vector interpreted as 4 …\nShifts each lane to the left by the specified number of …\nShifts each lane to the right by the specified number of …\nSame as <code>i8x16_shuffle</code>, except operates as if the inputs …\nCreates a vector with identical lanes.\nSubtracts two 128-bit vectors as if they were two packed …\nConverts a 128-bit vector interpreted as four 32-bit …\nSaturating conversion of the two double-precision floating …\nMaterializes a SIMD value from the provided operands.\nAdds two 128-bit vectors as if they were two packed two …\nReturns true if all lanes are non-zero, false otherwise.\nExtracts the high bit for each lane in <code>a</code> and produce a …\nCompares two 128-bit vectors as if they were two vectors …\nConverts high half of the smaller lane vector to a larger …\nConverts low half of the smaller lane vector to a larger …\nLane-wise integer extended multiplication producing twice …\nLane-wise integer extended multiplication producing twice …\nExtracts a lane from a 128-bit vector interpreted as 2 …\nLoad two 32-bit integers and zero extend each one to a …\nMultiplies two 128-bit vectors as if they were two packed …\nCompares two 128-bit vectors as if they were two vectors …\nReplaces a lane from a 128-bit vector interpreted as 2 …\nShifts each lane to the left by the specified number of …\nShifts each lane to the right by the specified number of …\nSame as <code>i8x16_shuffle</code>, except operates as if the inputs …\nCreates a vector with identical lanes.\nSubtracts two 128-bit vectors as if they were two packed …\nMaterializes a SIMD value from the provided operands.\nAdds two 128-bit vectors as if they were two packed …\nAdds two 128-bit vectors as if they were two packed …\nReturns true if all lanes are non-zero, false otherwise.\nLane-wise rounding average.\nExtracts the high bit for each lane in <code>a</code> and produce a …\nCompares two 128-bit vectors as if they were two vectors …\nExtracts a lane from a 128-bit vector interpreted as 16 …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares lane-wise unsigned integers, and returns the …\nCompares lane-wise unsigned integers, and returns the …\nConverts two input vectors into a smaller lane vector by …\nCompares two 128-bit vectors as if they were two vectors …\nCount the number of bits set to one within each lane.\nReplaces a lane from a 128-bit vector interpreted as 16 …\nShifts each lane to the left by the specified number of …\nShifts each lane to the right by the specified number of …\nReturns a new vector with lanes selected from the lanes of …\nCreates a vector with identical lanes.\nSubtracts two 128-bit vectors as if they were two packed …\nSubtracts two 128-bit vectors as if they were two packed …\nReturns a new vector with lanes selected from the lanes of …\nGenerates the <code>unreachable</code> instruction, which causes an …\nWASM-specific 128-bit wide SIMD vector type.\nPerforms a bitwise and of the two input 128-bit vectors, …\nBitwise AND of bits of <code>a</code> and the logical inverse of bits …\nReturns <code>true</code> if any bit in <code>a</code> is set, or <code>false</code> otherwise.\nUse the bitmask in <code>c</code> to select bits from <code>v1</code> when 1 and <code>v2</code> …\nLoads a <code>v128</code> vector from the given heap address.\nLoads a 16-bit value from <code>m</code> and sets lane <code>L</code> of <code>v</code> to that …\nLoad a single element and splat to all lanes of a v128 …\nLoads a 32-bit value from <code>m</code> and sets lane <code>L</code> of <code>v</code> to that …\nLoad a single element and splat to all lanes of a v128 …\nLoad a 32-bit element into the low bits of the vector and …\nLoads a 64-bit value from <code>m</code> and sets lane <code>L</code> of <code>v</code> to that …\nLoad a single element and splat to all lanes of a v128 …\nLoad a 64-bit element into the low bits of the vector and …\nLoads an 8-bit value from <code>m</code> and sets lane <code>L</code> of <code>v</code> to that …\nLoad a single element and splat to all lanes of a v128 …\nFlips each bit of the 128-bit input vector.\nPerforms a bitwise or of the two input 128-bit vectors, …\nStores a <code>v128</code> vector to the given heap address.\nStores the 16-bit value from lane <code>L</code> of <code>v</code> into <code>m</code>\nStores the 32-bit value from lane <code>L</code> of <code>v</code> into <code>m</code>\nStores the 64-bit value from lane <code>L</code> of <code>v</code> into <code>m</code>\nStores the 8-bit value from lane <code>L</code> of <code>v</code> into <code>m</code>\nPerforms a bitwise xor of the two input 128-bit vectors, …\nMaterializes a SIMD value from the provided operands.\nCalculates the absolute value of each lane of a 128-bit …\nLane-wise addition of two 128-bit vectors interpreted as …\nLane-wise rounding to the nearest integral value not …\nConverts a 128-bit vector interpreted as four 32-bit …\nConverts a 128-bit vector interpreted as four 32-bit …\nConversion of the two double-precision floating point …\nLane-wise division of two 128-bit vectors interpreted as …\nCompares two 128-bit vectors as if they were two vectors …\nExtracts a lane from a 128-bit vector interpreted as 4 …\nLane-wise rounding to the nearest integral value not …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCalculates the lane-wise minimum of two 128-bit vectors …\nCalculates the lane-wise minimum of two 128-bit vectors …\nLane-wise multiplication of two 128-bit vectors …\nCompares two 128-bit vectors as if they were two vectors …\nLane-wise rounding to the nearest integral value; if two …\nNegates each lane of a 128-bit vector interpreted as four …\nLane-wise maximum value, defined as <code>a &lt; b ? b : a</code>\nLane-wise minimum value, defined as <code>b &lt; a ? b : a</code>\nComputes <code>a * b + c</code> with either one rounding or two …\nA relaxed version of <code>f32x4_max</code> which is either <code>f32x4_max</code> or\nA relaxed version of <code>f32x4_min</code> which is either <code>f32x4_min</code> or\nComputes <code>-a * b + c</code> with either one rounding or two …\nReplaces a lane from a 128-bit vector interpreted as 4 …\nCreates a vector with identical lanes.\nCalculates the square root of each lane of a 128-bit …\nLane-wise subtraction of two 128-bit vectors interpreted …\nLane-wise rounding to the nearest integral value with the …\nMaterializes a SIMD value from the provided operands.\nCalculates the absolute value of each lane of a 128-bit …\nLane-wise add of two 128-bit vectors interpreted as two …\nLane-wise rounding to the nearest integral value not …\nLane-wise conversion from integer to floating point.\nLane-wise conversion from integer to floating point.\nLane-wise divide of two 128-bit vectors interpreted as two …\nCompares two 128-bit vectors as if they were two vectors …\nExtracts a lane from a 128-bit vector interpreted as 2 …\nLane-wise rounding to the nearest integral value not …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCalculates the lane-wise maximum of two 128-bit vectors …\nCalculates the lane-wise minimum of two 128-bit vectors …\nLane-wise multiply of two 128-bit vectors interpreted as …\nCompares two 128-bit vectors as if they were two vectors …\nLane-wise rounding to the nearest integral value; if two …\nNegates each lane of a 128-bit vector interpreted as two …\nLane-wise maximum value, defined as <code>a &lt; b ? b : a</code>\nLane-wise minimum value, defined as <code>b &lt; a ? b : a</code>\nConversion of the two lower single-precision floating …\nComputes <code>a * b + c</code> with either one rounding or two …\nA relaxed version of <code>f64x2_max</code> which is either <code>f64x2_max</code> or\nA relaxed version of <code>f64x2_min</code> which is either <code>f64x2_min</code> or\nComputes <code>-a * b + c</code> with either one rounding or two …\nReplaces a lane from a 128-bit vector interpreted as 2 …\nCreates a vector with identical lanes.\nCalculates the square root of each lane of a 128-bit …\nLane-wise subtract of two 128-bit vectors interpreted as …\nLane-wise rounding to the nearest integral value with the …\nMaterializes a SIMD value from the provided operands.\nLane-wise wrapping absolute value.\nAdds two 128-bit vectors as if they were two packed eight …\nAdds two 128-bit vectors as if they were two packed eight …\nReturns true if all lanes are non-zero, false otherwise.\nExtracts the high bit for each lane in <code>a</code> and produce a …\nCompares two 128-bit vectors as if they were two vectors …\nInteger extended pairwise addition producing extended …\nInteger extended pairwise addition producing extended …\nConverts high half of the smaller lane vector to a larger …\nConverts high half of the smaller lane vector to a larger …\nConverts low half of the smaller lane vector to a larger …\nConverts low half of the smaller lane vector to a larger …\nLane-wise integer extended multiplication producing twice …\nLane-wise integer extended multiplication producing twice …\nLane-wise integer extended multiplication producing twice …\nLane-wise integer extended multiplication producing twice …\nExtracts a lane from a 128-bit vector interpreted as 8 …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nLoad eight 8-bit integers and sign extend each one to a …\nLoad eight 8-bit integers and zero extend each one to a …\nCompares two 128-bit vectors as if they were two vectors …\nCompares lane-wise signed integers, and returns the …\nCompares lane-wise signed integers, and returns the …\nMultiplies two 128-bit vectors as if they were two packed …\nConverts two input vectors into a smaller lane vector by …\nCompares two 128-bit vectors as if they were two vectors …\nNegates a 128-bit vectors interpreted as eight 16-bit …\nLane-wise saturating rounding multiplication in Q15 format.\nA relaxed dot-product instruction.\nA relaxed version of <code>v128_bitselect</code> where this either …\nA relaxed version of <code>i16x8_relaxed_q15mulr</code> where if both …\nReplaces a lane from a 128-bit vector interpreted as 8 …\nShifts each lane to the left by the specified number of …\nShifts each lane to the right by the specified number of …\nSame as <code>i8x16_shuffle</code>, except operates as if the inputs …\nCreates a vector with identical lanes.\nSubtracts two 128-bit vectors as if they were two packed …\nSubtracts two 128-bit vectors as if they were two packed …\nMaterializes a SIMD value from the provided operands.\nLane-wise wrapping absolute value.\nAdds two 128-bit vectors as if they were two packed four …\nReturns true if all lanes are non-zero, false otherwise.\nExtracts the high bit for each lane in <code>a</code> and produce a …\nLane-wise multiply signed 16-bit integers in the two input …\nCompares two 128-bit vectors as if they were two vectors …\nInteger extended pairwise addition producing extended …\nInteger extended pairwise addition producing extended …\nConverts high half of the smaller lane vector to a larger …\nConverts high half of the smaller lane vector to a larger …\nConverts low half of the smaller lane vector to a larger …\nConverts low half of the smaller lane vector to a larger …\nLane-wise integer extended multiplication producing twice …\nLane-wise integer extended multiplication producing twice …\nLane-wise integer extended multiplication producing twice …\nLane-wise integer extended multiplication producing twice …\nExtracts a lane from a 128-bit vector interpreted as 4 …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nLoad four 16-bit integers and sign extend each one to a …\nLoad four 16-bit integers and zero extend each one to a …\nCompares two 128-bit vectors as if they were two vectors …\nCompares lane-wise signed integers, and returns the …\nCompares lane-wise signed integers, and returns the …\nMultiplies two 128-bit vectors as if they were two packed …\nCompares two 128-bit vectors as if they were two vectors …\nNegates a 128-bit vectors interpreted as four 32-bit …\nSimilar to <code>i16x8_relaxed_dot_i8x16_i7x16</code> except that the …\nA relaxed version of <code>v128_bitselect</code> where this either …\nA relaxed version of <code>i32x4_trunc_sat_f32x4(a)</code> converts the …\nA relaxed version of <code>i32x4_trunc_sat_f64x2_zero(a)</code> …\nReplaces a lane from a 128-bit vector interpreted as 4 …\nShifts each lane to the left by the specified number of …\nShifts each lane to the right by the specified number of …\nSame as <code>i8x16_shuffle</code>, except operates as if the inputs …\nCreates a vector with identical lanes.\nSubtracts two 128-bit vectors as if they were two packed …\nConverts a 128-bit vector interpreted as four 32-bit …\nSaturating conversion of the two double-precision floating …\nMaterializes a SIMD value from the provided operands.\nLane-wise wrapping absolute value.\nAdds two 128-bit vectors as if they were two packed two …\nReturns true if all lanes are non-zero, false otherwise.\nExtracts the high bit for each lane in <code>a</code> and produce a …\nCompares two 128-bit vectors as if they were two vectors …\nConverts high half of the smaller lane vector to a larger …\nConverts high half of the smaller lane vector to a larger …\nConverts low half of the smaller lane vector to a larger …\nConverts low half of the smaller lane vector to a larger …\nLane-wise integer extended multiplication producing twice …\nLane-wise integer extended multiplication producing twice …\nLane-wise integer extended multiplication producing twice …\nLane-wise integer extended multiplication producing twice …\nExtracts a lane from a 128-bit vector interpreted as 2 …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nLoad two 32-bit integers and sign extend each one to a …\nLoad two 32-bit integers and zero extend each one to a …\nCompares two 128-bit vectors as if they were two vectors …\nMultiplies two 128-bit vectors as if they were two packed …\nCompares two 128-bit vectors as if they were two vectors …\nNegates a 128-bit vectors interpreted as two 64-bit signed …\nA relaxed version of <code>v128_bitselect</code> where this either …\nReplaces a lane from a 128-bit vector interpreted as 2 …\nShifts each lane to the left by the specified number of …\nShifts each lane to the right by the specified number of …\nSame as <code>i8x16_shuffle</code>, except operates as if the inputs …\nCreates a vector with identical lanes.\nSubtracts two 128-bit vectors as if they were two packed …\nMaterializes a SIMD value from the provided operands.\nLane-wise wrapping absolute value.\nAdds two 128-bit vectors as if they were two packed …\nAdds two 128-bit vectors as if they were two packed …\nReturns true if all lanes are non-zero, false otherwise.\nExtracts the high bit for each lane in <code>a</code> and produce a …\nCompares two 128-bit vectors as if they were two vectors …\nExtracts a lane from a 128-bit vector interpreted as 16 …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares lane-wise signed integers, and returns the …\nCompares lane-wise signed integers, and returns the …\nConverts two input vectors into a smaller lane vector by …\nCompares two 128-bit vectors as if they were two vectors …\nNegates a 128-bit vectors interpreted as sixteen 8-bit …\nCount the number of bits set to one within each lane.\nA relaxed version of <code>v128_bitselect</code> where this either …\nA relaxed version of <code>i8x16_swizzle(a, s)</code> which selects …\nReplaces a lane from a 128-bit vector interpreted as 16 …\nShifts each lane to the left by the specified number of …\nShifts each lane to the right by the specified number of …\nReturns a new vector with lanes selected from the lanes of …\nCreates a vector with identical lanes.\nSubtracts two 128-bit vectors as if they were two packed …\nSubtracts two 128-bit vectors as if they were two packed …\nReturns a new vector with lanes selected from the lanes of …\nCorresponding intrinsic to wasm’s <code>memory.atomic.notify</code> …\nCorresponding intrinsic to wasm’s <code>memory.atomic.wait32</code> …\nCorresponding intrinsic to wasm’s <code>memory.atomic.wait64</code> …\nCorresponding intrinsic to wasm’s <code>memory.grow</code> instruction\nCorresponding intrinsic to wasm’s <code>memory.size</code> instruction\nGenerates the <code>throw</code> instruction from the …\nMaterializes a SIMD value from the provided operands.\nAdds two 128-bit vectors as if they were two packed eight …\nAdds two 128-bit vectors as if they were two packed eight …\nReturns true if all lanes are non-zero, false otherwise.\nLane-wise rounding average.\nExtracts the high bit for each lane in <code>a</code> and produce a …\nCompares two 128-bit vectors as if they were two vectors …\nInteger extended pairwise addition producing extended …\nConverts high half of the smaller lane vector to a larger …\nConverts low half of the smaller lane vector to a larger …\nLane-wise integer extended multiplication producing twice …\nLane-wise integer extended multiplication producing twice …\nExtracts a lane from a 128-bit vector interpreted as 8 …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nLoad eight 8-bit integers and zero extend each one to a …\nCompares two 128-bit vectors as if they were two vectors …\nCompares lane-wise unsigned integers, and returns the …\nCompares lane-wise unsigned integers, and returns the …\nMultiplies two 128-bit vectors as if they were two packed …\nConverts two input vectors into a smaller lane vector by …\nCompares two 128-bit vectors as if they were two vectors …\nReplaces a lane from a 128-bit vector interpreted as 8 …\nShifts each lane to the left by the specified number of …\nShifts each lane to the right by the specified number of …\nSame as <code>i8x16_shuffle</code>, except operates as if the inputs …\nCreates a vector with identical lanes.\nSubtracts two 128-bit vectors as if they were two packed …\nSubtracts two 128-bit vectors as if they were two packed …\nMaterializes a SIMD value from the provided operands.\nAdds two 128-bit vectors as if they were two packed four …\nReturns true if all lanes are non-zero, false otherwise.\nExtracts the high bit for each lane in <code>a</code> and produce a …\nCompares two 128-bit vectors as if they were two vectors …\nInteger extended pairwise addition producing extended …\nConverts high half of the smaller lane vector to a larger …\nConverts low half of the smaller lane vector to a larger …\nLane-wise integer extended multiplication producing twice …\nLane-wise integer extended multiplication producing twice …\nExtracts a lane from a 128-bit vector interpreted as 4 …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nLoad four 16-bit integers and zero extend each one to a …\nCompares two 128-bit vectors as if they were two vectors …\nCompares lane-wise unsigned integers, and returns the …\nCompares lane-wise unsigned integers, and returns the …\nMultiplies two 128-bit vectors as if they were two packed …\nCompares two 128-bit vectors as if they were two vectors …\nA relaxed version of <code>u32x4_trunc_sat_f32x4(a)</code> converts the …\nA relaxed version of <code>u32x4_trunc_sat_f64x2_zero(a)</code> …\nReplaces a lane from a 128-bit vector interpreted as 4 …\nShifts each lane to the left by the specified number of …\nShifts each lane to the right by the specified number of …\nSame as <code>i8x16_shuffle</code>, except operates as if the inputs …\nCreates a vector with identical lanes.\nSubtracts two 128-bit vectors as if they were two packed …\nConverts a 128-bit vector interpreted as four 32-bit …\nSaturating conversion of the two double-precision floating …\nMaterializes a SIMD value from the provided operands.\nAdds two 128-bit vectors as if they were two packed two …\nReturns true if all lanes are non-zero, false otherwise.\nExtracts the high bit for each lane in <code>a</code> and produce a …\nCompares two 128-bit vectors as if they were two vectors …\nConverts high half of the smaller lane vector to a larger …\nConverts low half of the smaller lane vector to a larger …\nLane-wise integer extended multiplication producing twice …\nLane-wise integer extended multiplication producing twice …\nExtracts a lane from a 128-bit vector interpreted as 2 …\nLoad two 32-bit integers and zero extend each one to a …\nMultiplies two 128-bit vectors as if they were two packed …\nCompares two 128-bit vectors as if they were two vectors …\nReplaces a lane from a 128-bit vector interpreted as 2 …\nShifts each lane to the left by the specified number of …\nShifts each lane to the right by the specified number of …\nSame as <code>i8x16_shuffle</code>, except operates as if the inputs …\nCreates a vector with identical lanes.\nSubtracts two 128-bit vectors as if they were two packed …\nMaterializes a SIMD value from the provided operands.\nAdds two 128-bit vectors as if they were two packed …\nAdds two 128-bit vectors as if they were two packed …\nReturns true if all lanes are non-zero, false otherwise.\nLane-wise rounding average.\nExtracts the high bit for each lane in <code>a</code> and produce a …\nCompares two 128-bit vectors as if they were two vectors …\nExtracts a lane from a 128-bit vector interpreted as 16 …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares lane-wise unsigned integers, and returns the …\nCompares lane-wise unsigned integers, and returns the …\nConverts two input vectors into a smaller lane vector by …\nCompares two 128-bit vectors as if they were two vectors …\nCount the number of bits set to one within each lane.\nReplaces a lane from a 128-bit vector interpreted as 16 …\nShifts each lane to the left by the specified number of …\nShifts each lane to the right by the specified number of …\nReturns a new vector with lanes selected from the lanes of …\nCreates a vector with identical lanes.\nSubtracts two 128-bit vectors as if they were two packed …\nSubtracts two 128-bit vectors as if they were two packed …\nReturns a new vector with lanes selected from the lanes of …\nGenerates the <code>unreachable</code> instruction, which causes an …\nWASM-specific 128-bit wide SIMD vector type.\nPerforms a bitwise and of the two input 128-bit vectors, …\nBitwise AND of bits of <code>a</code> and the logical inverse of bits …\nReturns <code>true</code> if any bit in <code>a</code> is set, or <code>false</code> otherwise.\nUse the bitmask in <code>c</code> to select bits from <code>v1</code> when 1 and <code>v2</code> …\nLoads a <code>v128</code> vector from the given heap address.\nLoads a 16-bit value from <code>m</code> and sets lane <code>L</code> of <code>v</code> to that …\nLoad a single element and splat to all lanes of a v128 …\nLoads a 32-bit value from <code>m</code> and sets lane <code>L</code> of <code>v</code> to that …\nLoad a single element and splat to all lanes of a v128 …\nLoad a 32-bit element into the low bits of the vector and …\nLoads a 64-bit value from <code>m</code> and sets lane <code>L</code> of <code>v</code> to that …\nLoad a single element and splat to all lanes of a v128 …\nLoad a 64-bit element into the low bits of the vector and …\nLoads an 8-bit value from <code>m</code> and sets lane <code>L</code> of <code>v</code> to that …\nLoad a single element and splat to all lanes of a v128 …\nFlips each bit of the 128-bit input vector.\nPerforms a bitwise or of the two input 128-bit vectors, …\nStores a <code>v128</code> vector to the given heap address.\nStores the 16-bit value from lane <code>L</code> of <code>v</code> into <code>m</code>\nStores the 32-bit value from lane <code>L</code> of <code>v</code> into <code>m</code>\nStores the 64-bit value from lane <code>L</code> of <code>v</code> into <code>m</code>\nStores the 8-bit value from lane <code>L</code> of <code>v</code> into <code>m</code>\nPerforms a bitwise xor of the two input 128-bit vectors, …\nResult of the <code>cpuid</code> instruction.\nEqual (ordered, non-signaling)\nEqual (ordered, signaling)\nEqual (unordered, non-signaling)\nEqual (unordered, signaling)\nFalse (ordered, non-signaling)\nFalse (ordered, signaling)\nGreater-than-or-equal (ordered, non-signaling)\nGreater-than-or-equal (ordered, signaling)\nGreater-than (ordered, non-signaling)\nGreater-than (ordered, signaling)\nLess-than-or-equal (ordered, non-signaling)\nLess-than-or-equal (ordered, signaling)\nLess-than (ordered, non-signaling)\nLess-than (ordered, signaling)\nNot-equal (ordered, non-signaling)\nNot-equal (ordered, signaling)\nNot-equal (unordered, non-signaling)\nNot-equal (unordered, signaling)\nNot-greater-than-or-equal (unordered, non-signaling)\nNot-greater-than-or-equal (unordered, signaling)\nNot-greater-than (unordered, non-signaling)\nNot-greater-than (unordered, signaling)\nNot-less-than-or-equal (unordered, non-signaling)\nNot-less-than-or-equal (unordered, signaling)\nNot-less-than (unordered, non-signaling)\nNot-less-than (unordered, signaling)\nOrdered (non-signaling)\nOrdered (signaling)\nTrue (unordered, non-signaling)\nTrue (unordered, signaling)\nUnordered (non-signaling)\nUnordered (signaling)\nThe <code>_MM_CMPINT_ENUM</code> type used to specify comparison …\nEqual\nFalse\nLess-than-or-equal\nLess-than\nNot-equal\nNot less-than-or-equal\nNot less-than\nTrue\nSee <code>_mm_setcsr</code>\nSee <code>_mm_setcsr</code>\nSee <code>_mm_setcsr</code>\nSee <code>_mm_setcsr</code>\nSee <code>_MM_GET_EXCEPTION_STATE</code>\nSee <code>_mm_setcsr</code>\nSee <code>_mm_setcsr</code>\nSee <code>_MM_GET_FLUSH_ZERO_MODE</code>\nSee <code>_mm_setcsr</code>\nSee <code>_mm_setcsr</code>\nround up and do not suppress exceptions\nuse MXCSR.RC; see <code>vendor::_MM_SET_ROUNDING_MODE</code>\nround down and do not suppress exceptions\nuse MXCSR.RC and suppress exceptions; see …\nround to nearest and do not suppress exceptions\nsuppress exceptions\ndo not suppress exceptions\nuse MXCSR.RC and do not suppress exceptions; see …\nround to nearest\nround down\nround up\ntruncate\ntruncate and do not suppress exceptions\nSee <code>_mm_setcsr</code>\nSee <code>_mm_setcsr</code>\nSee <code>_mm_setcsr</code>\nSee <code>_mm_setcsr</code>\nSee <code>_mm_prefetch</code>.\nSee <code>_mm_prefetch</code>.\nSee <code>_mm_prefetch</code>.\nSee <code>_mm_prefetch</code>.\nSee <code>_mm_prefetch</code>.\nSee <code>_mm_prefetch</code>.\nThe <code>MM_MANTISSA_NORM_ENUM</code> type used to specify mantissa …\nThe <code>MM_MANTISSA_SIGN_ENUM</code> type used to specify mantissa …\ninterval [1, 2)\ninterval [0.5, 1)\ninterval [0.5, 2)\ninterval [0.75, 1.5)\nDEST = NaN if sign(SRC) = 1\nsign = sign(SRC)\nsign = 0\nSee <code>_mm_setcsr</code>\nSee <code>_mm_setcsr</code>\nSee <code>_mm_setcsr</code>\nSee <code>_mm_setcsr</code>\nSee <code>_MM_GET_EXCEPTION_MASK</code>\nSee <code>_mm_setcsr</code>\nSee <code>_mm_setcsr</code>\nThe <code>MM_PERM_ENUM</code> type used to specify shuffle operations …\nSee <code>_mm_setcsr</code>\nSee <code>_MM_GET_ROUNDING_MODE</code>\nSee <code>_mm_setcsr</code>\nSee <code>_mm_setcsr</code>\nSee <code>_mm_setcsr</code>\nSee <code>_mm_setcsr</code>\nSee <code>_mm_setcsr</code>\nSee <code>_mm_setcsr</code>\nSee <code>_mm_setcsr</code>\nA utility function for creating masks to use with Intel …\nTranspose the 4x4 matrix formed by 4 rows of __m128 in …\n<strong>Mask only</strong>: return the bit mask\nFor each character in <code>a</code>, find if it is in <code>b</code> <em>(Default)</em>\nThe strings defined by <code>a</code> and <code>b</code> are equal\nSearch for the defined substring in the target\nFor each character in <code>a</code>, determine if …\n<strong>Index only</strong>: return the least significant bit <em>(Default)</em>\nNegates results only before the end of the string\nDo not negate results before the end of the string\n<strong>Index only</strong>: return the most significant bit\nNegates results\nDo not negate results <em>(Default)</em>\nString contains signed 8-bit characters\nString contains unsigned 16-bit characters\nString contains unsigned 8-bit characters <em>(Default)</em>\n<strong>Mask only</strong>: return the byte mask\nString contains unsigned 16-bit characters\nTransaction abort due to the transaction using too much …\nTransaction abort due to a memory conflict with another …\nTransaction abort due to a debug trap.\nTransaction explicitly aborted with xabort. The parameter …\nTransaction abort in a inner nested transaction.\nTransaction retry is possible.\nTransaction successfully started.\n<code>XFEATURE_ENABLED_MASK</code> for <code>XCR</code>\nSee <code>__cpuid_count</code>.\nReturns the result of the <code>cpuid</code> instruction for a given …\nReturns the highest-supported <code>leaf</code> (<code>EAX</code>) and sub-leaf (<code>ECX</code>…\n128-bit wide set of four <code>f32</code> types, x86-specific\n128-bit wide set of eight <code>u16</code> types, x86-specific\n128-bit wide set of two <code>f64</code> types, x86-specific\n128-bit wide integer vector type, x86-specific\n256-bit wide set of eight <code>f32</code> types, x86-specific\n256-bit wide set of 16 <code>u16</code> types, x86-specific\n256-bit wide set of four <code>f64</code> types, x86-specific\n256-bit wide integer vector type, x86-specific\n512-bit wide set of sixteen <code>f32</code> types, x86-specific\n512-bit wide set of 32 <code>u16</code> types, x86-specific\n512-bit wide set of eight <code>f64</code> types, x86-specific\n512-bit wide integer vector type, x86-specific\nThe <code>__mmask16</code> type used in AVX-512 intrinsics, a 16-bit …\nThe <code>__mmask32</code> type used in AVX-512 intrinsics, a 32-bit …\nThe <code>__mmask64</code> type used in AVX-512 intrinsics, a 64-bit …\nThe <code>__mmask8</code> type used in AVX-512 intrinsics, a 8-bit …\nReads the current value of the processor’s time-stamp …\nAdds unsigned 32-bit integers <code>a</code> and <code>b</code> with unsigned 8-bit …\nAdds unsigned 32-bit integers <code>a</code> and <code>b</code> with unsigned 8-bit …\nBitwise logical <code>AND</code> of inverted <code>a</code> with <code>b</code>.\nExtracts bits of <code>a</code> specified by <code>control</code> into the least …\nExtracts bits in range [<code>start</code>, <code>start</code> + <code>length</code>) from <code>a</code> into …\nReturns the bit in position <code>b</code> of the memory addressed by <code>p</code>.\nReturns the bit in position <code>b</code> of the memory addressed by <code>p</code>…\nReturns the bit in position <code>b</code> of the memory addressed by <code>p</code>…\nReturns the bit in position <code>b</code> of the memory addressed by <code>p</code>…\nClears all bits below the least significant zero bit of <code>x</code>.\nClears all bits below the least significant zero bit of <code>x</code>.\nSets all bits of <code>x</code> to 1 except for the least significant …\nSets all bits of <code>x</code> to 1 except for the least significant …\nSets the least significant zero bit of <code>x</code> and clears all …\nSets the least significant zero bit of <code>x</code> and clears all …\nSets the least significant zero bit of <code>x</code> and clears all …\nSets the least significant zero bit of <code>x</code> and clears all …\nSets the least significant zero bit of <code>x</code>.\nSets the least significant zero bit of <code>x</code>.\nSets all bits of <code>x</code> below the least significant one.\nSets all bits of <code>x</code> below the least significant one.\nExtracts lowest set isolated bit.\nClears least significant bit and sets all other bits.\nClears least significant bit and sets all other bits.\nGets mask up to lowest set bit.\nResets the lowest set bit of <code>x</code>.\nReturns an integer with the reversed byte order of x\nZeroes higher bits of <code>a</code> &gt;= <code>index</code>.\nRestores the <code>XMM</code>, <code>MMX</code>, <code>MXCSR</code>, and <code>x87</code> FPU registers from …\nSaves the <code>x87</code> FPU, <code>MMX</code> technology, <code>XMM</code>, and <code>MXCSR</code> …\nAdd 32-bit masks in a and b, and store the result in k.\nAdd 64-bit masks in a and b, and store the result in k.\nCompute the bitwise AND of 16-bit masks a and b, and store …\nCompute the bitwise AND of 32-bit masks a and b, and store …\nCompute the bitwise AND of 64-bit masks a and b, and store …\nCompute the bitwise NOT of 16-bit masks a and then AND …\nCompute the bitwise NOT of 32-bit masks a and then AND …\nCompute the bitwise NOT of 64-bit masks a and then AND …\nCompute the bitwise NOT of 16-bit mask a, and store the …\nCompute the bitwise NOT of 32-bit mask a, and store the …\nCompute the bitwise NOT of 64-bit mask a, and store the …\nCompute the bitwise OR of 16-bit masks a and b, and store …\nCompute the bitwise OR of 32-bit masks a and b, and store …\nCompute the bitwise OR of 64-bit masks a and b, and store …\nCompute the bitwise XNOR of 16-bit masks a and b, and …\nCompute the bitwise XNOR of 32-bit masks a and b, and …\nCompute the bitwise XNOR of 64-bit masks a and b, and …\nCompute the bitwise XOR of 16-bit masks a and b, and store …\nCompute the bitwise XOR of 32-bit masks a and b, and store …\nCompute the bitwise XOR of 64-bit masks a and b, and store …\nLoad 32-bit mask from memory into k.\nLoad 64-bit mask from memory into k.\nCounts the leading most significant zero bits.\nComputes the absolute values of packed 16-bit integers in <code>a</code>…\nComputes the absolute values of packed 32-bit integers in <code>a</code>…\nCompute the absolute value of packed signed 64-bit …\nComputes the absolute values of packed 8-bit integers in <code>a</code>.\nAdds packed 16-bit integers in <code>a</code> and <code>b</code>.\nAdds packed 32-bit integers in <code>a</code> and <code>b</code>.\nAdds packed 64-bit integers in <code>a</code> and <code>b</code>.\nAdds packed 8-bit integers in <code>a</code> and <code>b</code>.\nAdds packed double-precision (64-bit) floating-point …\nAdds packed single-precision (32-bit) floating-point …\nAdds packed 16-bit integers in <code>a</code> and <code>b</code> using saturation.\nAdds packed 8-bit integers in <code>a</code> and <code>b</code> using saturation.\nAdds packed unsigned 16-bit integers in <code>a</code> and <code>b</code> using …\nAdds packed unsigned 8-bit integers in <code>a</code> and <code>b</code> using …\nAlternatively adds and subtracts packed double-precision …\nAlternatively adds and subtracts packed single-precision …\nPerforms one round of an AES decryption flow on each …\nPerforms the last round of an AES decryption flow on each …\nPerforms one round of an AES encryption flow on each …\nPerforms the last round of an AES encryption flow on each …\nConcatenate a and b into a 64-byte immediate result, shift …\nConcatenate a and b into a 64-byte immediate result, shift …\nConcatenates pairs of 16-byte blocks in <code>a</code> and <code>b</code> into a …\nComputes the bitwise AND of a packed double-precision …\nComputes the bitwise AND of packed single-precision …\nComputes the bitwise AND of 256 bits (representing integer …\nComputes the bitwise NOT of packed double-precision …\nComputes the bitwise NOT of packed single-precision …\nComputes the bitwise NOT of 256 bits (representing integer …\nAverages packed unsigned 16-bit integers in <code>a</code> and <code>b</code>.\nAverages packed unsigned 8-bit integers in <code>a</code> and <code>b</code>.\nConsiders the input <code>b</code> as packed 64-bit integers and <code>c</code> as …\nBlends packed 16-bit integers from <code>a</code> and <code>b</code> using control …\nBlends packed 32-bit integers from <code>a</code> and <code>b</code> using control …\nBlends packed double-precision (64-bit) floating-point …\nBlends packed single-precision (32-bit) floating-point …\nBlends packed 8-bit integers from <code>a</code> and <code>b</code> using <code>mask</code>.\nBlends packed double-precision (64-bit) floating-point …\nBlends packed single-precision (32-bit) floating-point …\nBroadcast the 4 packed single-precision (32-bit) …\nBroadcast the 4 packed 32-bit integers from a to all …\nBroadcasts 128 bits from memory (composed of 2 packed …\nBroadcasts 128 bits from memory (composed of 4 packed …\nBroadcasts a double-precision (64-bit) floating-point …\nBroadcasts a single-precision (32-bit) floating-point …\nBroadcasts the low packed 8-bit integer from <code>a</code> to all …\nBroadcasts the low packed 32-bit integer from <code>a</code> to all …\nBroadcast the low 8-bits from input mask k to all 64-bit …\nBroadcast the low 16-bits from input mask k to all 32-bit …\nBroadcasts the low packed 64-bit integer from <code>a</code> to all …\nBroadcasts the low double-precision (64-bit) …\nBroadcasts 128 bits of integer data from a to all 128-bit …\nBroadcasts the low single-precision (32-bit) …\nBroadcasts the low packed 16-bit integer from a to all …\nShifts 128-bit lanes in <code>a</code> left by <code>imm8</code> bytes while …\nShifts 128-bit lanes in <code>a</code> right by <code>imm8</code> bytes while …\nCasts vector of type __m128d to type __m256d; the upper …\nCasts vector of type __m256d to type __m128d.\nCast vector of type __m256d to type __m256.\nCasts vector of type __m256d to type __m256i.\nCasts vector of type __m128 to type __m256; the upper 128 …\nCasts vector of type __m256 to type __m128.\nCast vector of type __m256 to type __m256d.\nCasts vector of type __m256 to type __m256i.\nCasts vector of type __m128i to type __m256i; the upper …\nCasts vector of type __m256i to type __m256d.\nCasts vector of type __m256i to type __m256.\nCasts vector of type __m256i to type __m128i.\nRounds packed double-precision (64-bit) floating point …\nRounds packed single-precision (32-bit) floating point …\nPerforms a carry-less multiplication of two 64-bit …\nCompare packed signed 16-bit integers in a and b based on …\nCompare packed signed 32-bit integers in a and b based on …\nCompare packed signed 64-bit integers in a and b based on …\nCompare packed signed 8-bit integers in a and b based on …\nCompare packed unsigned 16-bit integers in a and b based …\nCompare packed unsigned 32-bit integers in a and b based …\nCompare packed unsigned 64-bit integers in a and b based …\nCompare packed unsigned 8-bit integers in a and b based on …\nCompares packed double-precision (64-bit) floating-point …\nCompare packed double-precision (64-bit) floating-point …\nCompares packed single-precision (32-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nCompares packed 16-bit integers in <code>a</code> and <code>b</code> for equality.\nCompare packed signed 16-bit integers in a and b for …\nCompares packed 32-bit integers in <code>a</code> and <code>b</code> for equality.\nCompare packed 32-bit integers in a and b for equality, …\nCompares packed 64-bit integers in <code>a</code> and <code>b</code> for equality.\nCompare packed 64-bit integers in a and b for equality, …\nCompares packed 8-bit integers in <code>a</code> and <code>b</code> for equality.\nCompare packed signed 8-bit integers in a and b for …\nCompare packed unsigned 16-bit integers in a and b for …\nCompare packed unsigned 32-bit integers in a and b for …\nCompare packed unsigned 64-bit integers in a and b for …\nCompare packed unsigned 8-bit integers in a and b for …\nCompare packed signed 16-bit integers in a and b for …\nCompare packed signed 32-bit integers in a and b for …\nCompare packed signed 64-bit integers in a and b for …\nCompare packed signed 8-bit integers in a and b for …\nCompare packed unsigned 16-bit integers in a and b for …\nCompare packed unsigned 32-bit integers in a and b for …\nCompare packed unsigned 64-bit integers in a and b for …\nCompare packed unsigned 8-bit integers in a and b for …\nCompares packed 16-bit integers in <code>a</code> and <code>b</code> for …\nCompare packed signed 16-bit integers in a and b for …\nCompares packed 32-bit integers in <code>a</code> and <code>b</code> for …\nCompare packed signed 32-bit integers in a and b for …\nCompares packed 64-bit integers in <code>a</code> and <code>b</code> for …\nCompare packed signed 64-bit integers in a and b for …\nCompares packed 8-bit integers in <code>a</code> and <code>b</code> for greater-than.\nCompare packed signed 8-bit integers in a and b for …\nCompare packed unsigned 16-bit integers in a and b for …\nCompare packed unsigned 32-bit integers in a and b for …\nCompare packed unsigned 64-bit integers in a and b for …\nCompare packed unsigned 8-bit integers in a and b for …\nCompare packed signed 16-bit integers in a and b for …\nCompare packed signed 32-bit integers in a and b for …\nCompare packed signed 64-bit integers in a and b for …\nCompare packed signed 8-bit integers in a and b for …\nCompare packed unsigned 16-bit integers in a and b for …\nCompare packed unsigned 32-bit integers in a and b for …\nCompare packed unsigned 64-bit integers in a and b for …\nCompare packed unsigned 8-bit integers in a and b for …\nCompare packed signed 16-bit integers in a and b for …\nCompare packed signed 32-bit integers in a and b for …\nCompare packed signed 64-bit integers in a and b for …\nCompare packed signed 8-bit integers in a and b for …\nCompare packed unsigned 16-bit integers in a and b for …\nCompare packed unsigned 32-bit integers in a and b for …\nCompare packed unsigned 64-bit integers in a and b for …\nCompare packed unsigned 8-bit integers in a and b for …\nCompare packed signed 16-bit integers in a and b for …\nCompare packed 32-bit integers in a and b for not-equal, …\nCompare packed signed 64-bit integers in a and b for …\nCompare packed signed 8-bit integers in a and b for …\nCompare packed unsigned 16-bit integers in a and b for …\nCompare packed unsigned 32-bit integers in a and b for …\nCompare packed unsigned 64-bit integers in a and b for …\nCompare packed unsigned 8-bit integers in a and b for …\nTest each 32-bit element of a for equality with all other …\nTest each 64-bit element of a for equality with all other …\nSign-extend 16-bit integers to 32-bit integers.\nSign-extend 16-bit integers to 64-bit integers.\nConvert packed 16-bit integers in a to packed 8-bit …\nConvert packed 32-bit integers in a to packed 16-bit …\nSign-extend 32-bit integers to 64-bit integers.\nConvert packed 32-bit integers in a to packed 8-bit …\nConverts packed 32-bit integers in <code>a</code> to packed …\nConverts packed 32-bit integers in <code>a</code> to packed …\nConvert packed 64-bit integers in a to packed 16-bit …\nConvert packed 64-bit integers in a to packed 32-bit …\nConvert packed 64-bit integers in a to packed 8-bit …\nSign-extend 8-bit integers to 16-bit integers.\nSign-extend 8-bit integers to 32-bit integers.\nSign-extend 8-bit integers to 64-bit integers.\nZeroes extend packed unsigned 16-bit integers in <code>a</code> to …\nZero-extend the lower four unsigned 16-bit integers in <code>a</code> …\nZero-extend unsigned 32-bit integers in <code>a</code> to 64-bit …\nConvert packed unsigned 32-bit integers in a to packed …\nZero-extend unsigned 8-bit integers in <code>a</code> to 16-bit …\nZero-extend the lower eight unsigned 8-bit integers in <code>a</code> …\nZero-extend the lower four unsigned 8-bit integers in <code>a</code> to …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConverts packed double-precision (64-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConverts packed double-precision (64-bit) floating-point …\nConverts the 8 x 16-bit half-precision float values in the …\nConverts packed single-precision (32-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConverts packed single-precision (32-bit) floating-point …\nConverts the 8 x 32-bit float values in the 256-bit vector …\nReturns the first element of the input vector of …\nConvert packed signed 16-bit integers in a to packed 8-bit …\nConvert packed signed 32-bit integers in a to packed …\nConvert packed signed 32-bit integers in a to packed 8-bit …\nConvert packed signed 64-bit integers in a to packed …\nConvert packed signed 64-bit integers in a to packed …\nConvert packed signed 64-bit integers in a to packed 8-bit …\nReturns the first element of the input vector of <code>[8 x i32]</code>.\nReturns the first element of the input vector of …\nConverts packed double-precision (64-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConverts packed single-precision (32-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed unsigned 16-bit integers in a to packed …\nConvert packed unsigned 32-bit integers in a to packed …\nConvert packed unsigned 32-bit integers in a to packed …\nConvert packed unsigned 64-bit integers in a to packed …\nConvert packed unsigned 64-bit integers in a to packed …\nConvert packed unsigned 64-bit integers in a to packed …\nCompute the sum of absolute differences (SADs) of …\nComputes the division of each of the 4 packed 64-bit …\nComputes the division of each of the 8 packed 32-bit …\nConditionally multiplies the packed single-precision …\nCompute dot-product of BF16 (16-bit) floating-point pairs …\nMultiply groups of 4 adjacent pairs of unsigned 8-bit …\nMultiply groups of 4 adjacent pairs of unsigned 8-bit …\nMultiply groups of 2 adjacent pairs of signed 16-bit …\nMultiply groups of 2 adjacent pairs of signed 16-bit …\nExtracts a 16-bit integer from <code>a</code>, selected with <code>INDEX</code>. …\nExtracts a 32-bit integer from <code>a</code>, selected with <code>INDEX</code>.\nExtracts an 8-bit integer from <code>a</code>, selected with <code>INDEX</code>. …\nExtracts 128 bits (composed of 2 packed double-precision …\nExtracts 128 bits (composed of 4 packed single-precision …\nExtracts 128 bits (composed of integer data) from <code>a</code>, …\nExtract 128 bits (composed of 4 packed single-precision …\nExtracts 128 bits (of integer data) from <code>a</code> selected with …\nExtract 128 bits (composed of 4 packed 32-bit integers) …\nFix up packed double-precision (64-bit) floating-point …\nFix up packed single-precision (32-bit) floating-point …\nRounds packed double-precision (64-bit) floating point …\nRounds packed single-precision (32-bit) floating point …\nMultiplies packed double-precision (64-bit) floating-point …\nMultiplies packed single-precision (32-bit) floating-point …\nMultiplies packed double-precision (64-bit) floating-point …\nMultiplies packed single-precision (32-bit) floating-point …\nMultiplies packed double-precision (64-bit) floating-point …\nMultiplies packed single-precision (32-bit) floating-point …\nMultiplies packed double-precision (64-bit) floating-point …\nMultiplies packed single-precision (32-bit) floating-point …\nMultiplies packed double-precision (64-bit) floating-point …\nMultiplies packed single-precision (32-bit) floating-point …\nMultiplies packed double-precision (64-bit) floating-point …\nMultiplies packed single-precision (32-bit) floating-point …\nConvert the exponent of each packed double-precision …\nConvert the exponent of each packed single-precision …\nNormalize the mantissas of packed double-precision …\nNormalize the mantissas of packed single-precision …\nPerforms an affine transformation on the packed bytes in x.\nPerforms an affine transformation on the inverted packed …\nPerforms a multiplication in GF(2^8) on the packed bytes. …\nHorizontally adds adjacent pairs of 16-bit integers in <code>a</code> …\nHorizontally adds adjacent pairs of 32-bit integers in <code>a</code> …\nHorizontal addition of adjacent pairs in the two packed …\nHorizontal addition of adjacent pairs in the two packed …\nHorizontally adds adjacent pairs of 16-bit integers in <code>a</code> …\nHorizontally subtract adjacent pairs of 16-bit integers in …\nHorizontally subtract adjacent pairs of 32-bit integers in …\nHorizontal subtraction of adjacent pairs in the two packed …\nHorizontal subtraction of adjacent pairs in the two packed …\nHorizontally subtract adjacent pairs of 16-bit integers in …\nReturns values from <code>slice</code> at offsets determined by …\nReturns values from <code>slice</code> at offsets determined by …\nReturns values from <code>slice</code> at offsets determined by …\nReturns values from <code>slice</code> at offsets determined by …\nScatter 64-bit integers from a into memory using 32-bit …\nReturns values from <code>slice</code> at offsets determined by …\nReturns values from <code>slice</code> at offsets determined by …\nReturns values from <code>slice</code> at offsets determined by …\nReturns values from <code>slice</code> at offsets determined by …\nCopies <code>a</code> to result, and inserts the 16-bit integer <code>i</code> into …\nCopies <code>a</code> to result, and inserts the 32-bit integer <code>i</code> into …\nCopies <code>a</code> to result, and inserts the 8-bit integer <code>i</code> into …\nCopies <code>a</code> to result, then inserts 128 bits (composed of 2 …\nCopies <code>a</code> to result, then inserts 128 bits (composed of 4 …\nCopies <code>a</code> to result, then inserts 128 bits from <code>b</code> into …\nCopy a to dst, then insert 128 bits (composed of 4 packed …\nCopies <code>a</code> to <code>dst</code>, then insert 128 bits (of integer data) …\nCopy a to dst, then insert 128 bits (composed of 4 packed …\nLoads 256-bits of integer data from unaligned memory into …")