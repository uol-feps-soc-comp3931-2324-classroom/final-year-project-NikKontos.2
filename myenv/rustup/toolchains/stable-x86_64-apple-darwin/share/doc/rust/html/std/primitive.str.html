<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="String slices."><title>str - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-dd39b87e5fcfba68.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="std" data-themes="" data-resource-suffix="1.80.1" data-rustdoc-version="1.80.1 (3f5fd8dd4 2024-08-06)" data-channel="1.80.1" data-search-js="search-d52510db62a78183.js" data-settings-js="settings-4313503d2e1961c2.js" ><script src="../static.files/storage-118b08c4c78b968e.js"></script><script defer src="sidebar-items1.80.1.js"></script><script defer src="../static.files/main-20a3ad099b048cf2.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-df360f571f6edeae.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc primitive"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button><a class="logo-container" href="../std/index.html"><img class="rust-logo" src="../static.files/rust-logo-151179464ae7ed46.svg" alt=""></a></nav><nav class="sidebar"><div class="sidebar-crate"><a class="logo-container" href="../std/index.html"><img class="rust-logo" src="../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2><a href="../std/index.html">std</a><span class="version">1.80.1</span></h2></div><div class="version">(3f5fd8dd4	2024-08-06)</div><h2 class="location"><a href="#">str</a></h2><div class="sidebar-elems"><section><h3><a href="#implementations">Methods</a></h3><ul class="block method"><li><a href="#method.as_ascii">as_ascii</a></li><li><a href="#method.as_bytes">as_bytes</a></li><li><a href="#method.as_bytes_mut">as_bytes_mut</a></li><li><a href="#method.as_mut_ptr">as_mut_ptr</a></li><li><a href="#method.as_ptr">as_ptr</a></li><li><a href="#method.bytes">bytes</a></li><li><a href="#method.ceil_char_boundary">ceil_char_boundary</a></li><li><a href="#method.char_indices">char_indices</a></li><li><a href="#method.chars">chars</a></li><li><a href="#method.contains">contains</a></li><li><a href="#method.encode_utf16">encode_utf16</a></li><li><a href="#method.ends_with">ends_with</a></li><li><a href="#method.eq_ignore_ascii_case">eq_ignore_ascii_case</a></li><li><a href="#method.escape_debug">escape_debug</a></li><li><a href="#method.escape_default">escape_default</a></li><li><a href="#method.escape_unicode">escape_unicode</a></li><li><a href="#method.find">find</a></li><li><a href="#method.floor_char_boundary">floor_char_boundary</a></li><li><a href="#method.get">get</a></li><li><a href="#method.get_mut">get_mut</a></li><li><a href="#method.get_unchecked">get_unchecked</a></li><li><a href="#method.get_unchecked_mut">get_unchecked_mut</a></li><li><a href="#method.into_boxed_bytes">into_boxed_bytes</a></li><li><a href="#method.into_string">into_string</a></li><li><a href="#method.is_ascii">is_ascii</a></li><li><a href="#method.is_char_boundary">is_char_boundary</a></li><li><a href="#method.is_empty">is_empty</a></li><li><a href="#method.len">len</a></li><li><a href="#method.lines">lines</a></li><li><a href="#method.lines_any">lines_any</a></li><li><a href="#method.make_ascii_lowercase">make_ascii_lowercase</a></li><li><a href="#method.make_ascii_uppercase">make_ascii_uppercase</a></li><li><a href="#method.match_indices">match_indices</a></li><li><a href="#method.matches">matches</a></li><li><a href="#method.parse">parse</a></li><li><a href="#method.repeat">repeat</a></li><li><a href="#method.replace">replace</a></li><li><a href="#method.replacen">replacen</a></li><li><a href="#method.rfind">rfind</a></li><li><a href="#method.rmatch_indices">rmatch_indices</a></li><li><a href="#method.rmatches">rmatches</a></li><li><a href="#method.rsplit">rsplit</a></li><li><a href="#method.rsplit_once">rsplit_once</a></li><li><a href="#method.rsplit_terminator">rsplit_terminator</a></li><li><a href="#method.rsplitn">rsplitn</a></li><li><a href="#method.slice_mut_unchecked">slice_mut_unchecked</a></li><li><a href="#method.slice_unchecked">slice_unchecked</a></li><li><a href="#method.split">split</a></li><li><a href="#method.split_ascii_whitespace">split_ascii_whitespace</a></li><li><a href="#method.split_at">split_at</a></li><li><a href="#method.split_at_checked">split_at_checked</a></li><li><a href="#method.split_at_mut">split_at_mut</a></li><li><a href="#method.split_at_mut_checked">split_at_mut_checked</a></li><li><a href="#method.split_inclusive">split_inclusive</a></li><li><a href="#method.split_once">split_once</a></li><li><a href="#method.split_terminator">split_terminator</a></li><li><a href="#method.split_whitespace">split_whitespace</a></li><li><a href="#method.splitn">splitn</a></li><li><a href="#method.starts_with">starts_with</a></li><li><a href="#method.strip_prefix">strip_prefix</a></li><li><a href="#method.strip_suffix">strip_suffix</a></li><li><a href="#method.to_ascii_lowercase">to_ascii_lowercase</a></li><li><a href="#method.to_ascii_uppercase">to_ascii_uppercase</a></li><li><a href="#method.to_lowercase">to_lowercase</a></li><li><a href="#method.to_uppercase">to_uppercase</a></li><li><a href="#method.trim">trim</a></li><li><a href="#method.trim_ascii">trim_ascii</a></li><li><a href="#method.trim_ascii_end">trim_ascii_end</a></li><li><a href="#method.trim_ascii_start">trim_ascii_start</a></li><li><a href="#method.trim_end">trim_end</a></li><li><a href="#method.trim_end_matches">trim_end_matches</a></li><li><a href="#method.trim_left">trim_left</a></li><li><a href="#method.trim_left_matches">trim_left_matches</a></li><li><a href="#method.trim_matches">trim_matches</a></li><li><a href="#method.trim_right">trim_right</a></li><li><a href="#method.trim_right_matches">trim_right_matches</a></li><li><a href="#method.trim_start">trim_start</a></li><li><a href="#method.trim_start_matches">trim_start_matches</a></li></ul><h3><a href="#trait-implementations">Trait Implementations</a></h3><ul class="block trait-implementation"><li><a href="#impl-Error-for-%26str">!Error</a></li><li><a href="#impl-Add%3C%26str%3E-for-Cow%3C'a,+str%3E">Add&lt;&amp;&#x27;a str&gt;</a></li><li><a href="#impl-Add%3C%26str%3E-for-String">Add&lt;&amp;str&gt;</a></li><li><a href="#impl-AddAssign%3C%26str%3E-for-Cow%3C'a,+str%3E">AddAssign&lt;&amp;&#x27;a str&gt;</a></li><li><a href="#impl-AddAssign%3C%26str%3E-for-String">AddAssign&lt;&amp;str&gt;</a></li><li><a href="#impl-AsMut%3Cstr%3E-for-String">AsMut&lt;str&gt;</a></li><li><a href="#impl-AsMut%3Cstr%3E-for-str">AsMut&lt;str&gt;</a></li><li><a href="#impl-AsRef%3COsStr%3E-for-str">AsRef&lt;OsStr&gt;</a></li><li><a href="#impl-AsRef%3CPath%3E-for-str">AsRef&lt;Path&gt;</a></li><li><a href="#impl-AsRef%3C%5Bu8%5D%3E-for-str">AsRef&lt;[u8]&gt;</a></li><li><a href="#impl-AsRef%3Cstr%3E-for-Drain%3C'a%3E">AsRef&lt;str&gt;</a></li><li><a href="#impl-AsRef%3Cstr%3E-for-String">AsRef&lt;str&gt;</a></li><li><a href="#impl-AsRef%3Cstr%3E-for-str">AsRef&lt;str&gt;</a></li><li><a href="#impl-AsciiExt-for-str">AsciiExt</a></li><li><a href="#impl-Borrow%3Cstr%3E-for-String">Borrow&lt;str&gt;</a></li><li><a href="#impl-BorrowMut%3Cstr%3E-for-String">BorrowMut&lt;str&gt;</a></li><li><a href="#impl-Clone-for-Box%3Cstr%3E">Clone</a></li><li><a href="#impl-Concat%3Cstr%3E-for-%5BS%5D">Concat&lt;str&gt;</a></li><li><a href="#impl-ConstParamTy-for-str">ConstParamTy</a></li><li><a href="#impl-Debug-for-str">Debug</a></li><li><a href="#impl-Default-for-%26mut+str">Default</a></li><li><a href="#impl-Default-for-%26str">Default</a></li><li><a href="#impl-Default-for-Box%3Cstr%3E">Default</a></li><li><a href="#impl-Display-for-str">Display</a></li><li><a href="#impl-Eq-for-str">Eq</a></li><li><a href="#impl-Extend%3C%26str%3E-for-String">Extend&lt;&amp;&#x27;a str&gt;</a></li><li><a href="#impl-From%3C%26str%3E-for-Cow%3C'a,+str%3E">From&lt;&amp;&#x27;a str&gt;</a></li><li><a href="#impl-From%3C%26mut+str%3E-for-String">From&lt;&amp;mut str&gt;</a></li><li><a href="#impl-From%3C%26str%3E-for-Arc%3Cstr%3E">From&lt;&amp;str&gt;</a></li><li><a href="#impl-From%3C%26str%3E-for-Box%3Cdyn+Error%3E">From&lt;&amp;str&gt;</a></li><li><a href="#impl-From%3C%26str%3E-for-Box%3Cdyn+Error+%2B+Send+%2B+Sync%3E">From&lt;&amp;str&gt;</a></li><li><a href="#impl-From%3C%26str%3E-for-Box%3Cstr%3E">From&lt;&amp;str&gt;</a></li><li><a href="#impl-From%3C%26str%3E-for-Rc%3Cstr%3E">From&lt;&amp;str&gt;</a></li><li><a href="#impl-From%3C%26str%3E-for-String">From&lt;&amp;str&gt;</a></li><li><a href="#impl-From%3C%26str%3E-for-Vec%3Cu8%3E">From&lt;&amp;str&gt;</a></li><li><a href="#impl-From%3CCow%3C'_,+str%3E%3E-for-Box%3Cstr%3E">From&lt;Cow&lt;&#x27;_, str&gt;&gt;</a></li><li><a href="#impl-From%3CString%3E-for-Box%3Cstr%3E">From&lt;String&gt;</a></li><li><a href="#impl-FromIterator%3C%26char%3E-for-Box%3Cstr%3E">FromIterator&lt;&amp;&#x27;a char&gt;</a></li><li><a href="#impl-FromIterator%3C%26str%3E-for-Box%3Cstr%3E">FromIterator&lt;&amp;&#x27;a str&gt;</a></li><li><a href="#impl-FromIterator%3C%26str%3E-for-String">FromIterator&lt;&amp;&#x27;a str&gt;</a></li><li><a href="#impl-FromIterator%3C%26str%3E-for-Cow%3C'a,+str%3E">FromIterator&lt;&amp;&#x27;b str&gt;</a></li><li><a href="#impl-FromIterator%3CBox%3Cstr,+A%3E%3E-for-Box%3Cstr%3E">FromIterator&lt;Box&lt;str, A&gt;&gt;</a></li><li><a href="#impl-FromIterator%3CCow%3C'a,+str%3E%3E-for-Box%3Cstr%3E">FromIterator&lt;Cow&lt;&#x27;a, str&gt;&gt;</a></li><li><a href="#impl-FromIterator%3CString%3E-for-Box%3Cstr%3E">FromIterator&lt;String&gt;</a></li><li><a href="#impl-FromIterator%3Cchar%3E-for-Box%3Cstr%3E">FromIterator&lt;char&gt;</a></li><li><a href="#impl-Hash-for-str">Hash</a></li><li><a href="#impl-Index%3CI%3E-for-str">Index&lt;I&gt;</a></li><li><a href="#impl-IndexMut%3CI%3E-for-str">IndexMut&lt;I&gt;</a></li><li><a href="#impl-Join%3C%26str%3E-for-%5BS%5D">Join&lt;&amp;str&gt;</a></li><li><a href="#impl-Ord-for-str">Ord</a></li><li><a href="#impl-PartialEq-for-str">PartialEq</a></li><li><a href="#impl-PartialEq%3C%26str%3E-for-String">PartialEq&lt;&amp;&#x27;a str&gt;</a></li><li><a href="#impl-PartialEq%3C%26str%3E-for-Cow%3C'a,+str%3E">PartialEq&lt;&amp;&#x27;b str&gt;</a></li><li><a href="#impl-PartialEq%3C%26str%3E-for-OsString">PartialEq&lt;&amp;str&gt;</a></li><li><a href="#impl-PartialEq%3CCow%3C'a,+str%3E%3E-for-%26str">PartialEq&lt;Cow&lt;&#x27;a, str&gt;&gt;</a></li><li><a href="#impl-PartialEq%3CCow%3C'a,+str%3E%3E-for-str">PartialEq&lt;Cow&lt;&#x27;a, str&gt;&gt;</a></li><li><a href="#impl-PartialEq%3COsStr%3E-for-str">PartialEq&lt;OsStr&gt;</a></li><li><a href="#impl-PartialEq%3COsString%3E-for-%26str">PartialEq&lt;OsString&gt;</a></li><li><a href="#impl-PartialEq%3COsString%3E-for-str">PartialEq&lt;OsString&gt;</a></li><li><a href="#impl-PartialEq%3CString%3E-for-%26str">PartialEq&lt;String&gt;</a></li><li><a href="#impl-PartialEq%3CString%3E-for-str">PartialEq&lt;String&gt;</a></li><li><a href="#impl-PartialEq%3Cstr%3E-for-Cow%3C'a,+str%3E">PartialEq&lt;str&gt;</a></li><li><a href="#impl-PartialEq%3Cstr%3E-for-OsStr">PartialEq&lt;str&gt;</a></li><li><a href="#impl-PartialEq%3Cstr%3E-for-OsString">PartialEq&lt;str&gt;</a></li><li><a href="#impl-PartialEq%3Cstr%3E-for-String">PartialEq&lt;str&gt;</a></li><li><a href="#impl-PartialOrd-for-str">PartialOrd</a></li><li><a href="#impl-PartialOrd%3Cstr%3E-for-OsStr">PartialOrd&lt;str&gt;</a></li><li><a href="#impl-PartialOrd%3Cstr%3E-for-OsString">PartialOrd&lt;str&gt;</a></li><li><a href="#impl-Pattern%3C'a%3E-for-%26str">Pattern&lt;&#x27;a&gt;</a></li><li><a href="#impl-SliceIndex%3Cstr%3E-for-(Bound%3Cusize%3E,+Bound%3Cusize%3E)">SliceIndex&lt;str&gt;</a></li><li><a href="#impl-SliceIndex%3Cstr%3E-for-Range%3Cusize%3E">SliceIndex&lt;str&gt;</a></li><li><a href="#impl-SliceIndex%3Cstr%3E-for-RangeFrom%3Cusize%3E">SliceIndex&lt;str&gt;</a></li><li><a href="#impl-SliceIndex%3Cstr%3E-for-RangeFull">SliceIndex&lt;str&gt;</a></li><li><a href="#impl-SliceIndex%3Cstr%3E-for-RangeInclusive%3Cusize%3E">SliceIndex&lt;str&gt;</a></li><li><a href="#impl-SliceIndex%3Cstr%3E-for-RangeTo%3Cusize%3E">SliceIndex&lt;str&gt;</a></li><li><a href="#impl-SliceIndex%3Cstr%3E-for-RangeToInclusive%3Cusize%3E">SliceIndex&lt;str&gt;</a></li><li><a href="#impl-StructuralPartialEq-for-str">StructuralPartialEq</a></li><li><a href="#impl-ToOwned-for-str">ToOwned</a></li><li><a href="#impl-ToSocketAddrs-for-str">ToSocketAddrs</a></li><li><a href="#impl-TryFrom%3C%26OsStr%3E-for-%26str">TryFrom&lt;&amp;&#x27;a OsStr&gt;</a></li></ul><h3><a href="#synthetic-implementations">Auto Trait Implementations</a></h3><ul class="block synthetic-implementation"><li><a href="#impl-Sized-for-str">!Sized</a></li><li><a href="#impl-Freeze-for-str">Freeze</a></li><li><a href="#impl-RefUnwindSafe-for-str">RefUnwindSafe</a></li><li><a href="#impl-Send-for-str">Send</a></li><li><a href="#impl-Sync-for-str">Sync</a></li><li><a href="#impl-Unpin-for-str">Unpin</a></li><li><a href="#impl-UnwindSafe-for-str">UnwindSafe</a></li></ul><h3><a href="#blanket-implementations">Blanket Implementations</a></h3><ul class="block blanket-implementation"><li><a href="#impl-Any-for-T">Any</a></li><li><a href="#impl-Borrow%3CT%3E-for-T">Borrow&lt;T&gt;</a></li><li><a href="#impl-BorrowMut%3CT%3E-for-T">BorrowMut&lt;T&gt;</a></li><li><a href="#impl-ToString-for-T">ToString</a></li></ul></section><h2><a href="index.html">In crate std</a></h2></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1>Primitive Type <a class="primitive" href="#">str</a><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><span class="out-of-band"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>String slices.</p>
<p><em><a href="str/index.html" title="mod std::str">See also the <code>std::str</code> module</a>.</em></p>
<p>The <code>str</code> type, also called a â€˜string sliceâ€™, is the most primitive string
type. It is usually seen in its borrowed form, <code>&amp;str</code>. It is also the type
of string literals, <code>&amp;'static str</code>.</p>
<h2 id="basic-usage"><a class="doc-anchor" href="#basic-usage">Â§</a>Basic Usage</h2>
<p>String literals are string slices:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>hello_world = <span class="string">"Hello, World!"</span>;</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+hello_world+=+%22Hello,+World!%22;%0A%7D&amp;edition=2021">Run</a></div>
<p>Here we have declared a string slice initialized with a string literal.
String literals have a static lifetime, which means the string <code>hello_world</code>
is guaranteed to be valid for the duration of the entire program.
We can explicitly specify <code>hello_world</code>â€™s lifetime as well:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>hello_world: <span class="kw-2">&amp;</span><span class="lifetime">'static </span>str = <span class="string">"Hello, world!"</span>;</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+hello_world:+%26'static+str+=+%22Hello,+world!%22;%0A%7D&amp;edition=2021">Run</a></div>
<h2 id="representation"><a class="doc-anchor" href="#representation">Â§</a>Representation</h2>
<p>A <code>&amp;str</code> is made up of two components: a pointer to some bytes, and a
length. You can look at these with the <a href="primitive.str.html#method.as_ptr" title="method str::as_ptr"><code>as_ptr</code></a> and <a href="primitive.str.html#method.len" title="method str::len"><code>len</code></a> methods:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::slice;
<span class="kw">use </span>std::str;

<span class="kw">let </span>story = <span class="string">"Once upon a time..."</span>;

<span class="kw">let </span>ptr = story.as_ptr();
<span class="kw">let </span>len = story.len();

<span class="comment">// story has nineteen bytes
</span><span class="macro">assert_eq!</span>(<span class="number">19</span>, len);

<span class="comment">// We can re-build a str out of ptr and len. This is all unsafe because
// we are responsible for making sure the two components are valid:
</span><span class="kw">let </span>s = <span class="kw">unsafe </span>{
    <span class="comment">// First, we build a &amp;[u8]...
    </span><span class="kw">let </span>slice = slice::from_raw_parts(ptr, len);

    <span class="comment">// ... and then convert that slice into a string slice
    </span>str::from_utf8(slice)
};

<span class="macro">assert_eq!</span>(s, <span class="prelude-val">Ok</span>(story));</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::slice;%0A++++use+std::str;%0A++++%0A++++let+story+=+%22Once+upon+a+time...%22;%0A++++%0A++++let+ptr+=+story.as_ptr();%0A++++let+len+=+story.len();%0A++++%0A++++//+story+has+nineteen+bytes%0A++++assert_eq!(19,+len);%0A++++%0A++++//+We+can+re-build+a+str+out+of+ptr+and+len.+This+is+all+unsafe+because%0A++++//+we+are+responsible+for+making+sure+the+two+components+are+valid:%0A++++let+s+=+unsafe+%7B%0A++++++++//+First,+we+build+a+%26%5Bu8%5D...%0A++++++++let+slice+=+slice::from_raw_parts(ptr,+len);%0A++++%0A++++++++//+...+and+then+convert+that+slice+into+a+string+slice%0A++++++++str::from_utf8(slice)%0A++++%7D;%0A++++%0A++++assert_eq!(s,+Ok(story));%0A%7D&amp;edition=2021">Run</a></div>
<p>Note: This example shows the internals of <code>&amp;str</code>. <code>unsafe</code> should not be
used to get a string slice under normal circumstances. Use <code>as_str</code>
instead.</p>
<h2 id="invariant"><a class="doc-anchor" href="#invariant">Â§</a>Invariant</h2>
<p>Rust libraries may assume that string slices are always valid UTF-8.</p>
<p>Constructing a non-UTF-8 string slice is not immediate undefined behavior, but any function
called on a string slice may assume that it is valid UTF-8, which means that a non-UTF-8 string
slice can lead to undefined behavior down the road.</p>
</div></details><h2 id="implementations" class="section-header">Implementations<a href="#implementations" class="anchor">Â§</a></h2><div id="implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-str" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/str/mod.rs.html#139">source</a><a href="#impl-str" class="anchor">Â§</a><h3 class="code-header">impl <a class="primitive" href="primitive.str.html">str</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.len" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0, const since 1.39.0">1.0.0 (const: 1.39.0)</span> Â· <a class="src" href="https://doc.rust-lang.org/1.80.1/src/core/str/mod.rs.html#160">source</a></span><h4 class="code-header">pub const fn <a href="#method.len" class="fn">len</a>(&amp;self) -&gt; <a class="primitive" href="primitive.usize.html">usize</a></h4></section></summary><div class="docblock"><p>Returns the length of <code>self</code>.</p>
<p>This length is in bytes, not <a href="primitive.char.html" title="primitive char"><code>char</code></a>s or graphemes. In other words,
it might not be what a human considers the length of the string.</p>
<h5 id="examples"><a class="doc-anchor" href="#examples">Â§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>len = <span class="string">"foo"</span>.len();
<span class="macro">assert_eq!</span>(<span class="number">3</span>, len);

<span class="macro">assert_eq!</span>(<span class="string">"Æ’oo"</span>.len(), <span class="number">4</span>); <span class="comment">// fancy f!
</span><span class="macro">assert_eq!</span>(<span class="string">"Æ’oo"</span>.chars().count(), <span class="number">3</span>);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+len+=+%22foo%22.len();%0A++++assert_eq!(3,+len);%0A++++%0A++++assert_eq!(%22%C6%92oo%22.len(),+4);+//+fancy+f!%0A++++assert_eq!(%22%C6%92oo%22.chars().count(),+3);%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.is_empty" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0, const since 1.39.0">1.0.0 (const: 1.39.0)</span> Â· <a class="src" href="https://doc.rust-lang.org/1.80.1/src/core/str/mod.rs.html#179">source</a></span><h4 class="code-header">pub const fn <a href="#method.is_empty" class="fn">is_empty</a>(&amp;self) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Returns <code>true</code> if <code>self</code> has a length of zero bytes.</p>
<h5 id="examples-1"><a class="doc-anchor" href="#examples-1">Â§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>s = <span class="string">""</span>;
<span class="macro">assert!</span>(s.is_empty());

<span class="kw">let </span>s = <span class="string">"not empty"</span>;
<span class="macro">assert!</span>(!s.is_empty());</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+s+=+%22%22;%0A++++assert!(s.is_empty());%0A++++%0A++++let+s+=+%22not+empty%22;%0A++++assert!(!s.is_empty());%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.is_char_boundary" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.9.0">1.9.0</span> Â· <a class="src" href="https://doc.rust-lang.org/1.80.1/src/core/str/mod.rs.html#209">source</a></span><h4 class="code-header">pub fn <a href="#method.is_char_boundary" class="fn">is_char_boundary</a>(&amp;self, index: <a class="primitive" href="primitive.usize.html">usize</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Checks that <code>index</code>-th byte is the first byte in a UTF-8 code point
sequence or the end of the string.</p>
<p>The start and end of the string (when <code>index == self.len()</code>) are
considered to be boundaries.</p>
<p>Returns <code>false</code> if <code>index</code> is greater than <code>self.len()</code>.</p>
<h5 id="examples-2"><a class="doc-anchor" href="#examples-2">Â§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>s = <span class="string">"LÃ¶we è€è™ LÃ©opard"</span>;
<span class="macro">assert!</span>(s.is_char_boundary(<span class="number">0</span>));
<span class="comment">// start of `è€`
</span><span class="macro">assert!</span>(s.is_char_boundary(<span class="number">6</span>));
<span class="macro">assert!</span>(s.is_char_boundary(s.len()));

<span class="comment">// second byte of `Ã¶`
</span><span class="macro">assert!</span>(!s.is_char_boundary(<span class="number">2</span>));

<span class="comment">// third byte of `è€`
</span><span class="macro">assert!</span>(!s.is_char_boundary(<span class="number">8</span>));</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+s+=+%22L%C3%B6we+%E8%80%81%E8%99%8E+L%C3%A9opard%22;%0A++++assert!(s.is_char_boundary(0));%0A++++//+start+of+%60%E8%80%81%60%0A++++assert!(s.is_char_boundary(6));%0A++++assert!(s.is_char_boundary(s.len()));%0A++++%0A++++//+second+byte+of+%60%C3%B6%60%0A++++assert!(!s.is_char_boundary(2));%0A++++%0A++++//+third+byte+of+%60%E8%80%81%60%0A++++assert!(!s.is_char_boundary(8));%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.floor_char_boundary" class="method"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/str/mod.rs.html#256">source</a><h4 class="code-header">pub fn <a href="#method.floor_char_boundary" class="fn">floor_char_boundary</a>(&amp;self, index: <a class="primitive" href="primitive.usize.html">usize</a>) -&gt; <a class="primitive" href="primitive.usize.html">usize</a></h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>round_char_boundary</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/93743">#93743</a>)</span></div></span></summary><div class="docblock"><p>Finds the closest <code>x</code> not exceeding <code>index</code> where <code>is_char_boundary(x)</code> is <code>true</code>.</p>
<p>This method can help you truncate a string so that itâ€™s still valid UTF-8, but doesnâ€™t
exceed a given number of bytes. Note that this is done purely at the character level
and can still visually split graphemes, even though the underlying characters arenâ€™t
split. For example, the emoji ğŸ§‘â€ğŸ”¬ (scientist) could be split so that the string only
includes ğŸ§‘ (person) instead.</p>
<h5 id="examples-3"><a class="doc-anchor" href="#examples-3">Â§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(round_char_boundary)]
</span><span class="kw">let </span>s = <span class="string">"â¤ï¸ğŸ§¡ğŸ’›ğŸ’šğŸ’™ğŸ’œ"</span>;
<span class="macro">assert_eq!</span>(s.len(), <span class="number">26</span>);
<span class="macro">assert!</span>(!s.is_char_boundary(<span class="number">13</span>));

<span class="kw">let </span>closest = s.floor_char_boundary(<span class="number">13</span>);
<span class="macro">assert_eq!</span>(closest, <span class="number">10</span>);
<span class="macro">assert_eq!</span>(<span class="kw-2">&amp;</span>s[..closest], <span class="string">"â¤ï¸ğŸ§¡"</span>);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(round_char_boundary)%5D%0Afn+main()+%7B%0A++++let+s+=+%22%E2%9D%A4%EF%B8%8F%F0%9F%A7%A1%F0%9F%92%9B%F0%9F%92%9A%F0%9F%92%99%F0%9F%92%9C%22;%0A++++assert_eq!(s.len(),+26);%0A++++assert!(!s.is_char_boundary(13));%0A++++%0A++++let+closest+=+s.floor_char_boundary(13);%0A++++assert_eq!(closest,+10);%0A++++assert_eq!(%26s%5B..closest%5D,+%22%E2%9D%A4%EF%B8%8F%F0%9F%A7%A1%22);%0A%7D&amp;version=nightly&amp;edition=2021">Run</a></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.ceil_char_boundary" class="method"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/str/mod.rs.html#294">source</a><h4 class="code-header">pub fn <a href="#method.ceil_char_boundary" class="fn">ceil_char_boundary</a>(&amp;self, index: <a class="primitive" href="primitive.usize.html">usize</a>) -&gt; <a class="primitive" href="primitive.usize.html">usize</a></h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>round_char_boundary</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/93743">#93743</a>)</span></div></span></summary><div class="docblock"><p>Finds the closest <code>x</code> not below <code>index</code> where <code>is_char_boundary(x)</code> is <code>true</code>.</p>
<p>If <code>index</code> is greater than the length of the string, this returns the length of the string.</p>
<p>This method is the natural complement to <a href="primitive.str.html#method.floor_char_boundary" title="method str::floor_char_boundary"><code>floor_char_boundary</code></a>. See that method
for more details.</p>
<h5 id="examples-4"><a class="doc-anchor" href="#examples-4">Â§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(round_char_boundary)]
</span><span class="kw">let </span>s = <span class="string">"â¤ï¸ğŸ§¡ğŸ’›ğŸ’šğŸ’™ğŸ’œ"</span>;
<span class="macro">assert_eq!</span>(s.len(), <span class="number">26</span>);
<span class="macro">assert!</span>(!s.is_char_boundary(<span class="number">13</span>));

<span class="kw">let </span>closest = s.ceil_char_boundary(<span class="number">13</span>);
<span class="macro">assert_eq!</span>(closest, <span class="number">14</span>);
<span class="macro">assert_eq!</span>(<span class="kw-2">&amp;</span>s[..closest], <span class="string">"â¤ï¸ğŸ§¡ğŸ’›"</span>);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(round_char_boundary)%5D%0Afn+main()+%7B%0A++++let+s+=+%22%E2%9D%A4%EF%B8%8F%F0%9F%A7%A1%F0%9F%92%9B%F0%9F%92%9A%F0%9F%92%99%F0%9F%92%9C%22;%0A++++assert_eq!(s.len(),+26);%0A++++assert!(!s.is_char_boundary(13));%0A++++%0A++++let+closest+=+s.ceil_char_boundary(13);%0A++++assert_eq!(closest,+14);%0A++++assert_eq!(%26s%5B..closest%5D,+%22%E2%9D%A4%EF%B8%8F%F0%9F%A7%A1%F0%9F%92%9B%22);%0A%7D&amp;version=nightly&amp;edition=2021">Run</a></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.as_bytes" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0, const since 1.39.0">1.0.0 (const: 1.39.0)</span> Â· <a class="src" href="https://doc.rust-lang.org/1.80.1/src/core/str/mod.rs.html#320">source</a></span><h4 class="code-header">pub const fn <a href="#method.as_bytes" class="fn">as_bytes</a>(&amp;self) -&gt; &amp;[<a class="primitive" href="primitive.u8.html">u8</a>] <a href="#" class="tooltip" data-notable-ty="&amp;[u8]">â“˜</a></h4></section></summary><div class="docblock"><p>Converts a string slice to a byte slice. To convert the byte slice back
into a string slice, use the <a href="str/fn.from_utf8.html" title="fn std::str::from_utf8"><code>from_utf8</code></a> function.</p>
<h5 id="examples-5"><a class="doc-anchor" href="#examples-5">Â§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>bytes = <span class="string">"bors"</span>.as_bytes();
<span class="macro">assert_eq!</span>(<span class="string">b"bors"</span>, bytes);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+bytes+=+%22bors%22.as_bytes();%0A++++assert_eq!(b%22bors%22,+bytes);%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.as_bytes_mut" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.20.0">1.20.0</span> Â· <a class="src" href="https://doc.rust-lang.org/1.80.1/src/core/str/mod.rs.html#364">source</a></span><h4 class="code-header">pub unsafe fn <a href="#method.as_bytes_mut" class="fn">as_bytes_mut</a>(&amp;mut self) -&gt; &amp;mut [<a class="primitive" href="primitive.u8.html">u8</a>] <a href="#" class="tooltip" data-notable-ty="&amp;mut [u8]">â“˜</a></h4></section></summary><div class="docblock"><p>Converts a mutable string slice to a mutable byte slice.</p>
<h5 id="safety"><a class="doc-anchor" href="#safety">Â§</a>Safety</h5>
<p>The caller must ensure that the content of the slice is valid UTF-8
before the borrow ends and the underlying <code>str</code> is used.</p>
<p>Use of a <code>str</code> whose contents are not valid UTF-8 is undefined behavior.</p>
<h5 id="examples-6"><a class="doc-anchor" href="#examples-6">Â§</a>Examples</h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span><span class="kw-2">mut </span>s = String::from(<span class="string">"Hello"</span>);
<span class="kw">let </span>bytes = <span class="kw">unsafe </span>{ s.as_bytes_mut() };

<span class="macro">assert_eq!</span>(<span class="string">b"Hello"</span>, bytes);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+mut+s+=+String::from(%22Hello%22);%0A++++let+bytes+=+unsafe+%7B+s.as_bytes_mut()+%7D;%0A++++%0A++++assert_eq!(b%22Hello%22,+bytes);%0A%7D&amp;edition=2021">Run</a></div>
<p>Mutability:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span><span class="kw-2">mut </span>s = String::from(<span class="string">"ğŸ—»âˆˆğŸŒ"</span>);

<span class="kw">unsafe </span>{
    <span class="kw">let </span>bytes = s.as_bytes_mut();

    bytes[<span class="number">0</span>] = <span class="number">0xF0</span>;
    bytes[<span class="number">1</span>] = <span class="number">0x9F</span>;
    bytes[<span class="number">2</span>] = <span class="number">0x8D</span>;
    bytes[<span class="number">3</span>] = <span class="number">0x94</span>;
}

<span class="macro">assert_eq!</span>(<span class="string">"ğŸ”âˆˆğŸŒ"</span>, s);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+mut+s+=+String::from(%22%F0%9F%97%BB%E2%88%88%F0%9F%8C%8F%22);%0A++++%0A++++unsafe+%7B%0A++++++++let+bytes+=+s.as_bytes_mut();%0A++++%0A++++++++bytes%5B0%5D+=+0xF0;%0A++++++++bytes%5B1%5D+=+0x9F;%0A++++++++bytes%5B2%5D+=+0x8D;%0A++++++++bytes%5B3%5D+=+0x94;%0A++++%7D%0A++++%0A++++assert_eq!(%22%F0%9F%8D%94%E2%88%88%F0%9F%8C%8F%22,+s);%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.as_ptr" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0, const since 1.32.0">1.0.0 (const: 1.32.0)</span> Â· <a class="src" href="https://doc.rust-lang.org/1.80.1/src/core/str/mod.rs.html#394">source</a></span><h4 class="code-header">pub const fn <a href="#method.as_ptr" class="fn">as_ptr</a>(&amp;self) -&gt; <a class="primitive" href="primitive.pointer.html">*const </a><a class="primitive" href="primitive.u8.html">u8</a></h4></section></summary><div class="docblock"><p>Converts a string slice to a raw pointer.</p>
<p>As string slices are a slice of bytes, the raw pointer points to a
<a href="primitive.u8.html" title="primitive u8"><code>u8</code></a>. This pointer will be pointing to the first byte of the string
slice.</p>
<p>The caller must ensure that the returned pointer is never written to.
If you need to mutate the contents of the string slice, use <a href="primitive.str.html#method.as_mut_ptr" title="method str::as_mut_ptr"><code>as_mut_ptr</code></a>.</p>
<h5 id="examples-7"><a class="doc-anchor" href="#examples-7">Â§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>s = <span class="string">"Hello"</span>;
<span class="kw">let </span>ptr = s.as_ptr();</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+s+=+%22Hello%22;%0A++++let+ptr+=+s.as_ptr();%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.as_mut_ptr" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.36.0">1.36.0</span> Â· <a class="src" href="https://doc.rust-lang.org/1.80.1/src/core/str/mod.rs.html#410">source</a></span><h4 class="code-header">pub fn <a href="#method.as_mut_ptr" class="fn">as_mut_ptr</a>(&amp;mut self) -&gt; <a class="primitive" href="primitive.pointer.html">*mut </a><a class="primitive" href="primitive.u8.html">u8</a></h4></section></summary><div class="docblock"><p>Converts a mutable string slice to a raw pointer.</p>
<p>As string slices are a slice of bytes, the raw pointer points to a
<a href="primitive.u8.html" title="primitive u8"><code>u8</code></a>. This pointer will be pointing to the first byte of the string
slice.</p>
<p>It is your responsibility to make sure that the string slice only gets
modified in a way that it remains valid UTF-8.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.get" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.20.0">1.20.0</span> Â· <a class="src" href="https://doc.rust-lang.org/1.80.1/src/core/str/mod.rs.html#435">source</a></span><h4 class="code-header">pub fn <a href="#method.get" class="fn">get</a>&lt;I&gt;(&amp;self, i: I) -&gt; <a class="enum" href="option/enum.Option.html" title="enum std::option::Option">Option</a>&lt;&amp;&lt;I as <a class="trait" href="slice/trait.SliceIndex.html" title="trait std::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt;&gt;::<a class="associatedtype" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type std::slice::SliceIndex::Output">Output</a>&gt;<div class="where">where
    I: <a class="trait" href="slice/trait.SliceIndex.html" title="trait std::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt;,</div></h4></section></summary><div class="docblock"><p>Returns a subslice of <code>str</code>.</p>
<p>This is the non-panicking alternative to indexing the <code>str</code>. Returns
<a href="option/enum.Option.html#variant.None" title="variant std::option::Option::None"><code>None</code></a> whenever equivalent indexing operation would panic.</p>
<h5 id="examples-8"><a class="doc-anchor" href="#examples-8">Â§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>v = String::from(<span class="string">"ğŸ—»âˆˆğŸŒ"</span>);

<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">"ğŸ—»"</span>), v.get(<span class="number">0</span>..<span class="number">4</span>));

<span class="comment">// indices not on UTF-8 sequence boundaries
</span><span class="macro">assert!</span>(v.get(<span class="number">1</span>..).is_none());
<span class="macro">assert!</span>(v.get(..<span class="number">8</span>).is_none());

<span class="comment">// out of bounds
</span><span class="macro">assert!</span>(v.get(..<span class="number">42</span>).is_none());</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+v+=+String::from(%22%F0%9F%97%BB%E2%88%88%F0%9F%8C%8F%22);%0A++++%0A++++assert_eq!(Some(%22%F0%9F%97%BB%22),+v.get(0..4));%0A++++%0A++++//+indices+not+on+UTF-8+sequence+boundaries%0A++++assert!(v.get(1..).is_none());%0A++++assert!(v.get(..8).is_none());%0A++++%0A++++//+out+of+bounds%0A++++assert!(v.get(..42).is_none());%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.get_mut" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.20.0">1.20.0</span> Â· <a class="src" href="https://doc.rust-lang.org/1.80.1/src/core/str/mod.rs.html#467">source</a></span><h4 class="code-header">pub fn <a href="#method.get_mut" class="fn">get_mut</a>&lt;I&gt;(
    &amp;mut self,
    i: I,
) -&gt; <a class="enum" href="option/enum.Option.html" title="enum std::option::Option">Option</a>&lt;&amp;mut &lt;I as <a class="trait" href="slice/trait.SliceIndex.html" title="trait std::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt;&gt;::<a class="associatedtype" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type std::slice::SliceIndex::Output">Output</a>&gt;<div class="where">where
    I: <a class="trait" href="slice/trait.SliceIndex.html" title="trait std::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt;,</div></h4></section></summary><div class="docblock"><p>Returns a mutable subslice of <code>str</code>.</p>
<p>This is the non-panicking alternative to indexing the <code>str</code>. Returns
<a href="option/enum.Option.html#variant.None" title="variant std::option::Option::None"><code>None</code></a> whenever equivalent indexing operation would panic.</p>
<h5 id="examples-9"><a class="doc-anchor" href="#examples-9">Â§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span><span class="kw-2">mut </span>v = String::from(<span class="string">"hello"</span>);
<span class="comment">// correct length
</span><span class="macro">assert!</span>(v.get_mut(<span class="number">0</span>..<span class="number">5</span>).is_some());
<span class="comment">// out of bounds
</span><span class="macro">assert!</span>(v.get_mut(..<span class="number">42</span>).is_none());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">"he"</span>), v.get_mut(<span class="number">0</span>..<span class="number">2</span>).map(|v| <span class="kw-2">&amp;*</span>v));

<span class="macro">assert_eq!</span>(<span class="string">"hello"</span>, v);
{
    <span class="kw">let </span>s = v.get_mut(<span class="number">0</span>..<span class="number">2</span>);
    <span class="kw">let </span>s = s.map(|s| {
        s.make_ascii_uppercase();
        <span class="kw-2">&amp;*</span>s
    });
    <span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">"HE"</span>), s);
}
<span class="macro">assert_eq!</span>(<span class="string">"HEllo"</span>, v);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+mut+v+=+String::from(%22hello%22);%0A++++//+correct+length%0A++++assert!(v.get_mut(0..5).is_some());%0A++++//+out+of+bounds%0A++++assert!(v.get_mut(..42).is_none());%0A++++assert_eq!(Some(%22he%22),+v.get_mut(0..2).map(%7Cv%7C+%26*v));%0A++++%0A++++assert_eq!(%22hello%22,+v);%0A++++%7B%0A++++++++let+s+=+v.get_mut(0..2);%0A++++++++let+s+=+s.map(%7Cs%7C+%7B%0A++++++++++++s.make_ascii_uppercase();%0A++++++++++++%26*s%0A++++++++%7D);%0A++++++++assert_eq!(Some(%22HE%22),+s);%0A++++%7D%0A++++assert_eq!(%22HEllo%22,+v);%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.get_unchecked" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.20.0">1.20.0</span> Â· <a class="src" href="https://doc.rust-lang.org/1.80.1/src/core/str/mod.rs.html#499">source</a></span><h4 class="code-header">pub unsafe fn <a href="#method.get_unchecked" class="fn">get_unchecked</a>&lt;I&gt;(&amp;self, i: I) -&gt; &amp;&lt;I as <a class="trait" href="slice/trait.SliceIndex.html" title="trait std::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt;&gt;::<a class="associatedtype" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type std::slice::SliceIndex::Output">Output</a><div class="where">where
    I: <a class="trait" href="slice/trait.SliceIndex.html" title="trait std::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt;,</div></h4></section></summary><div class="docblock"><p>Returns an unchecked subslice of <code>str</code>.</p>
<p>This is the unchecked alternative to indexing the <code>str</code>.</p>
<h5 id="safety-1"><a class="doc-anchor" href="#safety-1">Â§</a>Safety</h5>
<p>Callers of this function are responsible that these preconditions are
satisfied:</p>
<ul>
<li>The starting index must not exceed the ending index;</li>
<li>Indexes must be within bounds of the original slice;</li>
<li>Indexes must lie on UTF-8 sequence boundaries.</li>
</ul>
<p>Failing that, the returned string slice may reference invalid memory or
violate the invariants communicated by the <code>str</code> type.</p>
<h5 id="examples-10"><a class="doc-anchor" href="#examples-10">Â§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>v = <span class="string">"ğŸ—»âˆˆğŸŒ"</span>;
<span class="kw">unsafe </span>{
    <span class="macro">assert_eq!</span>(<span class="string">"ğŸ—»"</span>, v.get_unchecked(<span class="number">0</span>..<span class="number">4</span>));
    <span class="macro">assert_eq!</span>(<span class="string">"âˆˆ"</span>, v.get_unchecked(<span class="number">4</span>..<span class="number">7</span>));
    <span class="macro">assert_eq!</span>(<span class="string">"ğŸŒ"</span>, v.get_unchecked(<span class="number">7</span>..<span class="number">11</span>));
}</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+v+=+%22%F0%9F%97%BB%E2%88%88%F0%9F%8C%8F%22;%0A++++unsafe+%7B%0A++++++++assert_eq!(%22%F0%9F%97%BB%22,+v.get_unchecked(0..4));%0A++++++++assert_eq!(%22%E2%88%88%22,+v.get_unchecked(4..7));%0A++++++++assert_eq!(%22%F0%9F%8C%8F%22,+v.get_unchecked(7..11));%0A++++%7D%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.get_unchecked_mut" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.20.0">1.20.0</span> Â· <a class="src" href="https://doc.rust-lang.org/1.80.1/src/core/str/mod.rs.html#534">source</a></span><h4 class="code-header">pub unsafe fn <a href="#method.get_unchecked_mut" class="fn">get_unchecked_mut</a>&lt;I&gt;(
    &amp;mut self,
    i: I,
) -&gt; &amp;mut &lt;I as <a class="trait" href="slice/trait.SliceIndex.html" title="trait std::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt;&gt;::<a class="associatedtype" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type std::slice::SliceIndex::Output">Output</a><div class="where">where
    I: <a class="trait" href="slice/trait.SliceIndex.html" title="trait std::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt;,</div></h4></section></summary><div class="docblock"><p>Returns a mutable, unchecked subslice of <code>str</code>.</p>
<p>This is the unchecked alternative to indexing the <code>str</code>.</p>
<h5 id="safety-2"><a class="doc-anchor" href="#safety-2">Â§</a>Safety</h5>
<p>Callers of this function are responsible that these preconditions are
satisfied:</p>
<ul>
<li>The starting index must not exceed the ending index;</li>
<li>Indexes must be within bounds of the original slice;</li>
<li>Indexes must lie on UTF-8 sequence boundaries.</li>
</ul>
<p>Failing that, the returned string slice may reference invalid memory or
violate the invariants communicated by the <code>str</code> type.</p>
<h5 id="examples-11"><a class="doc-anchor" href="#examples-11">Â§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span><span class="kw-2">mut </span>v = String::from(<span class="string">"ğŸ—»âˆˆğŸŒ"</span>);
<span class="kw">unsafe </span>{
    <span class="macro">assert_eq!</span>(<span class="string">"ğŸ—»"</span>, v.get_unchecked_mut(<span class="number">0</span>..<span class="number">4</span>));
    <span class="macro">assert_eq!</span>(<span class="string">"âˆˆ"</span>, v.get_unchecked_mut(<span class="number">4</span>..<span class="number">7</span>));
    <span class="macro">assert_eq!</span>(<span class="string">"ğŸŒ"</span>, v.get_unchecked_mut(<span class="number">7</span>..<span class="number">11</span>));
}</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+mut+v+=+String::from(%22%F0%9F%97%BB%E2%88%88%F0%9F%8C%8F%22);%0A++++unsafe+%7B%0A++++++++assert_eq!(%22%F0%9F%97%BB%22,+v.get_unchecked_mut(0..4));%0A++++++++assert_eq!(%22%E2%88%88%22,+v.get_unchecked_mut(4..7));%0A++++++++assert_eq!(%22%F0%9F%8C%8F%22,+v.get_unchecked_mut(7..11));%0A++++%7D%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.slice_unchecked" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="https://doc.rust-lang.org/1.80.1/src/core/str/mod.rs.html#585">source</a></span><h4 class="code-header">pub unsafe fn <a href="#method.slice_unchecked" class="fn">slice_unchecked</a>(&amp;self, begin: <a class="primitive" href="primitive.usize.html">usize</a>, end: <a class="primitive" href="primitive.usize.html">usize</a>) -&gt; &amp;<a class="primitive" href="primitive.str.html">str</a></h4></section><span class="item-info"><div class="stab deprecated"><span class="emoji">ğŸ‘</span><span>Deprecated since 1.29.0: use <code>get_unchecked(begin..end)</code> instead</span></div></span></summary><div class="docblock"><p>Creates a string slice from another string slice, bypassing safety
checks.</p>
<p>This is generally not recommended, use with caution! For a safe
alternative see <a href="primitive.str.html" title="primitive str"><code>str</code></a> and <a href="ops/trait.Index.html" title="trait std::ops::Index"><code>Index</code></a>.</p>
<p>This new slice goes from <code>begin</code> to <code>end</code>, including <code>begin</code> but
excluding <code>end</code>.</p>
<p>To get a mutable string slice instead, see the
<a href="primitive.str.html#method.slice_mut_unchecked" title="method str::slice_mut_unchecked"><code>slice_mut_unchecked</code></a> method.</p>
<h5 id="safety-3"><a class="doc-anchor" href="#safety-3">Â§</a>Safety</h5>
<p>Callers of this function are responsible that three preconditions are
satisfied:</p>
<ul>
<li><code>begin</code> must not exceed <code>end</code>.</li>
<li><code>begin</code> and <code>end</code> must be byte positions within the string slice.</li>
<li><code>begin</code> and <code>end</code> must lie on UTF-8 sequence boundaries.</li>
</ul>
<h5 id="examples-12"><a class="doc-anchor" href="#examples-12">Â§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>s = <span class="string">"LÃ¶we è€è™ LÃ©opard"</span>;

<span class="kw">unsafe </span>{
    <span class="macro">assert_eq!</span>(<span class="string">"LÃ¶we è€è™ LÃ©opard"</span>, s.slice_unchecked(<span class="number">0</span>, <span class="number">21</span>));
}

<span class="kw">let </span>s = <span class="string">"Hello, world!"</span>;

<span class="kw">unsafe </span>{
    <span class="macro">assert_eq!</span>(<span class="string">"world"</span>, s.slice_unchecked(<span class="number">7</span>, <span class="number">12</span>));
}</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+s+=+%22L%C3%B6we+%E8%80%81%E8%99%8E+L%C3%A9opard%22;%0A++++%0A++++unsafe+%7B%0A++++++++assert_eq!(%22L%C3%B6we+%E8%80%81%E8%99%8E+L%C3%A9opard%22,+s.slice_unchecked(0,+21));%0A++++%7D%0A++++%0A++++let+s+=+%22Hello,+world!%22;%0A++++%0A++++unsafe+%7B%0A++++++++assert_eq!(%22world%22,+s.slice_unchecked(7,+12));%0A++++%7D%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.slice_mut_unchecked" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.5.0">1.5.0</span> Â· <a class="src" href="https://doc.rust-lang.org/1.80.1/src/core/str/mod.rs.html#618">source</a></span><h4 class="code-header">pub unsafe fn <a href="#method.slice_mut_unchecked" class="fn">slice_mut_unchecked</a>(
    &amp;mut self,
    begin: <a class="primitive" href="primitive.usize.html">usize</a>,
    end: <a class="primitive" href="primitive.usize.html">usize</a>,
) -&gt; &amp;mut <a class="primitive" href="primitive.str.html">str</a></h4></section><span class="item-info"><div class="stab deprecated"><span class="emoji">ğŸ‘</span><span>Deprecated since 1.29.0: use <code>get_unchecked_mut(begin..end)</code> instead</span></div></span></summary><div class="docblock"><p>Creates a string slice from another string slice, bypassing safety
checks.
This is generally not recommended, use with caution! For a safe
alternative see <a href="primitive.str.html" title="primitive str"><code>str</code></a> and <a href="ops/trait.IndexMut.html" title="trait std::ops::IndexMut"><code>IndexMut</code></a>.</p>
<p>This new slice goes from <code>begin</code> to <code>end</code>, including <code>begin</code> but
excluding <code>end</code>.</p>
<p>To get an immutable string slice instead, see the
<a href="primitive.str.html#method.slice_unchecked" title="method str::slice_unchecked"><code>slice_unchecked</code></a> method.</p>
<h5 id="safety-4"><a class="doc-anchor" href="#safety-4">Â§</a>Safety</h5>
<p>Callers of this function are responsible that three preconditions are
satisfied:</p>
<ul>
<li><code>begin</code> must not exceed <code>end</code>.</li>
<li><code>begin</code> and <code>end</code> must be byte positions within the string slice.</li>
<li><code>begin</code> and <code>end</code> must lie on UTF-8 sequence boundaries.</li>
</ul>
</div></details><details class="toggle method-toggle" open><summary><section id="method.split_at" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.4.0">1.4.0</span> Â· <a class="src" href="https://doc.rust-lang.org/1.80.1/src/core/str/mod.rs.html#657">source</a></span><h4 class="code-header">pub fn <a href="#method.split_at" class="fn">split_at</a>(&amp;self, mid: <a class="primitive" href="primitive.usize.html">usize</a>) -&gt; (&amp;<a class="primitive" href="primitive.str.html">str</a>, &amp;<a class="primitive" href="primitive.str.html">str</a>)</h4></section></summary><div class="docblock"><p>Divide one string slice into two at an index.</p>
<p>The argument, <code>mid</code>, should be a byte offset from the start of the
string. It must also be on the boundary of a UTF-8 code point.</p>
<p>The two slices returned go from the start of the string slice to <code>mid</code>,
and from <code>mid</code> to the end of the string slice.</p>
<p>To get mutable string slices instead, see the <a href="primitive.str.html#method.split_at_mut" title="method str::split_at_mut"><code>split_at_mut</code></a>
method.</p>
<h5 id="panics"><a class="doc-anchor" href="#panics">Â§</a>Panics</h5>
<p>Panics if <code>mid</code> is not on a UTF-8 code point boundary, or if it is past
the end of the last code point of the string slice.  For a non-panicking
alternative see <a href="primitive.str.html#method.split_at_checked" title="method str::split_at_checked"><code>split_at_checked</code></a>.</p>
<h5 id="examples-13"><a class="doc-anchor" href="#examples-13">Â§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>s = <span class="string">"Per Martin-LÃ¶f"</span>;

<span class="kw">let </span>(first, last) = s.split_at(<span class="number">3</span>);

<span class="macro">assert_eq!</span>(<span class="string">"Per"</span>, first);
<span class="macro">assert_eq!</span>(<span class="string">" Martin-LÃ¶f"</span>, last);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+s+=+%22Per+Martin-L%C3%B6f%22;%0A++++%0A++++let+(first,+last)+=+s.split_at(3);%0A++++%0A++++assert_eq!(%22Per%22,+first);%0A++++assert_eq!(%22+Martin-L%C3%B6f%22,+last);%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.split_at_mut" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.4.0">1.4.0</span> Â· <a class="src" href="https://doc.rust-lang.org/1.80.1/src/core/str/mod.rs.html#697">source</a></span><h4 class="code-header">pub fn <a href="#method.split_at_mut" class="fn">split_at_mut</a>(&amp;mut self, mid: <a class="primitive" href="primitive.usize.html">usize</a>) -&gt; (&amp;mut <a class="primitive" href="primitive.str.html">str</a>, &amp;mut <a class="primitive" href="primitive.str.html">str</a>)</h4></section></summary><div class="docblock"><p>Divide one mutable string slice into two at an index.</p>
<p>The argument, <code>mid</code>, should be a byte offset from the start of the
string. It must also be on the boundary of a UTF-8 code point.</p>
<p>The two slices returned go from the start of the string slice to <code>mid</code>,
and from <code>mid</code> to the end of the string slice.</p>
<p>To get immutable string slices instead, see the <a href="primitive.str.html#method.split_at" title="method str::split_at"><code>split_at</code></a> method.</p>
<h5 id="panics-1"><a class="doc-anchor" href="#panics-1">Â§</a>Panics</h5>
<p>Panics if <code>mid</code> is not on a UTF-8 code point boundary, or if it is past
the end of the last code point of the string slice.  For a non-panicking
alternative see <a href="primitive.str.html#method.split_at_mut_checked" title="method str::split_at_mut_checked"><code>split_at_mut_checked</code></a>.</p>
<h5 id="examples-14"><a class="doc-anchor" href="#examples-14">Â§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span><span class="kw-2">mut </span>s = <span class="string">"Per Martin-LÃ¶f"</span>.to_string();
{
    <span class="kw">let </span>(first, last) = s.split_at_mut(<span class="number">3</span>);
    first.make_ascii_uppercase();
    <span class="macro">assert_eq!</span>(<span class="string">"PER"</span>, first);
    <span class="macro">assert_eq!</span>(<span class="string">" Martin-LÃ¶f"</span>, last);
}
<span class="macro">assert_eq!</span>(<span class="string">"PER Martin-LÃ¶f"</span>, s);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+mut+s+=+%22Per+Martin-L%C3%B6f%22.to_string();%0A++++%7B%0A++++++++let+(first,+last)+=+s.split_at_mut(3);%0A++++++++first.make_ascii_uppercase();%0A++++++++assert_eq!(%22PER%22,+first);%0A++++++++assert_eq!(%22+Martin-L%C3%B6f%22,+last);%0A++++%7D%0A++++assert_eq!(%22PER+Martin-L%C3%B6f%22,+s);%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.split_at_checked" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.80.0">1.80.0</span> Â· <a class="src" href="https://doc.rust-lang.org/1.80.1/src/core/str/mod.rs.html#736">source</a></span><h4 class="code-header">pub fn <a href="#method.split_at_checked" class="fn">split_at_checked</a>(&amp;self, mid: <a class="primitive" href="primitive.usize.html">usize</a>) -&gt; <a class="enum" href="option/enum.Option.html" title="enum std::option::Option">Option</a>&lt;(&amp;<a class="primitive" href="primitive.str.html">str</a>, &amp;<a class="primitive" href="primitive.str.html">str</a>)&gt;</h4></section></summary><div class="docblock"><p>Divide one string slice into two at an index.</p>
<p>The argument, <code>mid</code>, should be a valid byte offset from the start of the
string. It must also be on the boundary of a UTF-8 code point. The
method returns <code>None</code> if thatâ€™s not the case.</p>
<p>The two slices returned go from the start of the string slice to <code>mid</code>,
and from <code>mid</code> to the end of the string slice.</p>
<p>To get mutable string slices instead, see the <a href="primitive.str.html#method.split_at_mut_checked" title="method str::split_at_mut_checked"><code>split_at_mut_checked</code></a>
method.</p>
<h5 id="examples-15"><a class="doc-anchor" href="#examples-15">Â§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>s = <span class="string">"Per Martin-LÃ¶f"</span>;

<span class="kw">let </span>(first, last) = s.split_at_checked(<span class="number">3</span>).unwrap();
<span class="macro">assert_eq!</span>(<span class="string">"Per"</span>, first);
<span class="macro">assert_eq!</span>(<span class="string">" Martin-LÃ¶f"</span>, last);

<span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, s.split_at_checked(<span class="number">13</span>));  <span class="comment">// Inside â€œÃ¶â€
</span><span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, s.split_at_checked(<span class="number">16</span>));  <span class="comment">// Beyond the string length</span></code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+s+=+%22Per+Martin-L%C3%B6f%22;%0A++++%0A++++let+(first,+last)+=+s.split_at_checked(3).unwrap();%0A++++assert_eq!(%22Per%22,+first);%0A++++assert_eq!(%22+Martin-L%C3%B6f%22,+last);%0A++++%0A++++assert_eq!(None,+s.split_at_checked(13));++//+Inside+%E2%80%9C%C3%B6%E2%80%9D%0A++++assert_eq!(None,+s.split_at_checked(16));++//+Beyond+the+string+length%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.split_at_mut_checked" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.80.0">1.80.0</span> Â· <a class="src" href="https://doc.rust-lang.org/1.80.1/src/core/str/mod.rs.html#776">source</a></span><h4 class="code-header">pub fn <a href="#method.split_at_mut_checked" class="fn">split_at_mut_checked</a>(
    &amp;mut self,
    mid: <a class="primitive" href="primitive.usize.html">usize</a>,
) -&gt; <a class="enum" href="option/enum.Option.html" title="enum std::option::Option">Option</a>&lt;(&amp;mut <a class="primitive" href="primitive.str.html">str</a>, &amp;mut <a class="primitive" href="primitive.str.html">str</a>)&gt;</h4></section></summary><div class="docblock"><p>Divide one mutable string slice into two at an index.</p>
<p>The argument, <code>mid</code>, should be a valid byte offset from the start of the
string. It must also be on the boundary of a UTF-8 code point. The
method returns <code>None</code> if thatâ€™s not the case.</p>
<p>The two slices returned go from the start of the string slice to <code>mid</code>,
and from <code>mid</code> to the end of the string slice.</p>
<p>To get immutable string slices instead, see the <a href="primitive.str.html#method.split_at_checked" title="method str::split_at_checked"><code>split_at_checked</code></a> method.</p>
<h5 id="examples-16"><a class="doc-anchor" href="#examples-16">Â§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span><span class="kw-2">mut </span>s = <span class="string">"Per Martin-LÃ¶f"</span>.to_string();
<span class="kw">if let </span><span class="prelude-val">Some</span>((first, last)) = s.split_at_mut_checked(<span class="number">3</span>) {
    first.make_ascii_uppercase();
    <span class="macro">assert_eq!</span>(<span class="string">"PER"</span>, first);
    <span class="macro">assert_eq!</span>(<span class="string">" Martin-LÃ¶f"</span>, last);
}
<span class="macro">assert_eq!</span>(<span class="string">"PER Martin-LÃ¶f"</span>, s);

<span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, s.split_at_mut_checked(<span class="number">13</span>));  <span class="comment">// Inside â€œÃ¶â€
</span><span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, s.split_at_mut_checked(<span class="number">16</span>));  <span class="comment">// Beyond the string length</span></code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+mut+s+=+%22Per+Martin-L%C3%B6f%22.to_string();%0A++++if+let+Some((first,+last))+=+s.split_at_mut_checked(3)+%7B%0A++++++++first.make_ascii_uppercase();%0A++++++++assert_eq!(%22PER%22,+first);%0A++++++++assert_eq!(%22+Martin-L%C3%B6f%22,+last);%0A++++%7D%0A++++assert_eq!(%22PER+Martin-L%C3%B6f%22,+s);%0A++++%0A++++assert_eq!(None,+s.split_at_mut_checked(13));++//+Inside+%E2%80%9C%C3%B6%E2%80%9D%0A++++assert_eq!(None,+s.split_at_mut_checked(16));++//+Beyond+the+string+length%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.chars" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="https://doc.rust-lang.org/1.80.1/src/core/str/mod.rs.html#853">source</a></span><h4 class="code-header">pub fn <a href="#method.chars" class="fn">chars</a>(&amp;self) -&gt; <a class="struct" href="str/struct.Chars.html" title="struct std::str::Chars">Chars</a>&lt;'_&gt; <a href="#" class="tooltip" data-notable-ty="Chars&lt;&#39;_&gt;">â“˜</a></h4></section></summary><div class="docblock"><p>Returns an iterator over the <a href="primitive.char.html" title="primitive char"><code>char</code></a>s of a string slice.</p>
<p>As a string slice consists of valid UTF-8, we can iterate through a
string slice by <a href="primitive.char.html" title="primitive char"><code>char</code></a>. This method returns such an iterator.</p>
<p>Itâ€™s important to remember that <a href="primitive.char.html" title="primitive char"><code>char</code></a> represents a Unicode Scalar
Value, and might not match your idea of what a â€˜characterâ€™ is. Iteration
over grapheme clusters may be what you actually want. This functionality
is not provided by Rustâ€™s standard library, check crates.io instead.</p>
<h5 id="examples-17"><a class="doc-anchor" href="#examples-17">Â§</a>Examples</h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>word = <span class="string">"goodbye"</span>;

<span class="kw">let </span>count = word.chars().count();
<span class="macro">assert_eq!</span>(<span class="number">7</span>, count);

<span class="kw">let </span><span class="kw-2">mut </span>chars = word.chars();

<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">'g'</span>), chars.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">'o'</span>), chars.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">'o'</span>), chars.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">'d'</span>), chars.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">'b'</span>), chars.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">'y'</span>), chars.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">'e'</span>), chars.next());

<span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, chars.next());</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+word+=+%22goodbye%22;%0A++++%0A++++let+count+=+word.chars().count();%0A++++assert_eq!(7,+count);%0A++++%0A++++let+mut+chars+=+word.chars();%0A++++%0A++++assert_eq!(Some('g'),+chars.next());%0A++++assert_eq!(Some('o'),+chars.next());%0A++++assert_eq!(Some('o'),+chars.next());%0A++++assert_eq!(Some('d'),+chars.next());%0A++++assert_eq!(Some('b'),+chars.next());%0A++++assert_eq!(Some('y'),+chars.next());%0A++++assert_eq!(Some('e'),+chars.next());%0A++++%0A++++assert_eq!(None,+chars.next());%0A%7D&amp;edition=2021">Run</a></div>
<p>Remember, <a href="primitive.char.html" title="primitive char"><code>char</code></a>s might not match your intuition about characters:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>y = <span class="string">"yÌ†"</span>;

<span class="kw">let </span><span class="kw-2">mut </span>chars = y.chars();

<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">'y'</span>), chars.next()); <span class="comment">// not 'yÌ†'
</span><span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">'\u{0306}'</span>), chars.next());

<span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, chars.next());</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+y+=+%22y%CC%86%22;%0A++++%0A++++let+mut+chars+=+y.chars();%0A++++%0A++++assert_eq!(Some('y'),+chars.next());+//+not+'y%CC%86'%0A++++assert_eq!(Some('%5Cu%7B0306%7D'),+chars.next());%0A++++%0A++++assert_eq!(None,+chars.next());%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.char_indices" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="https://doc.rust-lang.org/1.80.1/src/core/str/mod.rs.html#910">source</a></span><h4 class="code-header">pub fn <a href="#method.char_indices" class="fn">char_indices</a>(&amp;self) -&gt; <a class="struct" href="str/struct.CharIndices.html" title="struct std::str::CharIndices">CharIndices</a>&lt;'_&gt; <a href="#" class="tooltip" data-notable-ty="CharIndices&lt;&#39;_&gt;">â“˜</a></h4></section></summary><div class="docblock"><p>Returns an iterator over the <a href="primitive.char.html" title="primitive char"><code>char</code></a>s of a string slice, and their
positions.</p>
<p>As a string slice consists of valid UTF-8, we can iterate through a
string slice by <a href="primitive.char.html" title="primitive char"><code>char</code></a>. This method returns an iterator of both
these <a href="primitive.char.html" title="primitive char"><code>char</code></a>s, as well as their byte positions.</p>
<p>The iterator yields tuples. The position is first, the <a href="primitive.char.html" title="primitive char"><code>char</code></a> is
second.</p>
<h5 id="examples-18"><a class="doc-anchor" href="#examples-18">Â§</a>Examples</h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>word = <span class="string">"goodbye"</span>;

<span class="kw">let </span>count = word.char_indices().count();
<span class="macro">assert_eq!</span>(<span class="number">7</span>, count);

<span class="kw">let </span><span class="kw-2">mut </span>char_indices = word.char_indices();

<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>((<span class="number">0</span>, <span class="string">'g'</span>)), char_indices.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>((<span class="number">1</span>, <span class="string">'o'</span>)), char_indices.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>((<span class="number">2</span>, <span class="string">'o'</span>)), char_indices.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>((<span class="number">3</span>, <span class="string">'d'</span>)), char_indices.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>((<span class="number">4</span>, <span class="string">'b'</span>)), char_indices.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>((<span class="number">5</span>, <span class="string">'y'</span>)), char_indices.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>((<span class="number">6</span>, <span class="string">'e'</span>)), char_indices.next());

<span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, char_indices.next());</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+word+=+%22goodbye%22;%0A++++%0A++++let+count+=+word.char_indices().count();%0A++++assert_eq!(7,+count);%0A++++%0A++++let+mut+char_indices+=+word.char_indices();%0A++++%0A++++assert_eq!(Some((0,+'g')),+char_indices.next());%0A++++assert_eq!(Some((1,+'o')),+char_indices.next());%0A++++assert_eq!(Some((2,+'o')),+char_indices.next());%0A++++assert_eq!(Some((3,+'d')),+char_indices.next());%0A++++assert_eq!(Some((4,+'b')),+char_indices.next());%0A++++assert_eq!(Some((5,+'y')),+char_indices.next());%0A++++assert_eq!(Some((6,+'e')),+char_indices.next());%0A++++%0A++++assert_eq!(None,+char_indices.next());%0A%7D&amp;edition=2021">Run</a></div>
<p>Remember, <a href="primitive.char.html" title="primitive char"><code>char</code></a>s might not match your intuition about characters:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>yes = <span class="string">"yÌ†es"</span>;

<span class="kw">let </span><span class="kw-2">mut </span>char_indices = yes.char_indices();

<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>((<span class="number">0</span>, <span class="string">'y'</span>)), char_indices.next()); <span class="comment">// not (0, 'yÌ†')
</span><span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>((<span class="number">1</span>, <span class="string">'\u{0306}'</span>)), char_indices.next());

<span class="comment">// note the 3 here - the previous character took up two bytes
</span><span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>((<span class="number">3</span>, <span class="string">'e'</span>)), char_indices.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>((<span class="number">4</span>, <span class="string">'s'</span>)), char_indices.next());

<span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, char_indices.next());</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+yes+=+%22y%CC%86es%22;%0A++++%0A++++let+mut+char_indices+=+yes.char_indices();%0A++++%0A++++assert_eq!(Some((0,+'y')),+char_indices.next());+//+not+(0,+'y%CC%86')%0A++++assert_eq!(Some((1,+'%5Cu%7B0306%7D')),+char_indices.next());%0A++++%0A++++//+note+the+3+here+-+the+previous+character+took+up+two+bytes%0A++++assert_eq!(Some((3,+'e')),+char_indices.next());%0A++++assert_eq!(Some((4,+'s')),+char_indices.next());%0A++++%0A++++assert_eq!(None,+char_indices.next());%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.bytes" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="https://doc.rust-lang.org/1.80.1/src/core/str/mod.rs.html#933">source</a></span><h4 class="code-header">pub fn <a href="#method.bytes" class="fn">bytes</a>(&amp;self) -&gt; <a class="struct" href="str/struct.Bytes.html" title="struct std::str::Bytes">Bytes</a>&lt;'_&gt; <a href="#" class="tooltip" data-notable-ty="Bytes&lt;&#39;_&gt;">â“˜</a></h4></section></summary><div class="docblock"><p>An iterator over the bytes of a string slice.</p>
<p>As a string slice consists of a sequence of bytes, we can iterate
through a string slice by byte. This method returns such an iterator.</p>
<h5 id="examples-19"><a class="doc-anchor" href="#examples-19">Â§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span><span class="kw-2">mut </span>bytes = <span class="string">"bors"</span>.bytes();

<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">b'b'</span>), bytes.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">b'o'</span>), bytes.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">b'r'</span>), bytes.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">b's'</span>), bytes.next());

<span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, bytes.next());</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+mut+bytes+=+%22bors%22.bytes();%0A++++%0A++++assert_eq!(Some(b'b'),+bytes.next());%0A++++assert_eq!(Some(b'o'),+bytes.next());%0A++++assert_eq!(Some(b'r'),+bytes.next());%0A++++assert_eq!(Some(b's'),+bytes.next());%0A++++%0A++++assert_eq!(None,+bytes.next());%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.split_whitespace" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.1.0">1.1.0</span> Â· <a class="src" href="https://doc.rust-lang.org/1.80.1/src/core/str/mod.rs.html#985">source</a></span><h4 class="code-header">pub fn <a href="#method.split_whitespace" class="fn">split_whitespace</a>(&amp;self) -&gt; <a class="struct" href="str/struct.SplitWhitespace.html" title="struct std::str::SplitWhitespace">SplitWhitespace</a>&lt;'_&gt; <a href="#" class="tooltip" data-notable-ty="SplitWhitespace&lt;&#39;_&gt;">â“˜</a></h4></section></summary><div class="docblock"><p>Splits a string slice by whitespace.</p>
<p>The iterator returned will return string slices that are sub-slices of
the original string slice, separated by any amount of whitespace.</p>
<p>â€˜Whitespaceâ€™ is defined according to the terms of the Unicode Derived
Core Property <code>White_Space</code>. If you only want to split on ASCII whitespace
instead, use <a href="primitive.str.html#method.split_ascii_whitespace" title="method str::split_ascii_whitespace"><code>split_ascii_whitespace</code></a>.</p>
<h5 id="examples-20"><a class="doc-anchor" href="#examples-20">Â§</a>Examples</h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span><span class="kw-2">mut </span>iter = <span class="string">"A few words"</span>.split_whitespace();

<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">"A"</span>), iter.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">"few"</span>), iter.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">"words"</span>), iter.next());

<span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, iter.next());</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+mut+iter+=+%22A+few+words%22.split_whitespace();%0A++++%0A++++assert_eq!(Some(%22A%22),+iter.next());%0A++++assert_eq!(Some(%22few%22),+iter.next());%0A++++assert_eq!(Some(%22words%22),+iter.next());%0A++++%0A++++assert_eq!(None,+iter.next());%0A%7D&amp;edition=2021">Run</a></div>
<p>All kinds of whitespace are considered:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span><span class="kw-2">mut </span>iter = <span class="string">" Mary   had\ta\u{2009}little  \n\t lamb"</span>.split_whitespace();
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">"Mary"</span>), iter.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">"had"</span>), iter.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">"a"</span>), iter.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">"little"</span>), iter.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">"lamb"</span>), iter.next());

<span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, iter.next());</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+mut+iter+=+%22+Mary+++had%5Cta%5Cu%7B2009%7Dlittle++%5Cn%5Ct+lamb%22.split_whitespace();%0A++++assert_eq!(Some(%22Mary%22),+iter.next());%0A++++assert_eq!(Some(%22had%22),+iter.next());%0A++++assert_eq!(Some(%22a%22),+iter.next());%0A++++assert_eq!(Some(%22little%22),+iter.next());%0A++++assert_eq!(Some(%22lamb%22),+iter.next());%0A++++%0A++++assert_eq!(None,+iter.next());%0A%7D&amp;edition=2021">Run</a></div>
<p>If the string is empty or all whitespace, the iterator yields no string slices:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(<span class="string">""</span>.split_whitespace().next(), <span class="prelude-val">None</span>);
<span class="macro">assert_eq!</span>(<span class="string">"   "</span>.split_whitespace().next(), <span class="prelude-val">None</span>);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++assert_eq!(%22%22.split_whitespace().next(),+None);%0A++++assert_eq!(%22+++%22.split_whitespace().next(),+None);%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.split_ascii_whitespace" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.34.0">1.34.0</span> Â· <a class="src" href="https://doc.rust-lang.org/1.80.1/src/core/str/mod.rs.html#1034">source</a></span><h4 class="code-header">pub fn <a href="#method.split_ascii_whitespace" class="fn">split_ascii_whitespace</a>(&amp;self) -&gt; <a class="struct" href="str/struct.SplitAsciiWhitespace.html" title="struct std::str::SplitAsciiWhitespace">SplitAsciiWhitespace</a>&lt;'_&gt; <a href="#" class="tooltip" data-notable-ty="SplitAsciiWhitespace&lt;&#39;_&gt;">â“˜</a></h4></section></summary><div class="docblock"><p>Splits a string slice by ASCII whitespace.</p>
<p>The iterator returned will return string slices that are sub-slices of
the original string slice, separated by any amount of ASCII whitespace.</p>
<p>To split by Unicode <code>Whitespace</code> instead, use <a href="primitive.str.html#method.split_whitespace" title="method str::split_whitespace"><code>split_whitespace</code></a>.</p>
<h5 id="examples-21"><a class="doc-anchor" href="#examples-21">Â§</a>Examples</h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span><span class="kw-2">mut </span>iter = <span class="string">"A few words"</span>.split_ascii_whitespace();

<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">"A"</span>), iter.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">"few"</span>), iter.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">"words"</span>), iter.next());

<span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, iter.next());</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+mut+iter+=+%22A+few+words%22.split_ascii_whitespace();%0A++++%0A++++assert_eq!(Some(%22A%22),+iter.next());%0A++++assert_eq!(Some(%22few%22),+iter.next());%0A++++assert_eq!(Some(%22words%22),+iter.next());%0A++++%0A++++assert_eq!(None,+iter.next());%0A%7D&amp;edition=2021">Run</a></div>
<p>All kinds of ASCII whitespace are considered:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span><span class="kw-2">mut </span>iter = <span class="string">" Mary   had\ta little  \n\t lamb"</span>.split_ascii_whitespace();
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">"Mary"</span>), iter.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">"had"</span>), iter.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">"a"</span>), iter.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">"little"</span>), iter.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">"lamb"</span>), iter.next());

<span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, iter.next());</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+mut+iter+=+%22+Mary+++had%5Cta+little++%5Cn%5Ct+lamb%22.split_ascii_whitespace();%0A++++assert_eq!(Some(%22Mary%22),+iter.next());%0A++++assert_eq!(Some(%22had%22),+iter.next());%0A++++assert_eq!(Some(%22a%22),+iter.next());%0A++++assert_eq!(Some(%22little%22),+iter.next());%0A++++assert_eq!(Some(%22lamb%22),+iter.next());%0A++++%0A++++assert_eq!(None,+iter.next());%0A%7D&amp;edition=2021">Run</a></div>
<p>If the string is empty or all ASCII whitespace, the iterator yields no string slices:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(<span class="string">""</span>.split_ascii_whitespace().next(), <span class="prelude-val">None</span>);
<span class="macro">assert_eq!</span>(<span class="string">"   "</span>.split_ascii_whitespace().next(), <span class="prelude-val">None</span>);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++assert_eq!(%22%22.split_ascii_whitespace().next(),+None);%0A++++assert_eq!(%22+++%22.split_ascii_whitespace().next(),+None);%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.lines" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="https://doc.rust-lang.org/1.80.1/src/core/str/mod.rs.html#1092">source</a></span><h4 class="code-header">pub fn <a href="#method.lines" class="fn">lines</a>(&amp;self) -&gt; <a class="struct" href="str/struct.Lines.html" title="struct std::str::Lines">Lines</a>&lt;'_&gt; <a href="#" class="tooltip" data-notable-ty="Lines&lt;&#39;_&gt;">â“˜</a></h4></section></summary><div class="docblock"><p>An iterator over the lines of a string, as string slices.</p>
<p>Lines are split at line endings that are either newlines (<code>\n</code>) or
sequences of a carriage return followed by a line feed (<code>\r\n</code>).</p>
<p>Line terminators are not included in the lines returned by the iterator.</p>
<p>Note that any carriage return (<code>\r</code>) not immediately followed by a
line feed (<code>\n</code>) does not split a line. These carriage returns are
thereby included in the produced lines.</p>
<p>The final line ending is optional. A string that ends with a final line
ending will return the same lines as an otherwise identical string
without a final line ending.</p>
<h5 id="examples-22"><a class="doc-anchor" href="#examples-22">Â§</a>Examples</h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>text = <span class="string">"foo\r\nbar\n\nbaz\r"</span>;
<span class="kw">let </span><span class="kw-2">mut </span>lines = text.lines();

<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">"foo"</span>), lines.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">"bar"</span>), lines.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">""</span>), lines.next());
<span class="comment">// Trailing carriage return is included in the last line
</span><span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">"baz\r"</span>), lines.next());

<span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, lines.next());</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+text+=+%22foo%5Cr%5Cnbar%5Cn%5Cnbaz%5Cr%22;%0A++++let+mut+lines+=+text.lines();%0A++++%0A++++assert_eq!(Some(%22foo%22),+lines.next());%0A++++assert_eq!(Some(%22bar%22),+lines.next());%0A++++assert_eq!(Some(%22%22),+lines.next());%0A++++//+Trailing+carriage+return+is+included+in+the+last+line%0A++++assert_eq!(Some(%22baz%5Cr%22),+lines.next());%0A++++%0A++++assert_eq!(None,+lines.next());%0A%7D&amp;edition=2021">Run</a></div>
<p>The final line does not require any ending:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>text = <span class="string">"foo\nbar\n\r\nbaz"</span>;
<span class="kw">let </span><span class="kw-2">mut </span>lines = text.lines();

<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">"foo"</span>), lines.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">"bar"</span>), lines.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">""</span>), lines.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">"baz"</span>), lines.next());

<span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, lines.next());</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+text+=+%22foo%5Cnbar%5Cn%5Cr%5Cnbaz%22;%0A++++let+mut+lines+=+text.lines();%0A++++%0A++++assert_eq!(Some(%22foo%22),+lines.next());%0A++++assert_eq!(Some(%22bar%22),+lines.next());%0A++++assert_eq!(Some(%22%22),+lines.next());%0A++++assert_eq!(Some(%22baz%22),+lines.next());%0A++++%0A++++assert_eq!(None,+lines.next());%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.lines_any" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="https://doc.rust-lang.org/1.80.1/src/core/str/mod.rs.html#1105">source</a></span><h4 class="code-header">pub fn <a href="#method.lines_any" class="fn">lines_any</a>(&amp;self) -&gt; <a class="struct" href="str/struct.LinesAny.html" title="struct std::str::LinesAny">LinesAny</a>&lt;'_&gt; <a href="#" class="tooltip" data-notable-ty="LinesAny&lt;&#39;_&gt;">â“˜</a></h4></section><span class="item-info"><div class="stab deprecated"><span class="emoji">ğŸ‘</span><span>Deprecated since 1.4.0: use lines() instead now</span></div></span></summary><div class="docblock"><p>An iterator over the lines of a string.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.encode_utf16" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.8.0">1.8.0</span> Â· <a class="src" href="https://doc.rust-lang.org/1.80.1/src/core/str/mod.rs.html#1124">source</a></span><h4 class="code-header">pub fn <a href="#method.encode_utf16" class="fn">encode_utf16</a>(&amp;self) -&gt; <a class="struct" href="str/struct.EncodeUtf16.html" title="struct std::str::EncodeUtf16">EncodeUtf16</a>&lt;'_&gt; <a href="#" class="tooltip" data-notable-ty="EncodeUtf16&lt;&#39;_&gt;">â“˜</a></h4></section></summary><div class="docblock"><p>Returns an iterator of <code>u16</code> over the string encoded as UTF-16.</p>
<h5 id="examples-23"><a class="doc-anchor" href="#examples-23">Â§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>text = <span class="string">"ZaÅ¼Ã³Å‚Ä‡ gÄ™Å›lÄ… jaÅºÅ„"</span>;

<span class="kw">let </span>utf8_len = text.len();
<span class="kw">let </span>utf16_len = text.encode_utf16().count();

<span class="macro">assert!</span>(utf16_len &lt;= utf8_len);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+text+=+%22Za%C5%BC%C3%B3%C5%82%C4%87+g%C4%99%C5%9Bl%C4%85+ja%C5%BA%C5%84%22;%0A++++%0A++++let+utf8_len+=+text.len();%0A++++let+utf16_len+=+text.encode_utf16().count();%0A++++%0A++++assert!(utf16_len+%3C=+utf8_len);%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.contains" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="https://doc.rust-lang.org/1.80.1/src/core/str/mod.rs.html#1149">source</a></span><h4 class="code-header">pub fn <a href="#method.contains" class="fn">contains</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; <a class="primitive" href="primitive.bool.html">bool</a><div class="where">where
    P: <a class="trait" href="str/pattern/trait.Pattern.html" title="trait std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,</div></h4></section></summary><div class="docblock"><p>Returns <code>true</code> if the given pattern matches a sub-slice of
this string slice.</p>
<p>Returns <code>false</code> if it does not.</p>
<p>The <a href="str/pattern/index.html" title="mod std::str::pattern">pattern</a> can be a <code>&amp;str</code>, <a href="primitive.char.html" title="primitive char"><code>char</code></a>, a slice of <a href="primitive.char.html" title="primitive char"><code>char</code></a>s, or a
function or closure that determines if a character matches.</p>
<h5 id="examples-24"><a class="doc-anchor" href="#examples-24">Â§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>bananas = <span class="string">"bananas"</span>;

<span class="macro">assert!</span>(bananas.contains(<span class="string">"nana"</span>));
<span class="macro">assert!</span>(!bananas.contains(<span class="string">"apples"</span>));</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+bananas+=+%22bananas%22;%0A++++%0A++++assert!(bananas.contains(%22nana%22));%0A++++assert!(!bananas.contains(%22apples%22));%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.starts_with" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="https://doc.rust-lang.org/1.80.1/src/core/str/mod.rs.html#1186">source</a></span><h4 class="code-header">pub fn <a href="#method.starts_with" class="fn">starts_with</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; <a class="primitive" href="primitive.bool.html">bool</a><div class="where">where
    P: <a class="trait" href="str/pattern/trait.Pattern.html" title="trait std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,</div></h4></section></summary><div class="docblock"><p>Returns <code>true</code> if the given pattern matches a prefix of this
string slice.</p>
<p>Returns <code>false</code> if it does not.</p>
<p>The <a href="str/pattern/index.html" title="mod std::str::pattern">pattern</a> can be a <code>&amp;str</code>, in which case this function will return true if
the <code>&amp;str</code> is a prefix of this string slice.</p>
<p>The <a href="str/pattern/index.html" title="mod std::str::pattern">pattern</a> can also be a <a href="primitive.char.html" title="primitive char"><code>char</code></a>, a slice of <a href="primitive.char.html" title="primitive char"><code>char</code></a>s, or a
function or closure that determines if a character matches.
These will only be checked against the first character of this string slice.
Look at the second example below regarding behavior for slices of <a href="primitive.char.html" title="primitive char"><code>char</code></a>s.</p>
<h5 id="examples-25"><a class="doc-anchor" href="#examples-25">Â§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>bananas = <span class="string">"bananas"</span>;

<span class="macro">assert!</span>(bananas.starts_with(<span class="string">"bana"</span>));
<span class="macro">assert!</span>(!bananas.starts_with(<span class="string">"nana"</span>));</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+bananas+=+%22bananas%22;%0A++++%0A++++assert!(bananas.starts_with(%22bana%22));%0A++++assert!(!bananas.starts_with(%22nana%22));%0A%7D&amp;edition=2021">Run</a></div>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>bananas = <span class="string">"bananas"</span>;

<span class="comment">// Note that both of these assert successfully.
</span><span class="macro">assert!</span>(bananas.starts_with(<span class="kw-2">&amp;</span>[<span class="string">'b'</span>, <span class="string">'a'</span>, <span class="string">'n'</span>, <span class="string">'a'</span>]));
<span class="macro">assert!</span>(bananas.starts_with(<span class="kw-2">&amp;</span>[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>]));</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+bananas+=+%22bananas%22;%0A++++%0A++++//+Note+that+both+of+these+assert+successfully.%0A++++assert!(bananas.starts_with(%26%5B'b',+'a',+'n',+'a'%5D));%0A++++assert!(bananas.starts_with(%26%5B'a',+'b',+'c',+'d'%5D));%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.ends_with" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="https://doc.rust-lang.org/1.80.1/src/core/str/mod.rs.html#1210-1212">source</a></span><h4 class="code-header">pub fn <a href="#method.ends_with" class="fn">ends_with</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; <a class="primitive" href="primitive.bool.html">bool</a><div class="where">where
    P: <a class="trait" href="str/pattern/trait.Pattern.html" title="trait std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,
    &lt;P as <a class="trait" href="str/pattern/trait.Pattern.html" title="trait std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;&gt;::<a class="associatedtype" href="str/pattern/trait.Pattern.html#associatedtype.Searcher" title="type std::str::pattern::Pattern::Searcher">Searcher</a>: <a class="trait" href="str/pattern/trait.ReverseSearcher.html" title="trait std::str::pattern::ReverseSearcher">ReverseSearcher</a>&lt;'a&gt;,</div></h4></section></summary><div class="docblock"><p>Returns <code>true</code> if the given pattern matches a suffix of this
string slice.</p>
<p>Returns <code>false</code> if it does not.</p>
<p>The <a href="str/pattern/index.html" title="mod std::str::pattern">pattern</a> can be a <code>&amp;str</code>, <a href="primitive.char.html" title="primitive char"><code>char</code></a>, a slice of <a href="primitive.char.html" title="primitive char"><code>char</code></a>s, or a
function or closure that determines if a character matches.</p>
<h5 id="examples-26"><a class="doc-anchor" href="#examples-26">Â§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>bananas = <span class="string">"bananas"</span>;

<span class="macro">assert!</span>(bananas.ends_with(<span class="string">"anas"</span>));
<span class="macro">assert!</span>(!bananas.ends_with(<span class="string">"nana"</span>));</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+bananas+=+%22bananas%22;%0A++++%0A++++assert!(bananas.ends_with(%22anas%22));%0A++++assert!(!bananas.ends_with(%22nana%22));%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.find" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="https://doc.rust-lang.org/1.80.1/src/core/str/mod.rs.html#1261">source</a></span><h4 class="code-header">pub fn <a href="#method.find" class="fn">find</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; <a class="enum" href="option/enum.Option.html" title="enum std::option::Option">Option</a>&lt;<a class="primitive" href="primitive.usize.html">usize</a>&gt;<div class="where">where
    P: <a class="trait" href="str/pattern/trait.Pattern.html" title="trait std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,</div></h4></section></summary><div class="docblock"><p>Returns the byte index of the first character of this string slice that
matches the pattern.</p>
<p>Returns <a href="option/enum.Option.html#variant.None" title="variant std::option::Option::None"><code>None</code></a> if the pattern doesnâ€™t match.</p>
<p>The <a href="str/pattern/index.html" title="mod std::str::pattern">pattern</a> can be a <code>&amp;str</code>, <a href="primitive.char.html" title="primitive char"><code>char</code></a>, a slice of <a href="primitive.char.html" title="primitive char"><code>char</code></a>s, or a
function or closure that determines if a character matches.</p>
<h5 id="examples-27"><a class="doc-anchor" href="#examples-27">Â§</a>Examples</h5>
<p>Simple patterns:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>s = <span class="string">"LÃ¶we è€è™ LÃ©opard Gepardi"</span>;

<span class="macro">assert_eq!</span>(s.find(<span class="string">'L'</span>), <span class="prelude-val">Some</span>(<span class="number">0</span>));
<span class="macro">assert_eq!</span>(s.find(<span class="string">'Ã©'</span>), <span class="prelude-val">Some</span>(<span class="number">14</span>));
<span class="macro">assert_eq!</span>(s.find(<span class="string">"pard"</span>), <span class="prelude-val">Some</span>(<span class="number">17</span>));</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+s+=+%22L%C3%B6we+%E8%80%81%E8%99%8E+L%C3%A9opard+Gepardi%22;%0A++++%0A++++assert_eq!(s.find('L'),+Some(0));%0A++++assert_eq!(s.find('%C3%A9'),+Some(14));%0A++++assert_eq!(s.find(%22pard%22),+Some(17));%0A%7D&amp;edition=2021">Run</a></div>
<p>More complex patterns using point-free style and closures:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>s = <span class="string">"LÃ¶we è€è™ LÃ©opard"</span>;

<span class="macro">assert_eq!</span>(s.find(char::is_whitespace), <span class="prelude-val">Some</span>(<span class="number">5</span>));
<span class="macro">assert_eq!</span>(s.find(char::is_lowercase), <span class="prelude-val">Some</span>(<span class="number">1</span>));
<span class="macro">assert_eq!</span>(s.find(|c: char| c.is_whitespace() || c.is_lowercase()), <span class="prelude-val">Some</span>(<span class="number">1</span>));
<span class="macro">assert_eq!</span>(s.find(|c: char| (c &lt; <span class="string">'o'</span>) &amp;&amp; (c &gt; <span class="string">'a'</span>)), <span class="prelude-val">Some</span>(<span class="number">4</span>));</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+s+=+%22L%C3%B6we+%E8%80%81%E8%99%8E+L%C3%A9opard%22;%0A++++%0A++++assert_eq!(s.find(char::is_whitespace),+Some(5));%0A++++assert_eq!(s.find(char::is_lowercase),+Some(1));%0A++++assert_eq!(s.find(%7Cc:+char%7C+c.is_whitespace()+%7C%7C+c.is_lowercase()),+Some(1));%0A++++assert_eq!(s.find(%7Cc:+char%7C+(c+%3C+'o')+%26%26+(c+%3E+'a')),+Some(4));%0A%7D&amp;edition=2021">Run</a></div>
<p>Not finding the pattern:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>s = <span class="string">"LÃ¶we è€è™ LÃ©opard"</span>;
<span class="kw">let </span>x: <span class="kw-2">&amp;</span>[<span class="kw">_</span>] = <span class="kw-2">&amp;</span>[<span class="string">'1'</span>, <span class="string">'2'</span>];

<span class="macro">assert_eq!</span>(s.find(x), <span class="prelude-val">None</span>);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+s+=+%22L%C3%B6we+%E8%80%81%E8%99%8E+L%C3%A9opard%22;%0A++++let+x:+%26%5B_%5D+=+%26%5B'1',+'2'%5D;%0A++++%0A++++assert_eq!(s.find(x),+None);%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.rfind" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="https://doc.rust-lang.org/1.80.1/src/core/str/mod.rs.html#1307-1309">source</a></span><h4 class="code-header">pub fn <a href="#method.rfind" class="fn">rfind</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; <a class="enum" href="option/enum.Option.html" title="enum std::option::Option">Option</a>&lt;<a class="primitive" href="primitive.usize.html">usize</a>&gt;<div class="where">where
    P: <a class="trait" href="str/pattern/trait.Pattern.html" title="trait std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,
    &lt;P as <a class="trait" href="str/pattern/trait.Pattern.html" title="trait std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;&gt;::<a class="associatedtype" href="str/pattern/trait.Pattern.html#associatedtype.Searcher" title="type std::str::pattern::Pattern::Searcher">Searcher</a>: <a class="trait" href="str/pattern/trait.ReverseSearcher.html" title="trait std::str::pattern::ReverseSearcher">ReverseSearcher</a>&lt;'a&gt;,</div></h4></section></summary><div class="docblock"><p>Returns the byte index for the first character of the last match of the pattern in
this string slice.</p>
<p>Returns <a href="option/enum.Option.html#variant.None" title="variant std::option::Option::None"><code>None</code></a> if the pattern doesnâ€™t match.</p>
<p>The <a href="str/pattern/index.html" title="mod std::str::pattern">pattern</a> can be a <code>&amp;str</code>, <a href="primitive.char.html" title="primitive char"><code>char</code></a>, a slice of <a href="primitive.char.html" title="primitive char"><code>char</code></a>s, or a
function or closure that determines if a character matches.</p>
<h5 id="examples-28"><a class="doc-anchor" href="#examples-28">Â§</a>Examples</h5>
<p>Simple patterns:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>s = <span class="string">"LÃ¶we è€è™ LÃ©opard Gepardi"</span>;

<span class="macro">assert_eq!</span>(s.rfind(<span class="string">'L'</span>), <span class="prelude-val">Some</span>(<span class="number">13</span>));
<span class="macro">assert_eq!</span>(s.rfind(<span class="string">'Ã©'</span>), <span class="prelude-val">Some</span>(<span class="number">14</span>));
<span class="macro">assert_eq!</span>(s.rfind(<span class="string">"pard"</span>), <span class="prelude-val">Some</span>(<span class="number">24</span>));</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+s+=+%22L%C3%B6we+%E8%80%81%E8%99%8E+L%C3%A9opard+Gepardi%22;%0A++++%0A++++assert_eq!(s.rfind('L'),+Some(13));%0A++++assert_eq!(s.rfind('%C3%A9'),+Some(14));%0A++++assert_eq!(s.rfind(%22pard%22),+Some(24));%0A%7D&amp;edition=2021">Run</a></div>
<p>More complex patterns with closures:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>s = <span class="string">"LÃ¶we è€è™ LÃ©opard"</span>;

<span class="macro">assert_eq!</span>(s.rfind(char::is_whitespace), <span class="prelude-val">Some</span>(<span class="number">12</span>));
<span class="macro">assert_eq!</span>(s.rfind(char::is_lowercase), <span class="prelude-val">Some</span>(<span class="number">20</span>));</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+s+=+%22L%C3%B6we+%E8%80%81%E8%99%8E+L%C3%A9opard%22;%0A++++%0A++++assert_eq!(s.rfind(char::is_whitespace),+Some(12));%0A++++assert_eq!(s.rfind(char::is_lowercase),+Some(20));%0A%7D&amp;edition=2021">Run</a></div>
<p>Not finding the pattern:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>s = <span class="string">"LÃ¶we è€è™ LÃ©opard"</span>;
<span class="kw">let </span>x: <span class="kw-2">&amp;</span>[<span class="kw">_</span>] = <span class="kw-2">&amp;</span>[<span class="string">'1'</span>, <span class="string">'2'</span>];

<span class="macro">assert_eq!</span>(s.rfind(x), <span class="prelude-val">None</span>);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+s+=+%22L%C3%B6we+%E8%80%81%E8%99%8E+L%C3%A9opard%22;%0A++++let+x:+%26%5B_%5D+=+%26%5B'1',+'2'%5D;%0A++++%0A++++assert_eq!(s.rfind(x),+None);%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.split" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="https://doc.rust-lang.org/1.80.1/src/core/str/mod.rs.html#1429">source</a></span><h4 class="code-header">pub fn <a href="#method.split" class="fn">split</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; <a class="struct" href="str/struct.Split.html" title="struct std::str::Split">Split</a>&lt;'a, P&gt; <a href="#" class="tooltip" data-notable-ty="Split&lt;&#39;a, P&gt;">â“˜</a><div class="where">where
    P: <a class="trait" href="str/pattern/trait.Pattern.html" title="trait std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,</div></h4></section></summary><div class="docblock"><p>An iterator over substrings of this string slice, separated by
characters matched by a pattern.</p>
<p>The <a href="str/pattern/index.html" title="mod std::str::pattern">pattern</a> can be a <code>&amp;str</code>, <a href="primitive.char.html" title="primitive char"><code>char</code></a>, a slice of <a href="primitive.char.html" title="primitive char"><code>char</code></a>s, or a
function or closure that determines if a character matches.</p>
<h5 id="iterator-behavior"><a class="doc-anchor" href="#iterator-behavior">Â§</a>Iterator behavior</h5>
<p>The returned iterator will be a <a href="iter/trait.DoubleEndedIterator.html" title="trait std::iter::DoubleEndedIterator"><code>DoubleEndedIterator</code></a> if the pattern
allows a reverse search and forward/reverse search yields the same
elements. This is true for, e.g., <a href="primitive.char.html" title="primitive char"><code>char</code></a>, but not for <code>&amp;str</code>.</p>
<p>If the pattern allows a reverse search but its results might differ
from a forward search, the <a href="primitive.str.html#method.rsplit" title="method str::rsplit"><code>rsplit</code></a> method can be used.</p>
<h5 id="examples-29"><a class="doc-anchor" href="#examples-29">Â§</a>Examples</h5>
<p>Simple patterns:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">"Mary had a little lamb"</span>.split(<span class="string">' '</span>).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">"Mary"</span>, <span class="string">"had"</span>, <span class="string">"a"</span>, <span class="string">"little"</span>, <span class="string">"lamb"</span>]);

<span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">""</span>.split(<span class="string">'X'</span>).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">""</span>]);

<span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">"lionXXtigerXleopard"</span>.split(<span class="string">'X'</span>).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">"lion"</span>, <span class="string">""</span>, <span class="string">"tiger"</span>, <span class="string">"leopard"</span>]);

<span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">"lion::tiger::leopard"</span>.split(<span class="string">"::"</span>).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">"lion"</span>, <span class="string">"tiger"</span>, <span class="string">"leopard"</span>]);

<span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">"abc1def2ghi"</span>.split(char::is_numeric).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">"abc"</span>, <span class="string">"def"</span>, <span class="string">"ghi"</span>]);

<span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">"lionXtigerXleopard"</span>.split(char::is_uppercase).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">"lion"</span>, <span class="string">"tiger"</span>, <span class="string">"leopard"</span>]);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+v:+Vec%3C%26str%3E+=+%22Mary+had+a+little+lamb%22.split('+').collect();%0A++++assert_eq!(v,+%5B%22Mary%22,+%22had%22,+%22a%22,+%22little%22,+%22lamb%22%5D);%0A++++%0A++++let+v:+Vec%3C%26str%3E+=+%22%22.split('X').collect();%0A++++assert_eq!(v,+%5B%22%22%5D);%0A++++%0A++++let+v:+Vec%3C%26str%3E+=+%22lionXXtigerXleopard%22.split('X').collect();%0A++++assert_eq!(v,+%5B%22lion%22,+%22%22,+%22tiger%22,+%22leopard%22%5D);%0A++++%0A++++let+v:+Vec%3C%26str%3E+=+%22lion::tiger::leopard%22.split(%22::%22).collect();%0A++++assert_eq!(v,+%5B%22lion%22,+%22tiger%22,+%22leopard%22%5D);%0A++++%0A++++let+v:+Vec%3C%26str%3E+=+%22abc1def2ghi%22.split(char::is_numeric).collect();%0A++++assert_eq!(v,+%5B%22abc%22,+%22def%22,+%22ghi%22%5D);%0A++++%0A++++let+v:+Vec%3C%26str%3E+=+%22lionXtigerXleopard%22.split(char::is_uppercase).collect();%0A++++assert_eq!(v,+%5B%22lion%22,+%22tiger%22,+%22leopard%22%5D);%0A%7D&amp;edition=2021">Run</a></div>
<p>If the pattern is a slice of chars, split on each occurrence of any of the characters:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">"2020-11-03 23:59"</span>.split(<span class="kw-2">&amp;</span>[<span class="string">'-'</span>, <span class="string">' '</span>, <span class="string">':'</span>, <span class="string">'@'</span>][..]).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">"2020"</span>, <span class="string">"11"</span>, <span class="string">"03"</span>, <span class="string">"23"</span>, <span class="string">"59"</span>]);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+v:+Vec%3C%26str%3E+=+%222020-11-03+23:59%22.split(%26%5B'-',+'+',+':',+'%40'%5D%5B..%5D).collect();%0A++++assert_eq!(v,+%5B%222020%22,+%2211%22,+%2203%22,+%2223%22,+%2259%22%5D);%0A%7D&amp;edition=2021">Run</a></div>
<p>A more complex pattern, using a closure:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">"abc1defXghi"</span>.split(|c| c == <span class="string">'1' </span>|| c == <span class="string">'X'</span>).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">"abc"</span>, <span class="string">"def"</span>, <span class="string">"ghi"</span>]);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+v:+Vec%3C%26str%3E+=+%22abc1defXghi%22.split(%7Cc%7C+c+==+'1'+%7C%7C+c+==+'X').collect();%0A++++assert_eq!(v,+%5B%22abc%22,+%22def%22,+%22ghi%22%5D);%0A%7D&amp;edition=2021">Run</a></div>
<p>If a string contains multiple contiguous separators, you will end up
with empty strings in the output:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>x = <span class="string">"||||a||b|c"</span>.to_string();
<span class="kw">let </span>d: Vec&lt;<span class="kw">_</span>&gt; = x.split(<span class="string">'|'</span>).collect();

<span class="macro">assert_eq!</span>(d, <span class="kw-2">&amp;</span>[<span class="string">""</span>, <span class="string">""</span>, <span class="string">""</span>, <span class="string">""</span>, <span class="string">"a"</span>, <span class="string">""</span>, <span class="string">"b"</span>, <span class="string">"c"</span>]);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+x+=+%22%7C%7C%7C%7Ca%7C%7Cb%7Cc%22.to_string();%0A++++let+d:+Vec%3C_%3E+=+x.split('%7C').collect();%0A++++%0A++++assert_eq!(d,+%26%5B%22%22,+%22%22,+%22%22,+%22%22,+%22a%22,+%22%22,+%22b%22,+%22c%22%5D);%0A%7D&amp;edition=2021">Run</a></div>
<p>Contiguous separators are separated by the empty string.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>x = <span class="string">"(///)"</span>.to_string();
<span class="kw">let </span>d: Vec&lt;<span class="kw">_</span>&gt; = x.split(<span class="string">'/'</span>).collect();

<span class="macro">assert_eq!</span>(d, <span class="kw-2">&amp;</span>[<span class="string">"("</span>, <span class="string">""</span>, <span class="string">""</span>, <span class="string">")"</span>]);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+x+=+%22(///)%22.to_string();%0A++++let+d:+Vec%3C_%3E+=+x.split('/').collect();%0A++++%0A++++assert_eq!(d,+%26%5B%22(%22,+%22%22,+%22%22,+%22)%22%5D);%0A%7D&amp;edition=2021">Run</a></div>
<p>Separators at the start or end of a string are neighbored
by empty strings.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>d: Vec&lt;<span class="kw">_</span>&gt; = <span class="string">"010"</span>.split(<span class="string">"0"</span>).collect();
<span class="macro">assert_eq!</span>(d, <span class="kw-2">&amp;</span>[<span class="string">""</span>, <span class="string">"1"</span>, <span class="string">""</span>]);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+d:+Vec%3C_%3E+=+%22010%22.split(%220%22).collect();%0A++++assert_eq!(d,+%26%5B%22%22,+%221%22,+%22%22%5D);%0A%7D&amp;edition=2021">Run</a></div>
<p>When the empty string is used as a separator, it separates
every character in the string, along with the beginning
and end of the string.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>f: Vec&lt;<span class="kw">_</span>&gt; = <span class="string">"rust"</span>.split(<span class="string">""</span>).collect();
<span class="macro">assert_eq!</span>(f, <span class="kw-2">&amp;</span>[<span class="string">""</span>, <span class="string">"r"</span>, <span class="string">"u"</span>, <span class="string">"s"</span>, <span class="string">"t"</span>, <span class="string">""</span>]);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+f:+Vec%3C_%3E+=+%22rust%22.split(%22%22).collect();%0A++++assert_eq!(f,+%26%5B%22%22,+%22r%22,+%22u%22,+%22s%22,+%22t%22,+%22%22%5D);%0A%7D&amp;edition=2021">Run</a></div>
<p>Contiguous separators can lead to possibly surprising behavior
when whitespace is used as the separator. This code is correct:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>x = <span class="string">"    a  b c"</span>.to_string();
<span class="kw">let </span>d: Vec&lt;<span class="kw">_</span>&gt; = x.split(<span class="string">' '</span>).collect();

<span class="macro">assert_eq!</span>(d, <span class="kw-2">&amp;</span>[<span class="string">""</span>, <span class="string">""</span>, <span class="string">""</span>, <span class="string">""</span>, <span class="string">"a"</span>, <span class="string">""</span>, <span class="string">"b"</span>, <span class="string">"c"</span>]);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+x+=+%22++++a++b+c%22.to_string();%0A++++let+d:+Vec%3C_%3E+=+x.split('+').collect();%0A++++%0A++++assert_eq!(d,+%26%5B%22%22,+%22%22,+%22%22,+%22%22,+%22a%22,+%22%22,+%22b%22,+%22c%22%5D);%0A%7D&amp;edition=2021">Run</a></div>
<p>It does <em>not</em> give you:</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">â“˜</a><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(d, <span class="kw-2">&amp;</span>[<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>]);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++assert_eq!(d,+%26%5B%22a%22,+%22b%22,+%22c%22%5D);%0A%7D&amp;edition=2021">Run</a></div>
<p>Use <a href="primitive.str.html#method.split_whitespace" title="method str::split_whitespace"><code>split_whitespace</code></a> for this behavior.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.split_inclusive" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.51.0">1.51.0</span> Â· <a class="src" href="https://doc.rust-lang.org/1.80.1/src/core/str/mod.rs.html#1469">source</a></span><h4 class="code-header">pub fn <a href="#method.split_inclusive" class="fn">split_inclusive</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; <a class="struct" href="str/struct.SplitInclusive.html" title="struct std::str::SplitInclusive">SplitInclusive</a>&lt;'a, P&gt; <a href="#" class="tooltip" data-notable-ty="SplitInclusive&lt;&#39;a, P&gt;">â“˜</a><div class="where">where
    P: <a class="trait" href="str/pattern/trait.Pattern.html" title="trait std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,</div></h4></section></summary><div class="docblock"><p>An iterator over substrings of this string slice, separated by
characters matched by a pattern. Differs from the iterator produced by
<code>split</code> in that <code>split_inclusive</code> leaves the matched part as the
terminator of the substring.</p>
<p>The <a href="str/pattern/index.html" title="mod std::str::pattern">pattern</a> can be a <code>&amp;str</code>, <a href="primitive.char.html" title="primitive char"><code>char</code></a>, a slice of <a href="primitive.char.html" title="primitive char"><code>char</code></a>s, or a
function or closure that determines if a character matches.</p>
<h5 id="examples-30"><a class="doc-anchor" href="#examples-30">Â§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">"Mary had a little lamb\nlittle lamb\nlittle lamb."
    </span>.split_inclusive(<span class="string">'\n'</span>).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">"Mary had a little lamb\n"</span>, <span class="string">"little lamb\n"</span>, <span class="string">"little lamb."</span>]);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+v:+Vec%3C%26str%3E+=+%22Mary+had+a+little+lamb%5Cnlittle+lamb%5Cnlittle+lamb.%22%0A++++++++.split_inclusive('%5Cn').collect();%0A++++assert_eq!(v,+%5B%22Mary+had+a+little+lamb%5Cn%22,+%22little+lamb%5Cn%22,+%22little+lamb.%22%5D);%0A%7D&amp;edition=2021">Run</a></div>
<p>If the last element of the string is matched,
that element will be considered the terminator of the preceding substring.
That substring will be the last item returned by the iterator.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">"Mary had a little lamb\nlittle lamb\nlittle lamb.\n"
    </span>.split_inclusive(<span class="string">'\n'</span>).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">"Mary had a little lamb\n"</span>, <span class="string">"little lamb\n"</span>, <span class="string">"little lamb.\n"</span>]);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+v:+Vec%3C%26str%3E+=+%22Mary+had+a+little+lamb%5Cnlittle+lamb%5Cnlittle+lamb.%5Cn%22%0A++++++++.split_inclusive('%5Cn').collect();%0A++++assert_eq!(v,+%5B%22Mary+had+a+little+lamb%5Cn%22,+%22little+lamb%5Cn%22,+%22little+lamb.%5Cn%22%5D);%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.rsplit" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="https://doc.rust-lang.org/1.80.1/src/core/str/mod.rs.html#1524-1526">source</a></span><h4 class="code-header">pub fn <a href="#method.rsplit" class="fn">rsplit</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; <a class="struct" href="str/struct.RSplit.html" title="struct std::str::RSplit">RSplit</a>&lt;'a, P&gt; <a href="#" class="tooltip" data-notable-ty="RSplit&lt;&#39;a, P&gt;">â“˜</a><div class="where">where
    P: <a class="trait" href="str/pattern/trait.Pattern.html" title="trait std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,
    &lt;P as <a class="trait" href="str/pattern/trait.Pattern.html" title="trait std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;&gt;::<a class="associatedtype" href="str/pattern/trait.Pattern.html#associatedtype.Searcher" title="type std::str::pattern::Pattern::Searcher">Searcher</a>: <a class="trait" href="str/pattern/trait.ReverseSearcher.html" title="trait std::str::pattern::ReverseSearcher">ReverseSearcher</a>&lt;'a&gt;,</div></h4></section></summary><div class="docblock"><p>An iterator over substrings of the given string slice, separated by
characters matched by a pattern and yielded in reverse order.</p>
<p>The <a href="str/pattern/index.html" title="mod std::str::pattern">pattern</a> can be a <code>&amp;str</code>, <a href="primitive.char.html" title="primitive char"><code>char</code></a>, a slice of <a href="primitive.char.html" title="primitive char"><code>char</code></a>s, or a
function or closure that determines if a character matches.</p>
<h5 id="iterator-behavior-1"><a class="doc-anchor" href="#iterator-behavior-1">Â§</a>Iterator behavior</h5>
<p>The returned iterator requires that the pattern supports a reverse
search, and it will be a <a href="iter/trait.DoubleEndedIterator.html" title="trait std::iter::DoubleEndedIterator"><code>DoubleEndedIterator</code></a> if a forward/reverse
search yields the same elements.</p>
<p>For iterating from the front, the <a href="primitive.str.html#method.split" title="method str::split"><code>split</code></a> method can be used.</p>
<h5 id="examples-31"><a class="doc-anchor" href="#examples-31">Â§</a>Examples</h5>
<p>Simple patterns:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">"Mary had a little lamb"</span>.rsplit(<span class="string">' '</span>).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">"lamb"</span>, <span class="string">"little"</span>, <span class="string">"a"</span>, <span class="string">"had"</span>, <span class="string">"Mary"</span>]);

<span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">""</span>.rsplit(<span class="string">'X'</span>).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">""</span>]);

<span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">"lionXXtigerXleopard"</span>.rsplit(<span class="string">'X'</span>).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">"leopard"</span>, <span class="string">"tiger"</span>, <span class="string">""</span>, <span class="string">"lion"</span>]);

<span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">"lion::tiger::leopard"</span>.rsplit(<span class="string">"::"</span>).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">"leopard"</span>, <span class="string">"tiger"</span>, <span class="string">"lion"</span>]);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+v:+Vec%3C%26str%3E+=+%22Mary+had+a+little+lamb%22.rsplit('+').collect();%0A++++assert_eq!(v,+%5B%22lamb%22,+%22little%22,+%22a%22,+%22had%22,+%22Mary%22%5D);%0A++++%0A++++let+v:+Vec%3C%26str%3E+=+%22%22.rsplit('X').collect();%0A++++assert_eq!(v,+%5B%22%22%5D);%0A++++%0A++++let+v:+Vec%3C%26str%3E+=+%22lionXXtigerXleopard%22.rsplit('X').collect();%0A++++assert_eq!(v,+%5B%22leopard%22,+%22tiger%22,+%22%22,+%22lion%22%5D);%0A++++%0A++++let+v:+Vec%3C%26str%3E+=+%22lion::tiger::leopard%22.rsplit(%22::%22).collect();%0A++++assert_eq!(v,+%5B%22leopard%22,+%22tiger%22,+%22lion%22%5D);%0A%7D&amp;edition=2021">Run</a></div>
<p>A more complex pattern, using a closure:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">"abc1defXghi"</span>.rsplit(|c| c == <span class="string">'1' </span>|| c == <span class="string">'X'</span>).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">"ghi"</span>, <span class="string">"def"</span>, <span class="string">"abc"</span>]);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+v:+Vec%3C%26str%3E+=+%22abc1defXghi%22.rsplit(%7Cc%7C+c+==+'1'+%7C%7C+c+==+'X').collect();%0A++++assert_eq!(v,+%5B%22ghi%22,+%22def%22,+%22abc%22%5D);%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.split_terminator" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="https://doc.rust-lang.org/1.80.1/src/core/str/mod.rs.html#1573">source</a></span><h4 class="code-header">pub fn <a href="#method.split_terminator" class="fn">split_terminator</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; <a class="struct" href="str/struct.SplitTerminator.html" title="struct std::str::SplitTerminator">SplitTerminator</a>&lt;'a, P&gt; <a href="#" class="tooltip" data-notable-ty="SplitTerminator&lt;&#39;a, P&gt;">â“˜</a><div class="where">where
    P: <a class="trait" href="str/pattern/trait.Pattern.html" title="trait std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,</div></h4></section></summary><div class="docblock"><p>An iterator over substrings of the given string slice, separated by
characters matched by a pattern.</p>
<p>The <a href="str/pattern/index.html" title="mod std::str::pattern">pattern</a> can be a <code>&amp;str</code>, <a href="primitive.char.html" title="primitive char"><code>char</code></a>, a slice of <a href="primitive.char.html" title="primitive char"><code>char</code></a>s, or a
function or closure that determines if a character matches.</p>
<p>Equivalent to <a href="primitive.str.html#method.split" title="method str::split"><code>split</code></a>, except that the trailing substring
is skipped if empty.</p>
<p>This method can be used for string data that is <em>terminated</em>,
rather than <em>separated</em> by a pattern.</p>
<h5 id="iterator-behavior-2"><a class="doc-anchor" href="#iterator-behavior-2">Â§</a>Iterator behavior</h5>
<p>The returned iterator will be a <a href="iter/trait.DoubleEndedIterator.html" title="trait std::iter::DoubleEndedIterator"><code>DoubleEndedIterator</code></a> if the pattern
allows a reverse search and forward/reverse search yields the same
elements. This is true for, e.g., <a href="primitive.char.html" title="primitive char"><code>char</code></a>, but not for <code>&amp;str</code>.</p>
<p>If the pattern allows a reverse search but its results might differ
from a forward search, the <a href="primitive.str.html#method.rsplit_terminator" title="method str::rsplit_terminator"><code>rsplit_terminator</code></a> method can be used.</p>
<h5 id="examples-32"><a class="doc-anchor" href="#examples-32">Â§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">"A.B."</span>.split_terminator(<span class="string">'.'</span>).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">"A"</span>, <span class="string">"B"</span>]);

<span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">"A..B.."</span>.split_terminator(<span class="string">"."</span>).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">"A"</span>, <span class="string">""</span>, <span class="string">"B"</span>, <span class="string">""</span>]);

<span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">"A.B:C.D"</span>.split_terminator(<span class="kw-2">&amp;</span>[<span class="string">'.'</span>, <span class="string">':'</span>][..]).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>, <span class="string">"D"</span>]);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+v:+Vec%3C%26str%3E+=+%22A.B.%22.split_terminator('.').collect();%0A++++assert_eq!(v,+%5B%22A%22,+%22B%22%5D);%0A++++%0A++++let+v:+Vec%3C%26str%3E+=+%22A..B..%22.split_terminator(%22.%22).collect();%0A++++assert_eq!(v,+%5B%22A%22,+%22%22,+%22B%22,+%22%22%5D);%0A++++%0A++++let+v:+Vec%3C%26str%3E+=+%22A.B:C.D%22.split_terminator(%26%5B'.',+':'%5D%5B..%5D).collect();%0A++++assert_eq!(v,+%5B%22A%22,+%22B%22,+%22C%22,+%22D%22%5D);%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.rsplit_terminator" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="https://doc.rust-lang.org/1.80.1/src/core/str/mod.rs.html#1619-1621">source</a></span><h4 class="code-header">pub fn <a href="#method.rsplit_terminator" class="fn">rsplit_terminator</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; <a class="struct" href="str/struct.RSplitTerminator.html" title="struct std::str::RSplitTerminator">RSplitTerminator</a>&lt;'a, P&gt; <a href="#" class="tooltip" data-notable-ty="RSplitTerminator&lt;&#39;a, P&gt;">â“˜</a><div class="where">where
    P: <a class="trait" href="str/pattern/trait.Pattern.html" title="trait std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,
    &lt;P as <a class="trait" href="str/pattern/trait.Pattern.html" title="trait std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;&gt;::<a class="associatedtype" href="str/pattern/trait.Pattern.html#associatedtype.Searcher" title="type std::str::pattern::Pattern::Searcher">Searcher</a>: <a class="trait" href="str/pattern/trait.ReverseSearcher.html" title="trait std::str::pattern::ReverseSearcher">ReverseSearcher</a>&lt;'a&gt;,</div></h4></section></summary><div class="docblock"><p>An iterator over substrings of <code>self</code>, separated by characters
matched by a pattern and yielded in reverse order.</p>
<p>The <a href="str/pattern/index.html" title="mod std::str::pattern">pattern</a> can be a <code>&amp;str</code>, <a href="primitive.char.html" title="primitive char"><code>char</code></a>, a slice of <a href="primitive.char.html" title="primitive char"><code>char</code></a>s, or a
function or closure that determines if a character matches.</p>
<p>Equivalent to <a href="primitive.str.html#method.split" title="method str::split"><code>split</code></a>, except that the trailing substring is
skipped if empty.</p>
<p>This method can be used for string data that is <em>terminated</em>,
rather than <em>separated</em> by a pattern.</p>
<h5 id="iterator-behavior-3"><a class="doc-anchor" href="#iterator-behavior-3">Â§</a>Iterator behavior</h5>
<p>The returned iterator requires that the pattern supports a
reverse search, and it will be double ended if a forward/reverse
search yields the same elements.</p>
<p>For iterating from the front, the <a href="primitive.str.html#method.split_terminator" title="method str::split_terminator"><code>split_terminator</code></a> method can be
used.</p>
<h5 id="examples-33"><a class="doc-anchor" href="#examples-33">Â§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">"A.B."</span>.rsplit_terminator(<span class="string">'.'</span>).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">"B"</span>, <span class="string">"A"</span>]);

<span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">"A..B.."</span>.rsplit_terminator(<span class="string">"."</span>).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">""</span>, <span class="string">"B"</span>, <span class="string">""</span>, <span class="string">"A"</span>]);

<span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">"A.B:C.D"</span>.rsplit_terminator(<span class="kw-2">&amp;</span>[<span class="string">'.'</span>, <span class="string">':'</span>][..]).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">"D"</span>, <span class="string">"C"</span>, <span class="string">"B"</span>, <span class="string">"A"</span>]);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+v:+Vec%3C%26str%3E+=+%22A.B.%22.rsplit_terminator('.').collect();%0A++++assert_eq!(v,+%5B%22B%22,+%22A%22%5D);%0A++++%0A++++let+v:+Vec%3C%26str%3E+=+%22A..B..%22.rsplit_terminator(%22.%22).collect();%0A++++assert_eq!(v,+%5B%22%22,+%22B%22,+%22%22,+%22A%22%5D);%0A++++%0A++++let+v:+Vec%3C%26str%3E+=+%22A.B:C.D%22.rsplit_terminator(%26%5B'.',+':'%5D%5B..%5D).collect();%0A++++assert_eq!(v,+%5B%22D%22,+%22C%22,+%22B%22,+%22A%22%5D);%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.splitn" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="https://doc.rust-lang.org/1.80.1/src/core/str/mod.rs.html#1674">source</a></span><h4 class="code-header">pub fn <a href="#method.splitn" class="fn">splitn</a>&lt;'a, P&gt;(&amp;'a self, n: <a class="primitive" href="primitive.usize.html">usize</a>, pat: P) -&gt; <a class="struct" href="str/struct.SplitN.html" title="struct std::str::SplitN">SplitN</a>&lt;'a, P&gt; <a href="#" class="tooltip" data-notable-ty="SplitN&lt;&#39;a, P&gt;">â“˜</a><div class="where">where
    P: <a class="trait" href="str/pattern/trait.Pattern.html" title="trait std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,</div></h4></section></summary><div class="docblock"><p>An iterator over substrings of the given string slice, separated by a
pattern, restricted to returning at most <code>n</code> items.</p>
<p>If <code>n</code> substrings are returned, the last substring (the <code>n</code>th substring)
will contain the remainder of the string.</p>
<p>The <a href="str/pattern/index.html" title="mod std::str::pattern">pattern</a> can be a <code>&amp;str</code>, <a href="primitive.char.html" title="primitive char"><code>char</code></a>, a slice of <a href="primitive.char.html" title="primitive char"><code>char</code></a>s, or a
function or closure that determines if a character matches.</p>
<h5 id="iterator-behavior-4"><a class="doc-anchor" href="#iterator-behavior-4">Â§</a>Iterator behavior</h5>
<p>The returned iterator will not be double ended, because it is
not efficient to support.</p>
<p>If the pattern allows a reverse search, the <a href="primitive.str.html#method.rsplitn" title="method str::rsplitn"><code>rsplitn</code></a> method can be
used.</p>
<h5 id="examples-34"><a class="doc-anchor" href="#examples-34">Â§</a>Examples</h5>
<p>Simple patterns:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">"Mary had a little lambda"</span>.splitn(<span class="number">3</span>, <span class="string">' '</span>).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">"Mary"</span>, <span class="string">"had"</span>, <span class="string">"a little lambda"</span>]);

<span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">"lionXXtigerXleopard"</span>.splitn(<span class="number">3</span>, <span class="string">"X"</span>).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">"lion"</span>, <span class="string">""</span>, <span class="string">"tigerXleopard"</span>]);

<span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">"abcXdef"</span>.splitn(<span class="number">1</span>, <span class="string">'X'</span>).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">"abcXdef"</span>]);

<span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">""</span>.splitn(<span class="number">1</span>, <span class="string">'X'</span>).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">""</span>]);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+v:+Vec%3C%26str%3E+=+%22Mary+had+a+little+lambda%22.splitn(3,+'+').collect();%0A++++assert_eq!(v,+%5B%22Mary%22,+%22had%22,+%22a+little+lambda%22%5D);%0A++++%0A++++let+v:+Vec%3C%26str%3E+=+%22lionXXtigerXleopard%22.splitn(3,+%22X%22).collect();%0A++++assert_eq!(v,+%5B%22lion%22,+%22%22,+%22tigerXleopard%22%5D);%0A++++%0A++++let+v:+Vec%3C%26str%3E+=+%22abcXdef%22.splitn(1,+'X').collect();%0A++++assert_eq!(v,+%5B%22abcXdef%22%5D);%0A++++%0A++++let+v:+Vec%3C%26str%3E+=+%22%22.splitn(1,+'X').collect();%0A++++assert_eq!(v,+%5B%22%22%5D);%0A%7D&amp;edition=2021">Run</a></div>
<p>A more complex pattern, using a closure:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">"abc1defXghi"</span>.splitn(<span class="number">2</span>, |c| c == <span class="string">'1' </span>|| c == <span class="string">'X'</span>).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">"abc"</span>, <span class="string">"defXghi"</span>]);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+v:+Vec%3C%26str%3E+=+%22abc1defXghi%22.splitn(2,+%7Cc%7C+c+==+'1'+%7C%7C+c+==+'X').collect();%0A++++assert_eq!(v,+%5B%22abc%22,+%22defXghi%22%5D);%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.rsplitn" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="https://doc.rust-lang.org/1.80.1/src/core/str/mod.rs.html#1723-1725">source</a></span><h4 class="code-header">pub fn <a href="#method.rsplitn" class="fn">rsplitn</a>&lt;'a, P&gt;(&amp;'a self, n: <a class="primitive" href="primitive.usize.html">usize</a>, pat: P) -&gt; <a class="struct" href="str/struct.RSplitN.html" title="struct std::str::RSplitN">RSplitN</a>&lt;'a, P&gt; <a href="#" class="tooltip" data-notable-ty="RSplitN&lt;&#39;a, P&gt;">â“˜</a><div class="where">where
    P: <a class="trait" href="str/pattern/trait.Pattern.html" title="trait std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,
    &lt;P as <a class="trait" href="str/pattern/trait.Pattern.html" title="trait std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;&gt;::<a class="associatedtype" href="str/pattern/trait.Pattern.html#associatedtype.Searcher" title="type std::str::pattern::Pattern::Searcher">Searcher</a>: <a class="trait" href="str/pattern/trait.ReverseSearcher.html" title="trait std::str::pattern::ReverseSearcher">ReverseSearcher</a>&lt;'a&gt;,</div></h4></section></summary><div class="docblock"><p>An iterator over substrings of this string slice, separated by a
pattern, starting from the end of the string, restricted to returning
at most <code>n</code> items.</p>
<p>If <code>n</code> substrings are returned, the last substring (the <code>n</code>th substring)
will contain the remainder of the string.</p>
<p>The <a href="str/pattern/index.html" title="mod std::str::pattern">pattern</a> can be a <code>&amp;str</code>, <a href="primitive.char.html" title="primitive char"><code>char</code></a>, a slice of <a href="primitive.char.html" title="primitive char"><code>char</code></a>s, or a
function or closure that determines if a character matches.</p>
<h5 id="iterator-behavior-5"><a class="doc-anchor" href="#iterator-behavior-5">Â§</a>Iterator behavior</h5>
<p>The returned iterator will not be double ended, because it is not
efficient to support.</p>
<p>For splitting from the front, the <a href="primitive.str.html#method.splitn" title="method str::splitn"><code>splitn</code></a> method can be used.</p>
<h5 id="examples-35"><a class="doc-anchor" href="#examples-35">Â§</a>Examples</h5>
<p>Simple patterns:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">"Mary had a little lamb"</span>.rsplitn(<span class="number">3</span>, <span class="string">' '</span>).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">"lamb"</span>, <span class="string">"little"</span>, <span class="string">"Mary had a"</span>]);

<span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">"lionXXtigerXleopard"</span>.rsplitn(<span class="number">3</span>, <span class="string">'X'</span>).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">"leopard"</span>, <span class="string">"tiger"</span>, <span class="string">"lionX"</span>]);

<span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">"lion::tiger::leopard"</span>.rsplitn(<span class="number">2</span>, <span class="string">"::"</span>).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">"leopard"</span>, <span class="string">"lion::tiger"</span>]);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+v:+Vec%3C%26str%3E+=+%22Mary+had+a+little+lamb%22.rsplitn(3,+'+').collect();%0A++++assert_eq!(v,+%5B%22lamb%22,+%22little%22,+%22Mary+had+a%22%5D);%0A++++%0A++++let+v:+Vec%3C%26str%3E+=+%22lionXXtigerXleopard%22.rsplitn(3,+'X').collect();%0A++++assert_eq!(v,+%5B%22leopard%22,+%22tiger%22,+%22lionX%22%5D);%0A++++%0A++++let+v:+Vec%3C%26str%3E+=+%22lion::tiger::leopard%22.rsplitn(2,+%22::%22).collect();%0A++++assert_eq!(v,+%5B%22leopard%22,+%22lion::tiger%22%5D);%0A%7D&amp;edition=2021">Run</a></div>
<p>A more complex pattern, using a closure:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">"abc1defXghi"</span>.rsplitn(<span class="number">2</span>, |c| c == <span class="string">'1' </span>|| c == <span class="string">'X'</span>).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">"ghi"</span>, <span class="string">"abc1def"</span>]);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+v:+Vec%3C%26str%3E+=+%22abc1defXghi%22.rsplitn(2,+%7Cc%7C+c+==+'1'+%7C%7C+c+==+'X').collect();%0A++++assert_eq!(v,+%5B%22ghi%22,+%22abc1def%22%5D);%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.split_once" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.52.0">1.52.0</span> Â· <a class="src" href="https://doc.rust-lang.org/1.80.1/src/core/str/mod.rs.html#1743">source</a></span><h4 class="code-header">pub fn <a href="#method.split_once" class="fn">split_once</a>&lt;'a, P&gt;(&amp;'a self, delimiter: P) -&gt; <a class="enum" href="option/enum.Option.html" title="enum std::option::Option">Option</a>&lt;(&amp;'a <a class="primitive" href="primitive.str.html">str</a>, &amp;'a <a class="primitive" href="primitive.str.html">str</a>)&gt;<div class="where">where
    P: <a class="trait" href="str/pattern/trait.Pattern.html" title="trait std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,</div></h4></section></summary><div class="docblock"><p>Splits the string on the first occurrence of the specified delimiter and
returns prefix before delimiter and suffix after delimiter.</p>
<h5 id="examples-36"><a class="doc-anchor" href="#examples-36">Â§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(<span class="string">"cfg"</span>.split_once(<span class="string">'='</span>), <span class="prelude-val">None</span>);
<span class="macro">assert_eq!</span>(<span class="string">"cfg="</span>.split_once(<span class="string">'='</span>), <span class="prelude-val">Some</span>((<span class="string">"cfg"</span>, <span class="string">""</span>)));
<span class="macro">assert_eq!</span>(<span class="string">"cfg=foo"</span>.split_once(<span class="string">'='</span>), <span class="prelude-val">Some</span>((<span class="string">"cfg"</span>, <span class="string">"foo"</span>)));
<span class="macro">assert_eq!</span>(<span class="string">"cfg=foo=bar"</span>.split_once(<span class="string">'='</span>), <span class="prelude-val">Some</span>((<span class="string">"cfg"</span>, <span class="string">"foo=bar"</span>)));</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++assert_eq!(%22cfg%22.split_once('='),+None);%0A++++assert_eq!(%22cfg=%22.split_once('='),+Some((%22cfg%22,+%22%22)));%0A++++assert_eq!(%22cfg=foo%22.split_once('='),+Some((%22cfg%22,+%22foo%22)));%0A++++assert_eq!(%22cfg=foo=bar%22.split_once('='),+Some((%22cfg%22,+%22foo=bar%22)));%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.rsplit_once" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.52.0">1.52.0</span> Â· <a class="src" href="https://doc.rust-lang.org/1.80.1/src/core/str/mod.rs.html#1761-1763">source</a></span><h4 class="code-header">pub fn <a href="#method.rsplit_once" class="fn">rsplit_once</a>&lt;'a, P&gt;(&amp;'a self, delimiter: P) -&gt; <a class="enum" href="option/enum.Option.html" title="enum std::option::Option">Option</a>&lt;(&amp;'a <a class="primitive" href="primitive.str.html">str</a>, &amp;'a <a class="primitive" href="primitive.str.html">str</a>)&gt;<div class="where">where
    P: <a class="trait" href="str/pattern/trait.Pattern.html" title="trait std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,
    &lt;P as <a class="trait" href="str/pattern/trait.Pattern.html" title="trait std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;&gt;::<a class="associatedtype" href="str/pattern/trait.Pattern.html#associatedtype.Searcher" title="type std::str::pattern::Pattern::Searcher">Searcher</a>: <a class="trait" href="str/pattern/trait.ReverseSearcher.html" title="trait std::str::pattern::ReverseSearcher">ReverseSearcher</a>&lt;'a&gt;,</div></h4></section></summary><div class="docblock"><p>Splits the string on the last occurrence of the specified delimiter and
returns prefix before delimiter and suffix after delimiter.</p>
<h5 id="examples-37"><a class="doc-anchor" href="#examples-37">Â§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(<span class="string">"cfg"</span>.rsplit_once(<span class="string">'='</span>), <span class="prelude-val">None</span>);
<span class="macro">assert_eq!</span>(<span class="string">"cfg=foo"</span>.rsplit_once(<span class="string">'='</span>), <span class="prelude-val">Some</span>((<span class="string">"cfg"</span>, <span class="string">"foo"</span>)));
<span class="macro">assert_eq!</span>(<span class="string">"cfg=foo=bar"</span>.rsplit_once(<span class="string">'='</span>), <span class="prelude-val">Some</span>((<span class="string">"cfg=foo"</span>, <span class="string">"bar"</span>)));</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++assert_eq!(%22cfg%22.rsplit_once('='),+None);%0A++++assert_eq!(%22cfg=foo%22.rsplit_once('='),+Some((%22cfg%22,+%22foo%22)));%0A++++assert_eq!(%22cfg=foo=bar%22.rsplit_once('='),+Some((%22cfg=foo%22,+%22bar%22)));%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.matches" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.2.0">1.2.0</span> Â· <a class="src" href="https://doc.rust-lang.org/1.80.1/src/core/str/mod.rs.html#1801">source</a></span><h4 class="code-header">pub fn <a href="#method.matches" class="fn">matches</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; <a class="struct" href="str/struct.Matches.html" title="struct std::str::Matches">Matches</a>&lt;'a, P&gt; <a href="#" class="tooltip" data-notable-ty="Matches&lt;&#39;a, P&gt;">â“˜</a><div class="where">where
    P: <a class="trait" href="str/pattern/trait.Pattern.html" title="trait std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,</div></h4></section></summary><div class="docblock"><p>An iterator over the disjoint matches of a pattern within the given string
slice.</p>
<p>The <a href="str/pattern/index.html" title="mod std::str::pattern">pattern</a> can be a <code>&amp;str</code>, <a href="primitive.char.html" title="primitive char"><code>char</code></a>, a slice of <a href="primitive.char.html" title="primitive char"><code>char</code></a>s, or a
function or closure that determines if a character matches.</p>
<h5 id="iterator-behavior-6"><a class="doc-anchor" href="#iterator-behavior-6">Â§</a>Iterator behavior</h5>
<p>The returned iterator will be a <a href="iter/trait.DoubleEndedIterator.html" title="trait std::iter::DoubleEndedIterator"><code>DoubleEndedIterator</code></a> if the pattern
allows a reverse search and forward/reverse search yields the same
elements. This is true for, e.g., <a href="primitive.char.html" title="primitive char"><code>char</code></a>, but not for <code>&amp;str</code>.</p>
<p>If the pattern allows a reverse search but its results might differ
from a forward search, the <a href="primitive.str.html#method.rmatches" title="method str::rmatches"><code>rmatches</code></a> method can be used.</p>
<h5 id="examples-38"><a class="doc-anchor" href="#examples-38">Â§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">"abcXXXabcYYYabc"</span>.matches(<span class="string">"abc"</span>).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">"abc"</span>, <span class="string">"abc"</span>, <span class="string">"abc"</span>]);

<span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">"1abc2abc3"</span>.matches(char::is_numeric).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>]);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+v:+Vec%3C%26str%3E+=+%22abcXXXabcYYYabc%22.matches(%22abc%22).collect();%0A++++assert_eq!(v,+%5B%22abc%22,+%22abc%22,+%22abc%22%5D);%0A++++%0A++++let+v:+Vec%3C%26str%3E+=+%221abc2abc3%22.matches(char::is_numeric).collect();%0A++++assert_eq!(v,+%5B%221%22,+%222%22,+%223%22%5D);%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.rmatches" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.2.0">1.2.0</span> Â· <a class="src" href="https://doc.rust-lang.org/1.80.1/src/core/str/mod.rs.html#1835-1837">source</a></span><h4 class="code-header">pub fn <a href="#method.rmatches" class="fn">rmatches</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; <a class="struct" href="str/struct.RMatches.html" title="struct std::str::RMatches">RMatches</a>&lt;'a, P&gt; <a href="#" class="tooltip" data-notable-ty="RMatches&lt;&#39;a, P&gt;">â“˜</a><div class="where">where
    P: <a class="trait" href="str/pattern/trait.Pattern.html" title="trait std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,
    &lt;P as <a class="trait" href="str/pattern/trait.Pattern.html" title="trait std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;&gt;::<a class="associatedtype" href="str/pattern/trait.Pattern.html#associatedtype.Searcher" title="type std::str::pattern::Pattern::Searcher">Searcher</a>: <a class="trait" href="str/pattern/trait.ReverseSearcher.html" title="trait std::str::pattern::ReverseSearcher">ReverseSearcher</a>&lt;'a&gt;,</div></h4></section></summary><div class="docblock"><p>An iterator over the disjoint matches of a pattern within this string slice,
yielded in reverse order.</p>
<p>The <a href="str/pattern/index.html" title="mod std::str::pattern">pattern</a> can be a <code>&amp;str</code>, <a href="primitive.char.html" title="primitive char"><code>char</code></a>, a slice of <a href="primitive.char.html" title="primitive char"><code>char</code></a>s, or a
function or closure that determines if a character matches.</p>
<h5 id="iterator-behavior-7"><a class="doc-anchor" href="#iterator-behavior-7">Â§</a>Iterator behavior</h5>
<p>The returned iterator requires that the pattern supports a reverse
search, and it will be a <a href="iter/trait.DoubleEndedIterator.html" title="trait std::iter::DoubleEndedIterator"><code>DoubleEndedIterator</code></a> if a forward/reverse
search yields the same elements.</p>
<p>For iterating from the front, the <a href="primitive.str.html#method.matches" title="method str::matches"><code>matches</code></a> method can be used.</p>
<h5 id="examples-39"><a class="doc-anchor" href="#examples-39">Â§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">"abcXXXabcYYYabc"</span>.rmatches(<span class="string">"abc"</span>).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">"abc"</span>, <span class="string">"abc"</span>, <span class="string">"abc"</span>]);

<span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">"1abc2abc3"</span>.rmatches(char::is_numeric).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">"3"</span>, <span class="string">"2"</span>, <span class="string">"1"</span>]);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+v:+Vec%3C%26str%3E+=+%22abcXXXabcYYYabc%22.rmatches(%22abc%22).collect();%0A++++assert_eq!(v,+%5B%22abc%22,+%22abc%22,+%22abc%22%5D);%0A++++%0A++++let+v:+Vec%3C%26str%3E+=+%221abc2abc3%22.rmatches(char::is_numeric).collect();%0A++++assert_eq!(v,+%5B%223%22,+%222%22,+%221%22%5D);%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.match_indices" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.5.0">1.5.0</span> Â· <a class="src" href="https://doc.rust-lang.org/1.80.1/src/core/str/mod.rs.html#1879">source</a></span><h4 class="code-header">pub fn <a href="#method.match_indices" class="fn">match_indices</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; <a class="struct" href="str/struct.MatchIndices.html" title="struct std::str::MatchIndices">MatchIndices</a>&lt;'a, P&gt; <a href="#" class="tooltip" data-notable-ty="MatchIndices&lt;&#39;a, P&gt;">â“˜</a><div class="where">where
    P: <a class="trait" href="str/pattern/trait.Pattern.html" title="trait std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,</div></h4></section></summary><div class="docblock"><p>An iterator over the disjoint matches of a pattern within this string
slice as well as the index that the match starts at.</p>
<p>For matches of <code>pat</code> within <code>self</code> that overlap, only the indices
corresponding to the first match are returned.</p>
<p>The <a href="str/pattern/index.html" title="mod std::str::pattern">pattern</a> can be a <code>&amp;str</code>, <a href="primitive.char.html" title="primitive char"><code>char</code></a>, a slice of <a href="primitive.char.html" title="primitive char"><code>char</code></a>s, or a
function or closure that determines if a character matches.</p>
<h5 id="iterator-behavior-8"><a class="doc-anchor" href="#iterator-behavior-8">Â§</a>Iterator behavior</h5>
<p>The returned iterator will be a <a href="iter/trait.DoubleEndedIterator.html" title="trait std::iter::DoubleEndedIterator"><code>DoubleEndedIterator</code></a> if the pattern
allows a reverse search and forward/reverse search yields the same
elements. This is true for, e.g., <a href="primitive.char.html" title="primitive char"><code>char</code></a>, but not for <code>&amp;str</code>.</p>
<p>If the pattern allows a reverse search but its results might differ
from a forward search, the <a href="primitive.str.html#method.rmatch_indices" title="method str::rmatch_indices"><code>rmatch_indices</code></a> method can be used.</p>
<h5 id="examples-40"><a class="doc-anchor" href="#examples-40">Â§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>v: Vec&lt;<span class="kw">_</span>&gt; = <span class="string">"abcXXXabcYYYabc"</span>.match_indices(<span class="string">"abc"</span>).collect();
<span class="macro">assert_eq!</span>(v, [(<span class="number">0</span>, <span class="string">"abc"</span>), (<span class="number">6</span>, <span class="string">"abc"</span>), (<span class="number">12</span>, <span class="string">"abc"</span>)]);

<span class="kw">let </span>v: Vec&lt;<span class="kw">_</span>&gt; = <span class="string">"1abcabc2"</span>.match_indices(<span class="string">"abc"</span>).collect();
<span class="macro">assert_eq!</span>(v, [(<span class="number">1</span>, <span class="string">"abc"</span>), (<span class="number">4</span>, <span class="string">"abc"</span>)]);

<span class="kw">let </span>v: Vec&lt;<span class="kw">_</span>&gt; = <span class="string">"ababa"</span>.match_indices(<span class="string">"aba"</span>).collect();
<span class="macro">assert_eq!</span>(v, [(<span class="number">0</span>, <span class="string">"aba"</span>)]); <span class="comment">// only the first `aba`</span></code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+v:+Vec%3C_%3E+=+%22abcXXXabcYYYabc%22.match_indices(%22abc%22).collect();%0A++++assert_eq!(v,+%5B(0,+%22abc%22),+(6,+%22abc%22),+(12,+%22abc%22)%5D);%0A++++%0A++++let+v:+Vec%3C_%3E+=+%221abcabc2%22.match_indices(%22abc%22).collect();%0A++++assert_eq!(v,+%5B(1,+%22abc%22),+(4,+%22abc%22)%5D);%0A++++%0A++++let+v:+Vec%3C_%3E+=+%22ababa%22.match_indices(%22aba%22).collect();%0A++++assert_eq!(v,+%5B(0,+%22aba%22)%5D);+//+only+the+first+%60aba%60%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.rmatch_indices" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.5.0">1.5.0</span> Â· <a class="src" href="https://doc.rust-lang.org/1.80.1/src/core/str/mod.rs.html#1919-1921">source</a></span><h4 class="code-header">pub fn <a href="#method.rmatch_indices" class="fn">rmatch_indices</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; <a class="struct" href="str/struct.RMatchIndices.html" title="struct std::str::RMatchIndices">RMatchIndices</a>&lt;'a, P&gt; <a href="#" class="tooltip" data-notable-ty="RMatchIndices&lt;&#39;a, P&gt;">â“˜</a><div class="where">where
    P: <a class="trait" href="str/pattern/trait.Pattern.html" title="trait std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,
    &lt;P as <a class="trait" href="str/pattern/trait.Pattern.html" title="trait std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;&gt;::<a class="associatedtype" href="str/pattern/trait.Pattern.html#associatedtype.Searcher" title="type std::str::pattern::Pattern::Searcher">Searcher</a>: <a class="trait" href="str/pattern/trait.ReverseSearcher.html" title="trait std::str::pattern::ReverseSearcher">ReverseSearcher</a>&lt;'a&gt;,</div></h4></section></summary><div class="docblock"><p>An iterator over the disjoint matches of a pattern within <code>self</code>,
yielded in reverse order along with the index of the match.</p>
<p>For matches of <code>pat</code> within <code>self</code> that overlap, only the indices
corresponding to the last match are returned.</p>
<p>The <a href="str/pattern/index.html" title="mod std::str::pattern">pattern</a> can be a <code>&amp;str</code>, <a href="primitive.char.html" title="primitive char"><code>char</code></a>, a slice of <a href="primitive.char.html" title="primitive char"><code>char</code></a>s, or a
function or closure that determines if a character matches.</p>
<h5 id="iterator-behavior-9"><a class="doc-anchor" href="#iterator-behavior-9">Â§</a>Iterator behavior</h5>
<p>The returned iterator requires that the pattern supports a reverse
search, and it will be a <a href="iter/trait.DoubleEndedIterator.html" title="trait std::iter::DoubleEndedIterator"><code>DoubleEndedIterator</code></a> if a forward/reverse
search yields the same elements.</p>
<p>For iterating from the front, the <a href="primitive.str.html#method.match_indices" title="method str::match_indices"><code>match_indices</code></a> method can be used.</p>
<h5 id="examples-41"><a class="doc-anchor" href="#examples-41">Â§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>v: Vec&lt;<span class="kw">_</span>&gt; = <span class="string">"abcXXXabcYYYabc"</span>.rmatch_indices(<span class="string">"abc"</span>).collect();
<span class="macro">assert_eq!</span>(v, [(<span class="number">12</span>, <span class="string">"abc"</span>), (<span class="number">6</span>, <span class="string">"abc"</span>), (<span class="number">0</span>, <span class="string">"abc"</span>)]);

<span class="kw">let </span>v: Vec&lt;<span class="kw">_</span>&gt; = <span class="string">"1abcabc2"</span>.rmatch_indices(<span class="string">"abc"</span>).collect();
<span class="macro">assert_eq!</span>(v, [(<span class="number">4</span>, <span class="string">"abc"</span>), (<span class="number">1</span>, <span class="string">"abc"</span>)]);

<span class="kw">let </span>v: Vec&lt;<span class="kw">_</span>&gt; = <span class="string">"ababa"</span>.rmatch_indices(<span class="string">"aba"</span>).collect();
<span class="macro">assert_eq!</span>(v, [(<span class="number">2</span>, <span class="string">"aba"</span>)]); <span class="comment">// only the last `aba`</span></code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+v:+Vec%3C_%3E+=+%22abcXXXabcYYYabc%22.rmatch_indices(%22abc%22).collect();%0A++++assert_eq!(v,+%5B(12,+%22abc%22),+(6,+%22abc%22),+(0,+%22abc%22)%5D);%0A++++%0A++++let+v:+Vec%3C_%3E+=+%221abcabc2%22.rmatch_indices(%22abc%22).collect();%0A++++assert_eq!(v,+%5B(4,+%22abc%22),+(1,+%22abc%22)%5D);%0A++++%0A++++let+v:+Vec%3C_%3E+=+%22ababa%22.rmatch_indices(%22aba%22).collect();%0A++++assert_eq!(v,+%5B(2,+%22aba%22)%5D);+//+only+the+last+%60aba%60%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.trim" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="https://doc.rust-lang.org/1.80.1/src/core/str/mod.rs.html#1943">source</a></span><h4 class="code-header">pub fn <a href="#method.trim" class="fn">trim</a>(&amp;self) -&gt; &amp;<a class="primitive" href="primitive.str.html">str</a></h4></section></summary><div class="docblock"><p>Returns a string slice with leading and trailing whitespace removed.</p>
<p>â€˜Whitespaceâ€™ is defined according to the terms of the Unicode Derived
Core Property <code>White_Space</code>, which includes newlines.</p>
<h5 id="examples-42"><a class="doc-anchor" href="#examples-42">Â§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>s = <span class="string">"\n Hello\tworld\t\n"</span>;

<span class="macro">assert_eq!</span>(<span class="string">"Hello\tworld"</span>, s.trim());</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+s+=+%22%5Cn+Hello%5Ctworld%5Ct%5Cn%22;%0A++++%0A++++assert_eq!(%22Hello%5Ctworld%22,+s.trim());%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.trim_start" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.30.0">1.30.0</span> Â· <a class="src" href="https://doc.rust-lang.org/1.80.1/src/core/str/mod.rs.html#1982">source</a></span><h4 class="code-header">pub fn <a href="#method.trim_start" class="fn">trim_start</a>(&amp;self) -&gt; &amp;<a class="primitive" href="primitive.str.html">str</a></h4></section></summary><div class="docblock"><p>Returns a string slice with leading whitespace removed.</p>
<p>â€˜Whitespaceâ€™ is defined according to the terms of the Unicode Derived
Core Property <code>White_Space</code>, which includes newlines.</p>
<h5 id="text-directionality"><a class="doc-anchor" href="#text-directionality">Â§</a>Text directionality</h5>
<p>A string is a sequence of bytes. <code>start</code> in this context means the first
position of that byte string; for a left-to-right language like English or
Russian, this will be left side, and for right-to-left languages like
Arabic or Hebrew, this will be the right side.</p>
<h5 id="examples-43"><a class="doc-anchor" href="#examples-43">Â§</a>Examples</h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>s = <span class="string">"\n Hello\tworld\t\n"</span>;
<span class="macro">assert_eq!</span>(<span class="string">"Hello\tworld\t\n"</span>, s.trim_start());</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+s+=+%22%5Cn+Hello%5Ctworld%5Ct%5Cn%22;%0A++++assert_eq!(%22Hello%5Ctworld%5Ct%5Cn%22,+s.trim_start());%0A%7D&amp;edition=2021">Run</a></div>
<p>Directionality:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>s = <span class="string">"  English  "</span>;
<span class="macro">assert!</span>(<span class="prelude-val">Some</span>(<span class="string">'E'</span>) == s.trim_start().chars().next());

<span class="kw">let </span>s = <span class="string">"  ×¢×‘×¨×™×ª  "</span>;
<span class="macro">assert!</span>(<span class="prelude-val">Some</span>(<span class="string">'×¢'</span>) == s.trim_start().chars().next());</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+s+=+%22++English++%22;%0A++++assert!(Some('E')+==+s.trim_start().chars().next());%0A++++%0A++++let+s+=+%22++%D7%A2%D7%91%D7%A8%D7%99%D7%AA++%22;%0A++++assert!(Some('%D7%A2')+==+s.trim_start().chars().next());%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.trim_end" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.30.0">1.30.0</span> Â· <a class="src" href="https://doc.rust-lang.org/1.80.1/src/core/str/mod.rs.html#2021">source</a></span><h4 class="code-header">pub fn <a href="#method.trim_end" class="fn">trim_end</a>(&amp;self) -&gt; &amp;<a class="primitive" href="primitive.str.html">str</a></h4></section></summary><div class="docblock"><p>Returns a string slice with trailing whitespace removed.</p>
<p>â€˜Whitespaceâ€™ is defined according to the terms of the Unicode Derived
Core Property <code>White_Space</code>, which includes newlines.</p>
<h5 id="text-directionality-1"><a class="doc-anchor" href="#text-directionality-1">Â§</a>Text directionality</h5>
<p>A string is a sequence of bytes. <code>end</code> in this context means the last
position of that byte string; for a left-to-right language like English or
Russian, this will be right side, and for right-to-left languages like
Arabic or Hebrew, this will be the left side.</p>
<h5 id="examples-44"><a class="doc-anchor" href="#examples-44">Â§</a>Examples</h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>s = <span class="string">"\n Hello\tworld\t\n"</span>;
<span class="macro">assert_eq!</span>(<span class="string">"\n Hello\tworld"</span>, s.trim_end());</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+s+=+%22%5Cn+Hello%5Ctworld%5Ct%5Cn%22;%0A++++assert_eq!(%22%5Cn+Hello%5Ctworld%22,+s.trim_end());%0A%7D&amp;edition=2021">Run</a></div>
<p>Directionality:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>s = <span class="string">"  English  "</span>;
<span class="macro">assert!</span>(<span class="prelude-val">Some</span>(<span class="string">'h'</span>) == s.trim_end().chars().rev().next());

<span class="kw">let </span>s = <span class="string">"  ×¢×‘×¨×™×ª  "</span>;
<span class="macro">assert!</span>(<span class="prelude-val">Some</span>(<span class="string">'×ª'</span>) == s.trim_end().chars().rev().next());</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+s+=+%22++English++%22;%0A++++assert!(Some('h')+==+s.trim_end().chars().rev().next());%0A++++%0A++++let+s+=+%22++%D7%A2%D7%91%D7%A8%D7%99%D7%AA++%22;%0A++++assert!(Some('%D7%AA')+==+s.trim_end().chars().rev().next());%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.trim_left" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="https://doc.rust-lang.org/1.80.1/src/core/str/mod.rs.html#2061">source</a></span><h4 class="code-header">pub fn <a href="#method.trim_left" class="fn">trim_left</a>(&amp;self) -&gt; &amp;<a class="primitive" href="primitive.str.html">str</a></h4></section><span class="item-info"><div class="stab deprecated"><span class="emoji">ğŸ‘</span><span>Deprecated since 1.33.0: superseded by <code>trim_start</code></span></div></span></summary><div class="docblock"><p>Returns a string slice with leading whitespace removed.</p>
<p>â€˜Whitespaceâ€™ is defined according to the terms of the Unicode Derived
Core Property <code>White_Space</code>.</p>
<h5 id="text-directionality-2"><a class="doc-anchor" href="#text-directionality-2">Â§</a>Text directionality</h5>
<p>A string is a sequence of bytes. â€˜Leftâ€™ in this context means the first
position of that byte string; for a language like Arabic or Hebrew
which are â€˜right to leftâ€™ rather than â€˜left to rightâ€™, this will be
the <em>right</em> side, not the left.</p>
<h5 id="examples-45"><a class="doc-anchor" href="#examples-45">Â§</a>Examples</h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>s = <span class="string">" Hello\tworld\t"</span>;

<span class="macro">assert_eq!</span>(<span class="string">"Hello\tworld\t"</span>, s.trim_left());</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+s+=+%22+Hello%5Ctworld%5Ct%22;%0A++++%0A++++assert_eq!(%22Hello%5Ctworld%5Ct%22,+s.trim_left());%0A%7D&amp;edition=2021">Run</a></div>
<p>Directionality:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>s = <span class="string">"  English"</span>;
<span class="macro">assert!</span>(<span class="prelude-val">Some</span>(<span class="string">'E'</span>) == s.trim_left().chars().next());

<span class="kw">let </span>s = <span class="string">"  ×¢×‘×¨×™×ª"</span>;
<span class="macro">assert!</span>(<span class="prelude-val">Some</span>(<span class="string">'×¢'</span>) == s.trim_left().chars().next());</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+s+=+%22++English%22;%0A++++assert!(Some('E')+==+s.trim_left().chars().next());%0A++++%0A++++let+s+=+%22++%D7%A2%D7%91%D7%A8%D7%99%D7%AA%22;%0A++++assert!(Some('%D7%A2')+==+s.trim_left().chars().next());%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.trim_right" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="https://doc.rust-lang.org/1.80.1/src/core/str/mod.rs.html#2101">source</a></span><h4 class="code-header">pub fn <a href="#method.trim_right" class="fn">trim_right</a>(&amp;self) -&gt; &amp;<a class="primitive" href="primitive.str.html">str</a></h4></section><span class="item-info"><div class="stab deprecated"><span class="emoji">ğŸ‘</span><span>Deprecated since 1.33.0: superseded by <code>trim_end</code></span></div></span></summary><div class="docblock"><p>Returns a string slice with trailing whitespace removed.</p>
<p>â€˜Whitespaceâ€™ is defined according to the terms of the Unicode Derived
Core Property <code>White_Space</code>.</p>
<h5 id="text-directionality-3"><a class="doc-anchor" href="#text-directionality-3">Â§</a>Text directionality</h5>
<p>A string is a sequence of bytes. â€˜Rightâ€™ in this context means the last
position of that byte string; for a language like Arabic or Hebrew
which are â€˜right to leftâ€™ rather than â€˜left to rightâ€™, this will be
the <em>left</em> side, not the right.</p>
<h5 id="examples-46"><a class="doc-anchor" href="#examples-46">Â§</a>Examples</h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>s = <span class="string">" Hello\tworld\t"</span>;

<span class="macro">assert_eq!</span>(<span class="string">" Hello\tworld"</span>, s.trim_right());</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+s+=+%22+Hello%5Ctworld%5Ct%22;%0A++++%0A++++assert_eq!(%22+Hello%5Ctworld%22,+s.trim_right());%0A%7D&amp;edition=2021">Run</a></div>
<p>Directionality:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>s = <span class="string">"English  "</span>;
<span class="macro">assert!</span>(<span class="prelude-val">Some</span>(<span class="string">'h'</span>) == s.trim_right().chars().rev().next());

<span class="kw">let </span>s = <span class="string">"×¢×‘×¨×™×ª  "</span>;
<span class="macro">assert!</span>(<span class="prelude-val">Some</span>(<span class="string">'×ª'</span>) == s.trim_right().chars().rev().next());</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+s+=+%22English++%22;%0A++++assert!(Some('h')+==+s.trim_right().chars().rev().next());%0A++++%0A++++let+s+=+%22%D7%A2%D7%91%D7%A8%D7%99%D7%AA++%22;%0A++++assert!(Some('%D7%AA')+==+s.trim_right().chars().rev().next());%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.trim_matches" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="https://doc.rust-lang.org/1.80.1/src/core/str/mod.rs.html#2134-2136">source</a></span><h4 class="code-header">pub fn <a href="#method.trim_matches" class="fn">trim_matches</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; &amp;'a <a class="primitive" href="primitive.str.html">str</a><div class="where">where
    P: <a class="trait" href="str/pattern/trait.Pattern.html" title="trait std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,
    &lt;P as <a class="trait" href="str/pattern/trait.Pattern.html" title="trait std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;&gt;::<a class="associatedtype" href="str/pattern/trait.Pattern.html#associatedtype.Searcher" title="type std::str::pattern::Pattern::Searcher">Searcher</a>: <a class="trait" href="str/pattern/trait.DoubleEndedSearcher.html" title="trait std::str::pattern::DoubleEndedSearcher">DoubleEndedSearcher</a>&lt;'a&gt;,</div></h4></section></summary><div class="docblock"><p>Returns a string slice with all prefixes and suffixes that match a
pattern repeatedly removed.</p>
<p>The <a href="str/pattern/index.html" title="mod std::str::pattern">pattern</a> can be a <a href="primitive.char.html" title="primitive char"><code>char</code></a>, a slice of <a href="primitive.char.html" title="primitive char"><code>char</code></a>s, or a function
or closure that determines if a character matches.</p>
<h5 id="examples-47"><a class="doc-anchor" href="#examples-47">Â§</a>Examples</h5>
<p>Simple patterns:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(<span class="string">"11foo1bar11"</span>.trim_matches(<span class="string">'1'</span>), <span class="string">"foo1bar"</span>);
<span class="macro">assert_eq!</span>(<span class="string">"123foo1bar123"</span>.trim_matches(char::is_numeric), <span class="string">"foo1bar"</span>);

<span class="kw">let </span>x: <span class="kw-2">&amp;</span>[<span class="kw">_</span>] = <span class="kw-2">&amp;</span>[<span class="string">'1'</span>, <span class="string">'2'</span>];
<span class="macro">assert_eq!</span>(<span class="string">"12foo1bar12"</span>.trim_matches(x), <span class="string">"foo1bar"</span>);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++assert_eq!(%2211foo1bar11%22.trim_matches('1'),+%22foo1bar%22);%0A++++assert_eq!(%22123foo1bar123%22.trim_matches(char::is_numeric),+%22foo1bar%22);%0A++++%0A++++let+x:+%26%5B_%5D+=+%26%5B'1',+'2'%5D;%0A++++assert_eq!(%2212foo1bar12%22.trim_matches(x),+%22foo1bar%22);%0A%7D&amp;edition=2021">Run</a></div>
<p>A more complex pattern, using a closure:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(<span class="string">"1foo1barXX"</span>.trim_matches(|c| c == <span class="string">'1' </span>|| c == <span class="string">'X'</span>), <span class="string">"foo1bar"</span>);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++assert_eq!(%221foo1barXX%22.trim_matches(%7Cc%7C+c+==+'1'+%7C%7C+c+==+'X'),+%22foo1bar%22);%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.trim_start_matches" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.30.0">1.30.0</span> Â· <a class="src" href="https://doc.rust-lang.org/1.80.1/src/core/str/mod.rs.html#2181">source</a></span><h4 class="code-header">pub fn <a href="#method.trim_start_matches" class="fn">trim_start_matches</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; &amp;'a <a class="primitive" href="primitive.str.html">str</a><div class="where">where
    P: <a class="trait" href="str/pattern/trait.Pattern.html" title="trait std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,</div></h4></section></summary><div class="docblock"><p>Returns a string slice with all prefixes that match a pattern
repeatedly removed.</p>
<p>The <a href="str/pattern/index.html" title="mod std::str::pattern">pattern</a> can be a <code>&amp;str</code>, <a href="primitive.char.html" title="primitive char"><code>char</code></a>, a slice of <a href="primitive.char.html" title="primitive char"><code>char</code></a>s, or a
function or closure that determines if a character matches.</p>
<h5 id="text-directionality-4"><a class="doc-anchor" href="#text-directionality-4">Â§</a>Text directionality</h5>
<p>A string is a sequence of bytes. <code>start</code> in this context means the first
position of that byte string; for a left-to-right language like English or
Russian, this will be left side, and for right-to-left languages like
Arabic or Hebrew, this will be the right side.</p>
<h5 id="examples-48"><a class="doc-anchor" href="#examples-48">Â§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(<span class="string">"11foo1bar11"</span>.trim_start_matches(<span class="string">'1'</span>), <span class="string">"foo1bar11"</span>);
<span class="macro">assert_eq!</span>(<span class="string">"123foo1bar123"</span>.trim_start_matches(char::is_numeric), <span class="string">"foo1bar123"</span>);

<span class="kw">let </span>x: <span class="kw-2">&amp;</span>[<span class="kw">_</span>] = <span class="kw-2">&amp;</span>[<span class="string">'1'</span>, <span class="string">'2'</span>];
<span class="macro">assert_eq!</span>(<span class="string">"12foo1bar12"</span>.trim_start_matches(x), <span class="string">"foo1bar12"</span>);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++assert_eq!(%2211foo1bar11%22.trim_start_matches('1'),+%22foo1bar11%22);%0A++++assert_eq!(%22123foo1bar123%22.trim_start_matches(char::is_numeric),+%22foo1bar123%22);%0A++++%0A++++let+x:+%26%5B_%5D+=+%26%5B'1',+'2'%5D;%0A++++assert_eq!(%2212foo1bar12%22.trim_start_matches(x),+%22foo1bar12%22);%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.strip_prefix" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.45.0">1.45.0</span> Â· <a class="src" href="https://doc.rust-lang.org/1.80.1/src/core/str/mod.rs.html#2214">source</a></span><h4 class="code-header">pub fn <a href="#method.strip_prefix" class="fn">strip_prefix</a>&lt;'a, P&gt;(&amp;'a self, prefix: P) -&gt; <a class="enum" href="option/enum.Option.html" title="enum std::option::Option">Option</a>&lt;&amp;'a <a class="primitive" href="primitive.str.html">str</a>&gt;<div class="where">where
    P: <a class="trait" href="str/pattern/trait.Pattern.html" title="trait std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,</div></h4></section></summary><div class="docblock"><p>Returns a string slice with the prefix removed.</p>
<p>If the string starts with the pattern <code>prefix</code>, returns the substring after the prefix,
wrapped in <code>Some</code>. Unlike <code>trim_start_matches</code>, this method removes the prefix exactly once.</p>
<p>If the string does not start with <code>prefix</code>, returns <code>None</code>.</p>
<p>The <a href="str/pattern/index.html" title="mod std::str::pattern">pattern</a> can be a <code>&amp;str</code>, <a href="primitive.char.html" title="primitive char"><code>char</code></a>, a slice of <a href="primitive.char.html" title="primitive char"><code>char</code></a>s, or a
function or closure that determines if a character matches.</p>
<h5 id="examples-49"><a class="doc-anchor" href="#examples-49">Â§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(<span class="string">"foo:bar"</span>.strip_prefix(<span class="string">"foo:"</span>), <span class="prelude-val">Some</span>(<span class="string">"bar"</span>));
<span class="macro">assert_eq!</span>(<span class="string">"foo:bar"</span>.strip_prefix(<span class="string">"bar"</span>), <span class="prelude-val">None</span>);
<span class="macro">assert_eq!</span>(<span class="string">"foofoo"</span>.strip_prefix(<span class="string">"foo"</span>), <span class="prelude-val">Some</span>(<span class="string">"foo"</span>));</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++assert_eq!(%22foo:bar%22.strip_prefix(%22foo:%22),+Some(%22bar%22));%0A++++assert_eq!(%22foo:bar%22.strip_prefix(%22bar%22),+None);%0A++++assert_eq!(%22foofoo%22.strip_prefix(%22foo%22),+Some(%22foo%22));%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.strip_suffix" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.45.0">1.45.0</span> Â· <a class="src" href="https://doc.rust-lang.org/1.80.1/src/core/str/mod.rs.html#2241-2244">source</a></span><h4 class="code-header">pub fn <a href="#method.strip_suffix" class="fn">strip_suffix</a>&lt;'a, P&gt;(&amp;'a self, suffix: P) -&gt; <a class="enum" href="option/enum.Option.html" title="enum std::option::Option">Option</a>&lt;&amp;'a <a class="primitive" href="primitive.str.html">str</a>&gt;<div class="where">where
    P: <a class="trait" href="str/pattern/trait.Pattern.html" title="trait std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,
    &lt;P as <a class="trait" href="str/pattern/trait.Pattern.html" title="trait std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;&gt;::<a class="associatedtype" href="str/pattern/trait.Pattern.html#associatedtype.Searcher" title="type std::str::pattern::Pattern::Searcher">Searcher</a>: <a class="trait" href="str/pattern/trait.ReverseSearcher.html" title="trait std::str::pattern::ReverseSearcher">ReverseSearcher</a>&lt;'a&gt;,</div></h4></section></summary><div class="docblock"><p>Returns a string slice with the suffix removed.</p>
<p>If the string ends with the pattern <code>suffix</code>, returns the substring before the suffix,
wrapped in <code>Some</code>.  Unlike <code>trim_end_matches</code>, this method removes the suffix exactly once.</p>
<p>If the string does not end with <code>suffix</code>, returns <code>None</code>.</p>
<p>The <a href="str/pattern/index.html" title="mod std::str::pattern">pattern</a> can be a <code>&amp;str</code>, <a href="primitive.char.html" title="primitive char"><code>char</code></a>, a slice of <a href="primitive.char.html" title="primitive char"><code>char</code></a>s, or a
function or closure that determines if a character matches.</p>
<h5 id="examples-50"><a class="doc-anchor" href="#examples-50">Â§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(<span class="string">"bar:foo"</span>.strip_suffix(<span class="string">":foo"</span>), <span class="prelude-val">Some</span>(<span class="string">"bar"</span>));
<span class="macro">assert_eq!</span>(<span class="string">"bar:foo"</span>.strip_suffix(<span class="string">"bar"</span>), <span class="prelude-val">None</span>);
<span class="macro">assert_eq!</span>(<span class="string">"foofoo"</span>.strip_suffix(<span class="string">"foo"</span>), <span class="prelude-val">Some</span>(<span class="string">"foo"</span>));</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++assert_eq!(%22bar:foo%22.strip_suffix(%22:foo%22),+Some(%22bar%22));%0A++++assert_eq!(%22bar:foo%22.strip_suffix(%22bar%22),+None);%0A++++assert_eq!(%22foofoo%22.strip_suffix(%22foo%22),+Some(%22foo%22));%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.trim_end_matches" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.30.0">1.30.0</span> Â· <a class="src" href="https://doc.rust-lang.org/1.80.1/src/core/str/mod.rs.html#2285-2287">source</a></span><h4 class="code-header">pub fn <a href="#method.trim_end_matches" class="fn">trim_end_matches</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; &amp;'a <a class="primitive" href="primitive.str.html">str</a><div class="where">where
    P: <a class="trait" href="str/pattern/trait.Pattern.html" title="trait std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,
    &lt;P as <a class="trait" href="str/pattern/trait.Pattern.html" title="trait std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;&gt;::<a class="associatedtype" href="str/pattern/trait.Pattern.html#associatedtype.Searcher" title="type std::str::pattern::Pattern::Searcher">Searcher</a>: <a class="trait" href="str/pattern/trait.ReverseSearcher.html" title="trait std::str::pattern::ReverseSearcher">ReverseSearcher</a>&lt;'a&gt;,</div></h4></section></summary><div class="docblock"><p>Returns a string slice with all suffixes that match a pattern
repeatedly removed.</p>
<p>The <a href="str/pattern/index.html" title="mod std::str::pattern">pattern</a> can be a <code>&amp;str</code>, <a href="primitive.char.html" title="primitive char"><code>char</code></a>, a slice of <a href="primitive.char.html" title="primitive char"><code>char</code></a>s, or a
function or closure that determines if a character matches.</p>
<h5 id="text-directionality-5"><a class="doc-anchor" href="#text-directionality-5">Â§</a>Text directionality</h5>
<p>A string is a sequence of bytes. <code>end</code> in this context means the last
position of that byte string; for a left-to-right language like English or
Russian, this will be right side, and for right-to-left languages like
Arabic or Hebrew, this will be the left side.</p>
<h5 id="examples-51"><a class="doc-anchor" href="#examples-51">Â§</a>Examples</h5>
<p>Simple patterns:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(<span class="string">"11foo1bar11"</span>.trim_end_matches(<span class="string">'1'</span>), <span class="string">"11foo1bar"</span>);
<span class="macro">assert_eq!</span>(<span class="string">"123foo1bar123"</span>.trim_end_matches(char::is_numeric), <span class="string">"123foo1bar"</span>);

<span class="kw">let </span>x: <span class="kw-2">&amp;</span>[<span class="kw">_</span>] = <span class="kw-2">&amp;</span>[<span class="string">'1'</span>, <span class="string">'2'</span>];
<span class="macro">assert_eq!</span>(<span class="string">"12foo1bar12"</span>.trim_end_matches(x), <span class="string">"12foo1bar"</span>);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++assert_eq!(%2211foo1bar11%22.trim_end_matches('1'),+%2211foo1bar%22);%0A++++assert_eq!(%22123foo1bar123%22.trim_end_matches(char::is_numeric),+%22123foo1bar%22);%0A++++%0A++++let+x:+%26%5B_%5D+=+%26%5B'1',+'2'%5D;%0A++++assert_eq!(%2212foo1bar12%22.trim_end_matches(x),+%2212foo1bar%22);%0A%7D&amp;edition=2021">Run</a></div>
<p>A more complex pattern, using a closure:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(<span class="string">"1fooX"</span>.trim_end_matches(|c| c == <span class="string">'1' </span>|| c == <span class="string">'X'</span>), <span class="string">"1foo"</span>);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++assert_eq!(%221fooX%22.trim_end_matches(%7Cc%7C+c+==+'1'+%7C%7C+c+==+'X'),+%221foo%22);%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.trim_left_matches" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="https://doc.rust-lang.org/1.80.1/src/core/str/mod.rs.html#2329">source</a></span><h4 class="code-header">pub fn <a href="#method.trim_left_matches" class="fn">trim_left_matches</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; &amp;'a <a class="primitive" href="primitive.str.html">str</a><div class="where">where
    P: <a class="trait" href="str/pattern/trait.Pattern.html" title="trait std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,</div></h4></section><span class="item-info"><div class="stab deprecated"><span class="emoji">ğŸ‘</span><span>Deprecated since 1.33.0: superseded by <code>trim_start_matches</code></span></div></span></summary><div class="docblock"><p>Returns a string slice with all prefixes that match a pattern
repeatedly removed.</p>
<p>The <a href="str/pattern/index.html" title="mod std::str::pattern">pattern</a> can be a <code>&amp;str</code>, <a href="primitive.char.html" title="primitive char"><code>char</code></a>, a slice of <a href="primitive.char.html" title="primitive char"><code>char</code></a>s, or a
function or closure that determines if a character matches.</p>
<h5 id="text-directionality-6"><a class="doc-anchor" href="#text-directionality-6">Â§</a>Text directionality</h5>
<p>A string is a sequence of bytes. â€˜Leftâ€™ in this context means the first
position of that byte string; for a language like Arabic or Hebrew
which are â€˜right to leftâ€™ rather than â€˜left to rightâ€™, this will be
the <em>right</em> side, not the left.</p>
<h5 id="examples-52"><a class="doc-anchor" href="#examples-52">Â§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(<span class="string">"11foo1bar11"</span>.trim_left_matches(<span class="string">'1'</span>), <span class="string">"foo1bar11"</span>);
<span class="macro">assert_eq!</span>(<span class="string">"123foo1bar123"</span>.trim_left_matches(char::is_numeric), <span class="string">"foo1bar123"</span>);

<span class="kw">let </span>x: <span class="kw-2">&amp;</span>[<span class="kw">_</span>] = <span class="kw-2">&amp;</span>[<span class="string">'1'</span>, <span class="string">'2'</span>];
<span class="macro">assert_eq!</span>(<span class="string">"12foo1bar12"</span>.trim_left_matches(x), <span class="string">"foo1bar12"</span>);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++assert_eq!(%2211foo1bar11%22.trim_left_matches('1'),+%22foo1bar11%22);%0A++++assert_eq!(%22123foo1bar123%22.trim_left_matches(char::is_numeric),+%22foo1bar123%22);%0A++++%0A++++let+x:+%26%5B_%5D+=+%26%5B'1',+'2'%5D;%0A++++assert_eq!(%2212foo1bar12%22.trim_left_matches(x),+%22foo1bar12%22);%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.trim_right_matches" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="https://doc.rust-lang.org/1.80.1/src/core/str/mod.rs.html#2372-2374">source</a></span><h4 class="code-header">pub fn <a href="#method.trim_right_matches" class="fn">trim_right_matches</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; &amp;'a <a class="primitive" href="primitive.str.html">str</a><div class="where">where
    P: <a class="trait" href="str/pattern/trait.Pattern.html" title="trait std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,
    &lt;P as <a class="trait" href="str/pattern/trait.Pattern.html" title="trait std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;&gt;::<a class="associatedtype" href="str/pattern/trait.Pattern.html#associatedtype.Searcher" title="type std::str::pattern::Pattern::Searcher">Searcher</a>: <a class="trait" href="str/pattern/trait.ReverseSearcher.html" title="trait std::str::pattern::ReverseSearcher">ReverseSearcher</a>&lt;'a&gt;,</div></h4></section><span class="item-info"><div class="stab deprecated"><span class="emoji">ğŸ‘</span><span>Deprecated since 1.33.0: superseded by <code>trim_end_matches</code></span></div></span></summary><div class="docblock"><p>Returns a string slice with all suffixes that match a pattern
repeatedly removed.</p>
<p>The <a href="str/pattern/index.html" title="mod std::str::pattern">pattern</a> can be a <code>&amp;str</code>, <a href="primitive.char.html" title="primitive char"><code>char</code></a>, a slice of <a href="primitive.char.html" title="primitive char"><code>char</code></a>s, or a
function or closure that determines if a character matches.</p>
<h5 id="text-directionality-7"><a class="doc-anchor" href="#text-directionality-7">Â§</a>Text directionality</h5>
<p>A string is a sequence of bytes. â€˜Rightâ€™ in this context means the last
position of that byte string; for a language like Arabic or Hebrew
which are â€˜right to leftâ€™ rather than â€˜left to rightâ€™, this will be
the <em>left</em> side, not the right.</p>
<h5 id="examples-53"><a class="doc-anchor" href="#examples-53">Â§</a>Examples</h5>
<p>Simple patterns:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(<span class="string">"11foo1bar11"</span>.trim_right_matches(<span class="string">'1'</span>), <span class="string">"11foo1bar"</span>);
<span class="macro">assert_eq!</span>(<span class="string">"123foo1bar123"</span>.trim_right_matches(char::is_numeric), <span class="string">"123foo1bar"</span>);

<span class="kw">let </span>x: <span class="kw-2">&amp;</span>[<span class="kw">_</span>] = <span class="kw-2">&amp;</span>[<span class="string">'1'</span>, <span class="string">'2'</span>];
<span class="macro">assert_eq!</span>(<span class="string">"12foo1bar12"</span>.trim_right_matches(x), <span class="string">"12foo1bar"</span>);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++assert_eq!(%2211foo1bar11%22.trim_right_matches('1'),+%2211foo1bar%22);%0A++++assert_eq!(%22123foo1bar123%22.trim_right_matches(char::is_numeric),+%22123foo1bar%22);%0A++++%0A++++let+x:+%26%5B_%5D+=+%26%5B'1',+'2'%5D;%0A++++assert_eq!(%2212foo1bar12%22.trim_right_matches(x),+%2212foo1bar%22);%0A%7D&amp;edition=2021">Run</a></div>
<p>A more complex pattern, using a closure:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(<span class="string">"1fooX"</span>.trim_right_matches(|c| c == <span class="string">'1' </span>|| c == <span class="string">'X'</span>), <span class="string">"1foo"</span>);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++assert_eq!(%221fooX%22.trim_right_matches(%7Cc%7C+c+==+'1'+%7C%7C+c+==+'X'),+%221foo%22);%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.parse" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="https://doc.rust-lang.org/1.80.1/src/core/str/mod.rs.html#2424">source</a></span><h4 class="code-header">pub fn <a href="#method.parse" class="fn">parse</a>&lt;F&gt;(&amp;self) -&gt; <a class="enum" href="result/enum.Result.html" title="enum std::result::Result">Result</a>&lt;F, &lt;F as <a class="trait" href="str/trait.FromStr.html" title="trait std::str::FromStr">FromStr</a>&gt;::<a class="associatedtype" href="str/trait.FromStr.html#associatedtype.Err" title="type std::str::FromStr::Err">Err</a>&gt;<div class="where">where
    F: <a class="trait" href="str/trait.FromStr.html" title="trait std::str::FromStr">FromStr</a>,</div></h4></section></summary><div class="docblock"><p>Parses this string slice into another type.</p>
<p>Because <code>parse</code> is so general, it can cause problems with type
inference. As such, <code>parse</code> is one of the few times youâ€™ll see
the syntax affectionately known as the â€˜turbofishâ€™: <code>::&lt;&gt;</code>. This
helps the inference algorithm understand specifically which type
youâ€™re trying to parse into.</p>
<p><code>parse</code> can parse into any type that implements the <a href="str/trait.FromStr.html" title="trait std::str::FromStr"><code>FromStr</code></a> trait.</p>
<h5 id="errors"><a class="doc-anchor" href="#errors">Â§</a>Errors</h5>
<p>Will return <a href="str/trait.FromStr.html#associatedtype.Err" title="associated type std::str::FromStr::Err"><code>Err</code></a> if itâ€™s not possible to parse this string slice into
the desired type.</p>
<h5 id="examples-54"><a class="doc-anchor" href="#examples-54">Â§</a>Examples</h5>
<p>Basic usage</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>four: u32 = <span class="string">"4"</span>.parse().unwrap();

<span class="macro">assert_eq!</span>(<span class="number">4</span>, four);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+four:+u32+=+%224%22.parse().unwrap();%0A++++%0A++++assert_eq!(4,+four);%0A%7D&amp;edition=2021">Run</a></div>
<p>Using the â€˜turbofishâ€™ instead of annotating <code>four</code>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>four = <span class="string">"4"</span>.parse::&lt;u32&gt;();

<span class="macro">assert_eq!</span>(<span class="prelude-val">Ok</span>(<span class="number">4</span>), four);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+four+=+%224%22.parse::%3Cu32%3E();%0A++++%0A++++assert_eq!(Ok(4),+four);%0A%7D&amp;edition=2021">Run</a></div>
<p>Failing to parse:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>nope = <span class="string">"j"</span>.parse::&lt;u32&gt;();

<span class="macro">assert!</span>(nope.is_err());</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+nope+=+%22j%22.parse::%3Cu32%3E();%0A++++%0A++++assert!(nope.is_err());%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.is_ascii" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.23.0, const since 1.74.0">1.23.0 (const: 1.74.0)</span> Â· <a class="src" href="https://doc.rust-lang.org/1.80.1/src/core/str/mod.rs.html#2443">source</a></span><h4 class="code-header">pub const fn <a href="#method.is_ascii" class="fn">is_ascii</a>(&amp;self) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Checks if all characters in this string are within the ASCII range.</p>
<h5 id="examples-55"><a class="doc-anchor" href="#examples-55">Â§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>ascii = <span class="string">"hello!\n"</span>;
<span class="kw">let </span>non_ascii = <span class="string">"GrÃ¼ÃŸe, JÃ¼rgen â¤"</span>;

<span class="macro">assert!</span>(ascii.is_ascii());
<span class="macro">assert!</span>(!non_ascii.is_ascii());</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+ascii+=+%22hello!%5Cn%22;%0A++++let+non_ascii+=+%22Gr%C3%BC%C3%9Fe,+J%C3%BCrgen+%E2%9D%A4%22;%0A++++%0A++++assert!(ascii.is_ascii());%0A++++assert!(!non_ascii.is_ascii());%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.as_ascii" class="method"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/str/mod.rs.html#2455">source</a><h4 class="code-header">pub const fn <a href="#method.as_ascii" class="fn">as_ascii</a>(&amp;self) -&gt; <a class="enum" href="option/enum.Option.html" title="enum std::option::Option">Option</a>&lt;&amp;[<a class="enum" href="ascii/enum.Char.html" title="enum std::ascii::Char">AsciiChar</a>]&gt;</h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>ascii_char</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/110998">#110998</a>)</span></div></span></summary><div class="docblock"><p>If this string slice <a href="primitive.str.html#method.is_ascii" title="method str::is_ascii"><code>is_ascii</code></a>, returns it as a slice
of <a href="ascii/enum.Char.html" title="enum std::ascii::Char">ASCII characters</a>, otherwise returns <code>None</code>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.eq_ignore_ascii_case" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.23.0">1.23.0</span> Â· <a class="src" href="https://doc.rust-lang.org/1.80.1/src/core/str/mod.rs.html#2475">source</a></span><h4 class="code-header">pub fn <a href="#method.eq_ignore_ascii_case" class="fn">eq_ignore_ascii_case</a>(&amp;self, other: &amp;<a class="primitive" href="primitive.str.html">str</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Checks that two strings are an ASCII case-insensitive match.</p>
<p>Same as <code>to_ascii_lowercase(a) == to_ascii_lowercase(b)</code>,
but without allocating and copying temporaries.</p>
<h5 id="examples-56"><a class="doc-anchor" href="#examples-56">Â§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert!</span>(<span class="string">"Ferris"</span>.eq_ignore_ascii_case(<span class="string">"FERRIS"</span>));
<span class="macro">assert!</span>(<span class="string">"FerrÃ¶s"</span>.eq_ignore_ascii_case(<span class="string">"FERRÃ¶S"</span>));
<span class="macro">assert!</span>(!<span class="string">"FerrÃ¶s"</span>.eq_ignore_ascii_case(<span class="string">"FERRÃ–S"</span>));</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++assert!(%22Ferris%22.eq_ignore_ascii_case(%22FERRIS%22));%0A++++assert!(%22Ferr%C3%B6s%22.eq_ignore_ascii_case(%22FERR%C3%B6S%22));%0A++++assert!(!%22Ferr%C3%B6s%22.eq_ignore_ascii_case(%22FERR%C3%96S%22));%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.make_ascii_uppercase" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.23.0">1.23.0</span> Â· <a class="src" href="https://doc.rust-lang.org/1.80.1/src/core/str/mod.rs.html#2500">source</a></span><h4 class="code-header">pub fn <a href="#method.make_ascii_uppercase" class="fn">make_ascii_uppercase</a>(&amp;mut self)</h4></section></summary><div class="docblock"><p>Converts this string to its ASCII upper case equivalent in-place.</p>
<p>ASCII letters â€˜aâ€™ to â€˜zâ€™ are mapped to â€˜Aâ€™ to â€˜Zâ€™,
but non-ASCII letters are unchanged.</p>
<p>To return a new uppercased value without modifying the existing one, use
<a href="#method.to_ascii_uppercase"><code>to_ascii_uppercase()</code></a>.</p>
<h5 id="examples-57"><a class="doc-anchor" href="#examples-57">Â§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span><span class="kw-2">mut </span>s = String::from(<span class="string">"GrÃ¼ÃŸe, JÃ¼rgen â¤"</span>);

s.make_ascii_uppercase();

<span class="macro">assert_eq!</span>(<span class="string">"GRÃ¼ÃŸE, JÃ¼RGEN â¤"</span>, s);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+mut+s+=+String::from(%22Gr%C3%BC%C3%9Fe,+J%C3%BCrgen+%E2%9D%A4%22);%0A++++%0A++++s.make_ascii_uppercase();%0A++++%0A++++assert_eq!(%22GR%C3%BC%C3%9FE,+J%C3%BCRGEN+%E2%9D%A4%22,+s);%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.make_ascii_lowercase" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.23.0">1.23.0</span> Â· <a class="src" href="https://doc.rust-lang.org/1.80.1/src/core/str/mod.rs.html#2527">source</a></span><h4 class="code-header">pub fn <a href="#method.make_ascii_lowercase" class="fn">make_ascii_lowercase</a>(&amp;mut self)</h4></section></summary><div class="docblock"><p>Converts this string to its ASCII lower case equivalent in-place.</p>
<p>ASCII letters â€˜Aâ€™ to â€˜Zâ€™ are mapped to â€˜aâ€™ to â€˜zâ€™,
but non-ASCII letters are unchanged.</p>
<p>To return a new lowercased value without modifying the existing one, use
<a href="#method.to_ascii_lowercase"><code>to_ascii_lowercase()</code></a>.</p>
<h5 id="examples-58"><a class="doc-anchor" href="#examples-58">Â§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span><span class="kw-2">mut </span>s = String::from(<span class="string">"GRÃœÃŸE, JÃœRGEN â¤"</span>);

s.make_ascii_lowercase();

<span class="macro">assert_eq!</span>(<span class="string">"grÃœÃŸe, jÃœrgen â¤"</span>, s);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+mut+s+=+String::from(%22GR%C3%9C%C3%9FE,+J%C3%9CRGEN+%E2%9D%A4%22);%0A++++%0A++++s.make_ascii_lowercase();%0A++++%0A++++assert_eq!(%22gr%C3%9C%C3%9Fe,+j%C3%9Crgen+%E2%9D%A4%22,+s);%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.trim_ascii_start" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.80.0, const since 1.80.0">1.80.0 (const: 1.80.0)</span> Â· <a class="src" href="https://doc.rust-lang.org/1.80.1/src/core/str/mod.rs.html#2552">source</a></span><h4 class="code-header">pub const fn <a href="#method.trim_ascii_start" class="fn">trim_ascii_start</a>(&amp;self) -&gt; &amp;<a class="primitive" href="primitive.str.html">str</a></h4></section></summary><div class="docblock"><p>Returns a string slice with leading ASCII whitespace removed.</p>
<p>â€˜Whitespaceâ€™ refers to the definition used by
<a href="primitive.u8.html#method.is_ascii_whitespace" title="method u8::is_ascii_whitespace"><code>u8::is_ascii_whitespace</code></a>.</p>
<h5 id="examples-59"><a class="doc-anchor" href="#examples-59">Â§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(<span class="string">" \t \u{3000}hello world\n"</span>.trim_ascii_start(), <span class="string">"\u{3000}hello world\n"</span>);
<span class="macro">assert_eq!</span>(<span class="string">"  "</span>.trim_ascii_start(), <span class="string">""</span>);
<span class="macro">assert_eq!</span>(<span class="string">""</span>.trim_ascii_start(), <span class="string">""</span>);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++assert_eq!(%22+%5Ct+%5Cu%7B3000%7Dhello+world%5Cn%22.trim_ascii_start(),+%22%5Cu%7B3000%7Dhello+world%5Cn%22);%0A++++assert_eq!(%22++%22.trim_ascii_start(),+%22%22);%0A++++assert_eq!(%22%22.trim_ascii_start(),+%22%22);%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.trim_ascii_end" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.80.0, const since 1.80.0">1.80.0 (const: 1.80.0)</span> Â· <a class="src" href="https://doc.rust-lang.org/1.80.1/src/core/str/mod.rs.html#2577">source</a></span><h4 class="code-header">pub const fn <a href="#method.trim_ascii_end" class="fn">trim_ascii_end</a>(&amp;self) -&gt; &amp;<a class="primitive" href="primitive.str.html">str</a></h4></section></summary><div class="docblock"><p>Returns a string slice with trailing ASCII whitespace removed.</p>
<p>â€˜Whitespaceâ€™ refers to the definition used by
<a href="primitive.u8.html#method.is_ascii_whitespace" title="method u8::is_ascii_whitespace"><code>u8::is_ascii_whitespace</code></a>.</p>
<h5 id="examples-60"><a class="doc-anchor" href="#examples-60">Â§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(<span class="string">"\r hello world\u{3000}\n "</span>.trim_ascii_end(), <span class="string">"\r hello world\u{3000}"</span>);
<span class="macro">assert_eq!</span>(<span class="string">"  "</span>.trim_ascii_end(), <span class="string">""</span>);
<span class="macro">assert_eq!</span>(<span class="string">""</span>.trim_ascii_end(), <span class="string">""</span>);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++assert_eq!(%22%5Cr+hello+world%5Cu%7B3000%7D%5Cn+%22.trim_ascii_end(),+%22%5Cr+hello+world%5Cu%7B3000%7D%22);%0A++++assert_eq!(%22++%22.trim_ascii_end(),+%22%22);%0A++++assert_eq!(%22%22.trim_ascii_end(),+%22%22);%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.trim_ascii" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.80.0, const since 1.80.0">1.80.0 (const: 1.80.0)</span> Â· <a class="src" href="https://doc.rust-lang.org/1.80.1/src/core/str/mod.rs.html#2603">source</a></span><h4 class="code-header">pub const fn <a href="#method.trim_ascii" class="fn">trim_ascii</a>(&amp;self) -&gt; &amp;<a class="primitive" href="primitive.str.html">str</a></h4></section></summary><div class="docblock"><p>Returns a string slice with leading and trailing ASCII whitespace
removed.</p>
<p>â€˜Whitespaceâ€™ refers to the definition used by
<a href="primitive.u8.html#method.is_ascii_whitespace" title="method u8::is_ascii_whitespace"><code>u8::is_ascii_whitespace</code></a>.</p>
<h5 id="examples-61"><a class="doc-anchor" href="#examples-61">Â§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(<span class="string">"\r hello world\n "</span>.trim_ascii(), <span class="string">"hello world"</span>);
<span class="macro">assert_eq!</span>(<span class="string">"  "</span>.trim_ascii(), <span class="string">""</span>);
<span class="macro">assert_eq!</span>(<span class="string">""</span>.trim_ascii(), <span class="string">""</span>);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++assert_eq!(%22%5Cr+hello+world%5Cn+%22.trim_ascii(),+%22hello+world%22);%0A++++assert_eq!(%22++%22.trim_ascii(),+%22%22);%0A++++assert_eq!(%22%22.trim_ascii(),+%22%22);%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.escape_debug" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.34.0">1.34.0</span> Â· <a class="src" href="https://doc.rust-lang.org/1.80.1/src/core/str/mod.rs.html#2646">source</a></span><h4 class="code-header">pub fn <a href="#method.escape_debug" class="fn">escape_debug</a>(&amp;self) -&gt; <a class="struct" href="str/struct.EscapeDebug.html" title="struct std::str::EscapeDebug">EscapeDebug</a>&lt;'_&gt; <a href="#" class="tooltip" data-notable-ty="EscapeDebug&lt;&#39;_&gt;">â“˜</a></h4></section></summary><div class="docblock"><p>Return an iterator that escapes each char in <code>self</code> with <a href="primitive.char.html#method.escape_debug" title="method char::escape_debug"><code>char::escape_debug</code></a>.</p>
<p>Note: only extended grapheme codepoints that begin the string will be
escaped.</p>
<h5 id="examples-62"><a class="doc-anchor" href="#examples-62">Â§</a>Examples</h5>
<p>As an iterator:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">for </span>c <span class="kw">in </span><span class="string">"â¤\n!"</span>.escape_debug() {
    <span class="macro">print!</span>(<span class="string">"{c}"</span>);
}
<span class="macro">println!</span>();</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++for+c+in+%22%E2%9D%A4%5Cn!%22.escape_debug()+%7B%0A++++++++print!(%22%7Bc%7D%22);%0A++++%7D%0A++++println!();%0A%7D&amp;edition=2021">Run</a></div>
<p>Using <code>println!</code> directly:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">"{}"</span>, <span class="string">"â¤\n!"</span>.escape_debug());</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++println!(%22%7B%7D%22,+%22%E2%9D%A4%5Cn!%22.escape_debug());%0A%7D&amp;edition=2021">Run</a></div>
<p>Both are equivalent to:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">"â¤\\n!"</span>);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++println!(%22%E2%9D%A4%5C%5Cn!%22);%0A%7D&amp;edition=2021">Run</a></div>
<p>Using <code>to_string</code>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(<span class="string">"â¤\n!"</span>.escape_debug().to_string(), <span class="string">"â¤\\n!"</span>);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++assert_eq!(%22%E2%9D%A4%5Cn!%22.escape_debug().to_string(),+%22%E2%9D%A4%5C%5Cn!%22);%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.escape_default" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.34.0">1.34.0</span> Â· <a class="src" href="https://doc.rust-lang.org/1.80.1/src/core/str/mod.rs.html#2697">source</a></span><h4 class="code-header">pub fn <a href="#method.escape_default" class="fn">escape_default</a>(&amp;self) -&gt; <a class="struct" href="str/struct.EscapeDefault.html" title="struct std::str::EscapeDefault">EscapeDefault</a>&lt;'_&gt; <a href="#" class="tooltip" data-notable-ty="EscapeDefault&lt;&#39;_&gt;">â“˜</a></h4></section></summary><div class="docblock"><p>Return an iterator that escapes each char in <code>self</code> with <a href="primitive.char.html#method.escape_default" title="method char::escape_default"><code>char::escape_default</code></a>.</p>
<h5 id="examples-63"><a class="doc-anchor" href="#examples-63">Â§</a>Examples</h5>
<p>As an iterator:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">for </span>c <span class="kw">in </span><span class="string">"â¤\n!"</span>.escape_default() {
    <span class="macro">print!</span>(<span class="string">"{c}"</span>);
}
<span class="macro">println!</span>();</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++for+c+in+%22%E2%9D%A4%5Cn!%22.escape_default()+%7B%0A++++++++print!(%22%7Bc%7D%22);%0A++++%7D%0A++++println!();%0A%7D&amp;edition=2021">Run</a></div>
<p>Using <code>println!</code> directly:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">"{}"</span>, <span class="string">"â¤\n!"</span>.escape_default());</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++println!(%22%7B%7D%22,+%22%E2%9D%A4%5Cn!%22.escape_default());%0A%7D&amp;edition=2021">Run</a></div>
<p>Both are equivalent to:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">"\\u{{2764}}\\n!"</span>);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++println!(%22%5C%5Cu%7B%7B2764%7D%7D%5C%5Cn!%22);%0A%7D&amp;edition=2021">Run</a></div>
<p>Using <code>to_string</code>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(<span class="string">"â¤\n!"</span>.escape_default().to_string(), <span class="string">"\\u{2764}\\n!"</span>);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++assert_eq!(%22%E2%9D%A4%5Cn!%22.escape_default().to_string(),+%22%5C%5Cu%7B2764%7D%5C%5Cn!%22);%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.escape_unicode" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.34.0">1.34.0</span> Â· <a class="src" href="https://doc.rust-lang.org/1.80.1/src/core/str/mod.rs.html#2735">source</a></span><h4 class="code-header">pub fn <a href="#method.escape_unicode" class="fn">escape_unicode</a>(&amp;self) -&gt; <a class="struct" href="str/struct.EscapeUnicode.html" title="struct std::str::EscapeUnicode">EscapeUnicode</a>&lt;'_&gt; <a href="#" class="tooltip" data-notable-ty="EscapeUnicode&lt;&#39;_&gt;">â“˜</a></h4></section></summary><div class="docblock"><p>Return an iterator that escapes each char in <code>self</code> with <a href="primitive.char.html#method.escape_unicode" title="method char::escape_unicode"><code>char::escape_unicode</code></a>.</p>
<h5 id="examples-64"><a class="doc-anchor" href="#examples-64">Â§</a>Examples</h5>
<p>As an iterator:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">for </span>c <span class="kw">in </span><span class="string">"â¤\n!"</span>.escape_unicode() {
    <span class="macro">print!</span>(<span class="string">"{c}"</span>);
}
<span class="macro">println!</span>();</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++for+c+in+%22%E2%9D%A4%5Cn!%22.escape_unicode()+%7B%0A++++++++print!(%22%7Bc%7D%22);%0A++++%7D%0A++++println!();%0A%7D&amp;edition=2021">Run</a></div>
<p>Using <code>println!</code> directly:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">"{}"</span>, <span class="string">"â¤\n!"</span>.escape_unicode());</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++println!(%22%7B%7D%22,+%22%E2%9D%A4%5Cn!%22.escape_unicode());%0A%7D&amp;edition=2021">Run</a></div>
<p>Both are equivalent to:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">"\\u{{2764}}\\u{{a}}\\u{{21}}"</span>);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++println!(%22%5C%5Cu%7B%7B2764%7D%7D%5C%5Cu%7B%7Ba%7D%7D%5C%5Cu%7B%7B21%7D%7D%22);%0A%7D&amp;edition=2021">Run</a></div>
<p>Using <code>to_string</code>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(<span class="string">"â¤\n!"</span>.escape_unicode().to_string(), <span class="string">"\\u{2764}\\u{a}\\u{21}"</span>);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++assert_eq!(%22%E2%9D%A4%5Cn!%22.escape_unicode().to_string(),+%22%5C%5Cu%7B2764%7D%5C%5Cu%7Ba%7D%5C%5Cu%7B21%7D%22);%0A%7D&amp;edition=2021">Run</a></div>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-str-1" class="impl"><a class="src rightside" href="../src/alloc/str.rs.html#223">source</a><a href="#impl-str-1" class="anchor">Â§</a><h3 class="code-header">impl <a class="primitive" href="primitive.str.html">str</a></h3></section></summary><div class="docblock"><p>Methods for string slices.</p>
</div><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.into_boxed_bytes" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.20.0">1.20.0</span> Â· <a class="src" href="../src/alloc/str.rs.html#238">source</a></span><h4 class="code-header">pub fn <a href="#method.into_boxed_bytes" class="fn">into_boxed_bytes</a>(self: <a class="struct" href="boxed/struct.Box.html" title="struct std::boxed::Box">Box</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt;) -&gt; <a class="struct" href="boxed/struct.Box.html" title="struct std::boxed::Box">Box</a>&lt;[<a class="primitive" href="primitive.u8.html">u8</a>]&gt;</h4></section></summary><div class="docblock"><p>Converts a <code>Box&lt;str&gt;</code> into a <code>Box&lt;[u8]&gt;</code> without copying or allocating.</p>
<h5 id="examples-65"><a class="doc-anchor" href="#examples-65">Â§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>s = <span class="string">"this is a string"</span>;
<span class="kw">let </span>boxed_str = s.to_owned().into_boxed_str();
<span class="kw">let </span>boxed_bytes = boxed_str.into_boxed_bytes();
<span class="macro">assert_eq!</span>(<span class="kw-2">*</span>boxed_bytes, <span class="kw-2">*</span>s.as_bytes());</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+s+=+%22this+is+a+string%22;%0A++++let+boxed_str+=+s.to_owned().into_boxed_str();%0A++++let+boxed_bytes+=+boxed_str.into_boxed_bytes();%0A++++assert_eq!(*boxed_bytes,+*s.as_bytes());%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.replace" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="../src/alloc/str.rs.html#271">source</a></span><h4 class="code-header">pub fn <a href="#method.replace" class="fn">replace</a>&lt;'a, P&gt;(&amp;'a self, from: P, to: &amp;<a class="primitive" href="primitive.str.html">str</a>) -&gt; <a class="struct" href="string/struct.String.html" title="struct std::string::String">String</a><div class="where">where
    P: <a class="trait" href="str/pattern/trait.Pattern.html" title="trait std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,</div></h4></section></summary><div class="docblock"><p>Replaces all matches of a pattern with another string.</p>
<p><code>replace</code> creates a new <a href="string/struct.String.html" title="struct std::string::String"><code>String</code></a>, and copies the data from this string slice into it.
While doing so, it attempts to find matches of a pattern. If it finds any, it
replaces them with the replacement string slice.</p>
<h5 id="examples-66"><a class="doc-anchor" href="#examples-66">Â§</a>Examples</h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>s = <span class="string">"this is old"</span>;

<span class="macro">assert_eq!</span>(<span class="string">"this is new"</span>, s.replace(<span class="string">"old"</span>, <span class="string">"new"</span>));
<span class="macro">assert_eq!</span>(<span class="string">"than an old"</span>, s.replace(<span class="string">"is"</span>, <span class="string">"an"</span>));</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+s+=+%22this+is+old%22;%0A++++%0A++++assert_eq!(%22this+is+new%22,+s.replace(%22old%22,+%22new%22));%0A++++assert_eq!(%22than+an+old%22,+s.replace(%22is%22,+%22an%22));%0A%7D&amp;edition=2021">Run</a></div>
<p>When the pattern doesnâ€™t match, it returns this string slice as <a href="string/struct.String.html" title="struct std::string::String"><code>String</code></a>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>s = <span class="string">"this is old"</span>;
<span class="macro">assert_eq!</span>(s, s.replace(<span class="string">"cookie monster"</span>, <span class="string">"little lamb"</span>));</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+s+=+%22this+is+old%22;%0A++++assert_eq!(s,+s.replace(%22cookie+monster%22,+%22little+lamb%22));%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.replacen" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.16.0">1.16.0</span> Â· <a class="src" href="../src/alloc/str.rs.html#311">source</a></span><h4 class="code-header">pub fn <a href="#method.replacen" class="fn">replacen</a>&lt;'a, P&gt;(&amp;'a self, pat: P, to: &amp;<a class="primitive" href="primitive.str.html">str</a>, count: <a class="primitive" href="primitive.usize.html">usize</a>) -&gt; <a class="struct" href="string/struct.String.html" title="struct std::string::String">String</a><div class="where">where
    P: <a class="trait" href="str/pattern/trait.Pattern.html" title="trait std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,</div></h4></section></summary><div class="docblock"><p>Replaces first N matches of a pattern with another string.</p>
<p><code>replacen</code> creates a new <a href="string/struct.String.html" title="struct std::string::String"><code>String</code></a>, and copies the data from this string slice into it.
While doing so, it attempts to find matches of a pattern. If it finds any, it
replaces them with the replacement string slice at most <code>count</code> times.</p>
<h5 id="examples-67"><a class="doc-anchor" href="#examples-67">Â§</a>Examples</h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>s = <span class="string">"foo foo 123 foo"</span>;
<span class="macro">assert_eq!</span>(<span class="string">"new new 123 foo"</span>, s.replacen(<span class="string">"foo"</span>, <span class="string">"new"</span>, <span class="number">2</span>));
<span class="macro">assert_eq!</span>(<span class="string">"faa fao 123 foo"</span>, s.replacen(<span class="string">'o'</span>, <span class="string">"a"</span>, <span class="number">3</span>));
<span class="macro">assert_eq!</span>(<span class="string">"foo foo new23 foo"</span>, s.replacen(char::is_numeric, <span class="string">"new"</span>, <span class="number">1</span>));</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+s+=+%22foo+foo+123+foo%22;%0A++++assert_eq!(%22new+new+123+foo%22,+s.replacen(%22foo%22,+%22new%22,+2));%0A++++assert_eq!(%22faa+fao+123+foo%22,+s.replacen('o',+%22a%22,+3));%0A++++assert_eq!(%22foo+foo+new23+foo%22,+s.replacen(char::is_numeric,+%22new%22,+1));%0A%7D&amp;edition=2021">Run</a></div>
<p>When the pattern doesnâ€™t match, it returns this string slice as <a href="string/struct.String.html" title="struct std::string::String"><code>String</code></a>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>s = <span class="string">"this is old"</span>;
<span class="macro">assert_eq!</span>(s, s.replacen(<span class="string">"cookie monster"</span>, <span class="string">"little lamb"</span>, <span class="number">10</span>));</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+s+=+%22this+is+old%22;%0A++++assert_eq!(s,+s.replacen(%22cookie+monster%22,+%22little+lamb%22,+10));%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.to_lowercase" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.2.0">1.2.0</span> Â· <a class="src" href="../src/alloc/str.rs.html#368">source</a></span><h4 class="code-header">pub fn <a href="#method.to_lowercase" class="fn">to_lowercase</a>(&amp;self) -&gt; <a class="struct" href="string/struct.String.html" title="struct std::string::String">String</a></h4></section></summary><div class="docblock"><p>Returns the lowercase equivalent of this string slice, as a new <a href="string/struct.String.html" title="struct std::string::String"><code>String</code></a>.</p>
<p>â€˜Lowercaseâ€™ is defined according to the terms of the Unicode Derived Core Property
<code>Lowercase</code>.</p>
<p>Since some characters can expand into multiple characters when changing
the case, this function returns a <a href="string/struct.String.html" title="struct std::string::String"><code>String</code></a> instead of modifying the
parameter in-place.</p>
<h5 id="examples-68"><a class="doc-anchor" href="#examples-68">Â§</a>Examples</h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>s = <span class="string">"HELLO"</span>;

<span class="macro">assert_eq!</span>(<span class="string">"hello"</span>, s.to_lowercase());</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+s+=+%22HELLO%22;%0A++++%0A++++assert_eq!(%22hello%22,+s.to_lowercase());%0A%7D&amp;edition=2021">Run</a></div>
<p>A tricky example, with sigma:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>sigma = <span class="string">"Î£"</span>;

<span class="macro">assert_eq!</span>(<span class="string">"Ïƒ"</span>, sigma.to_lowercase());

<span class="comment">// but at the end of a word, it's Ï‚, not Ïƒ:
</span><span class="kw">let </span>odysseus = <span class="string">"á½ˆÎ”Î¥Î£Î£Î•ÎÎ£"</span>;

<span class="macro">assert_eq!</span>(<span class="string">"á½€Î´Ï…ÏƒÏƒÎµÏÏ‚"</span>, odysseus.to_lowercase());</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+sigma+=+%22%CE%A3%22;%0A++++%0A++++assert_eq!(%22%CF%83%22,+sigma.to_lowercase());%0A++++%0A++++//+but+at+the+end+of+a+word,+it's+%CF%82,+not+%CF%83:%0A++++let+odysseus+=+%22%E1%BD%88%CE%94%CE%A5%CE%A3%CE%A3%CE%95%CE%8E%CE%A3%22;%0A++++%0A++++assert_eq!(%22%E1%BD%80%CE%B4%CF%85%CF%83%CF%83%CE%B5%CF%8D%CF%82%22,+odysseus.to_lowercase());%0A%7D&amp;edition=2021">Run</a></div>
<p>Languages without case are not changed:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>new_year = <span class="string">"å†œå†æ–°å¹´"</span>;

<span class="macro">assert_eq!</span>(new_year, new_year.to_lowercase());</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+new_year+=+%22%E5%86%9C%E5%8E%86%E6%96%B0%E5%B9%B4%22;%0A++++%0A++++assert_eq!(new_year,+new_year.to_lowercase());%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.to_uppercase" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.2.0">1.2.0</span> Â· <a class="src" href="../src/alloc/str.rs.html#461">source</a></span><h4 class="code-header">pub fn <a href="#method.to_uppercase" class="fn">to_uppercase</a>(&amp;self) -&gt; <a class="struct" href="string/struct.String.html" title="struct std::string::String">String</a></h4></section></summary><div class="docblock"><p>Returns the uppercase equivalent of this string slice, as a new <a href="string/struct.String.html" title="struct std::string::String"><code>String</code></a>.</p>
<p>â€˜Uppercaseâ€™ is defined according to the terms of the Unicode Derived Core Property
<code>Uppercase</code>.</p>
<p>Since some characters can expand into multiple characters when changing
the case, this function returns a <a href="string/struct.String.html" title="struct std::string::String"><code>String</code></a> instead of modifying the
parameter in-place.</p>
<h5 id="examples-69"><a class="doc-anchor" href="#examples-69">Â§</a>Examples</h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>s = <span class="string">"hello"</span>;

<span class="macro">assert_eq!</span>(<span class="string">"HELLO"</span>, s.to_uppercase());</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+s+=+%22hello%22;%0A++++%0A++++assert_eq!(%22HELLO%22,+s.to_uppercase());%0A%7D&amp;edition=2021">Run</a></div>
<p>Scripts without case are not changed:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>new_year = <span class="string">"å†œå†æ–°å¹´"</span>;

<span class="macro">assert_eq!</span>(new_year, new_year.to_uppercase());</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+new_year+=+%22%E5%86%9C%E5%8E%86%E6%96%B0%E5%B9%B4%22;%0A++++%0A++++assert_eq!(new_year,+new_year.to_uppercase());%0A%7D&amp;edition=2021">Run</a></div>
<p>One character can become multiple:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>s = <span class="string">"tschÃ¼ÃŸ"</span>;

<span class="macro">assert_eq!</span>(<span class="string">"TSCHÃœSS"</span>, s.to_uppercase());</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+s+=+%22tsch%C3%BC%C3%9F%22;%0A++++%0A++++assert_eq!(%22TSCH%C3%9CSS%22,+s.to_uppercase());%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.into_string" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.4.0">1.4.0</span> Â· <a class="src" href="../src/alloc/str.rs.html#502">source</a></span><h4 class="code-header">pub fn <a href="#method.into_string" class="fn">into_string</a>(self: <a class="struct" href="boxed/struct.Box.html" title="struct std::boxed::Box">Box</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt;) -&gt; <a class="struct" href="string/struct.String.html" title="struct std::string::String">String</a></h4></section></summary><div class="docblock"><p>Converts a <a href="boxed/struct.Box.html" title="struct std::boxed::Box"><code>Box&lt;str&gt;</code></a> into a <a href="string/struct.String.html" title="struct std::string::String"><code>String</code></a> without copying or allocating.</p>
<h5 id="examples-70"><a class="doc-anchor" href="#examples-70">Â§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>string = String::from(<span class="string">"birthday gift"</span>);
<span class="kw">let </span>boxed_str = string.clone().into_boxed_str();

<span class="macro">assert_eq!</span>(boxed_str.into_string(), string);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+string+=+String::from(%22birthday+gift%22);%0A++++let+boxed_str+=+string.clone().into_boxed_str();%0A++++%0A++++assert_eq!(boxed_str.into_string(),+string);%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.repeat" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.16.0">1.16.0</span> Â· <a class="src" href="../src/alloc/str.rs.html#531">source</a></span><h4 class="code-header">pub fn <a href="#method.repeat" class="fn">repeat</a>(&amp;self, n: <a class="primitive" href="primitive.usize.html">usize</a>) -&gt; <a class="struct" href="string/struct.String.html" title="struct std::string::String">String</a></h4></section></summary><div class="docblock"><p>Creates a new <a href="string/struct.String.html" title="struct std::string::String"><code>String</code></a> by repeating a string <code>n</code> times.</p>
<h5 id="panics-2"><a class="doc-anchor" href="#panics-2">Â§</a>Panics</h5>
<p>This function will panic if the capacity would overflow.</p>
<h5 id="examples-71"><a class="doc-anchor" href="#examples-71">Â§</a>Examples</h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(<span class="string">"abc"</span>.repeat(<span class="number">4</span>), String::from(<span class="string">"abcabcabcabc"</span>));</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++assert_eq!(%22abc%22.repeat(4),+String::from(%22abcabcabcabc%22));%0A%7D&amp;edition=2021">Run</a></div>
<p>A panic upon overflow:</p>

<div class="example-wrap should_panic"><a href="#" class="tooltip" title="This example panics">â“˜</a><pre class="rust rust-example-rendered"><code><span class="comment">// this will panic at runtime
</span><span class="kw">let </span>huge = <span class="string">"0123456789abcdef"</span>.repeat(usize::MAX);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A//+this+will+panic+at+runtime%0Afn+main()+%7B%0A++++let+huge+=+%220123456789abcdef%22.repeat(usize::MAX);%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.to_ascii_uppercase" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.23.0">1.23.0</span> Â· <a class="src" href="../src/alloc/str.rs.html#561">source</a></span><h4 class="code-header">pub fn <a href="#method.to_ascii_uppercase" class="fn">to_ascii_uppercase</a>(&amp;self) -&gt; <a class="struct" href="string/struct.String.html" title="struct std::string::String">String</a></h4></section></summary><div class="docblock"><p>Returns a copy of this string where each character is mapped to its
ASCII upper case equivalent.</p>
<p>ASCII letters â€˜aâ€™ to â€˜zâ€™ are mapped to â€˜Aâ€™ to â€˜Zâ€™,
but non-ASCII letters are unchanged.</p>
<p>To uppercase the value in-place, use <a href="primitive.str.html#method.make_ascii_uppercase" title="method str::make_ascii_uppercase"><code>make_ascii_uppercase</code></a>.</p>
<p>To uppercase ASCII characters in addition to non-ASCII characters, use
<a href="#method.to_uppercase"><code>to_uppercase</code></a>.</p>
<h5 id="examples-72"><a class="doc-anchor" href="#examples-72">Â§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>s = <span class="string">"GrÃ¼ÃŸe, JÃ¼rgen â¤"</span>;

<span class="macro">assert_eq!</span>(<span class="string">"GRÃ¼ÃŸE, JÃ¼RGEN â¤"</span>, s.to_ascii_uppercase());</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+s+=+%22Gr%C3%BC%C3%9Fe,+J%C3%BCrgen+%E2%9D%A4%22;%0A++++%0A++++assert_eq!(%22GR%C3%BC%C3%9FE,+J%C3%BCRGEN+%E2%9D%A4%22,+s.to_ascii_uppercase());%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.to_ascii_lowercase" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.23.0">1.23.0</span> Â· <a class="src" href="../src/alloc/str.rs.html#593">source</a></span><h4 class="code-header">pub fn <a href="#method.to_ascii_lowercase" class="fn">to_ascii_lowercase</a>(&amp;self) -&gt; <a class="struct" href="string/struct.String.html" title="struct std::string::String">String</a></h4></section></summary><div class="docblock"><p>Returns a copy of this string where each character is mapped to its
ASCII lower case equivalent.</p>
<p>ASCII letters â€˜Aâ€™ to â€˜Zâ€™ are mapped to â€˜aâ€™ to â€˜zâ€™,
but non-ASCII letters are unchanged.</p>
<p>To lowercase the value in-place, use <a href="primitive.str.html#method.make_ascii_lowercase" title="method str::make_ascii_lowercase"><code>make_ascii_lowercase</code></a>.</p>
<p>To lowercase ASCII characters in addition to non-ASCII characters, use
<a href="#method.to_lowercase"><code>to_lowercase</code></a>.</p>
<h5 id="examples-73"><a class="doc-anchor" href="#examples-73">Â§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>s = <span class="string">"GrÃ¼ÃŸe, JÃ¼rgen â¤"</span>;

<span class="macro">assert_eq!</span>(<span class="string">"grÃ¼ÃŸe, jÃ¼rgen â¤"</span>, s.to_ascii_lowercase());</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+s+=+%22Gr%C3%BC%C3%9Fe,+J%C3%BCrgen+%E2%9D%A4%22;%0A++++%0A++++assert_eq!(%22gr%C3%BC%C3%9Fe,+j%C3%BCrgen+%E2%9D%A4%22,+s.to_ascii_lowercase());%0A%7D&amp;edition=2021">Run</a></div>
</div></details></div></details></div><h2 id="trait-implementations" class="section-header">Trait Implementations<a href="#trait-implementations" class="anchor">Â§</a></h2><div id="trait-implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-Add%3C%26str%3E-for-Cow%3C'a,+str%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.14.0">1.14.0</span> Â· <a class="src" href="../src/alloc/borrow.rs.html#443">source</a></span><a href="#impl-Add%3C%26str%3E-for-Cow%3C'a,+str%3E" class="anchor">Â§</a><h3 class="code-header">impl&lt;'a&gt; <a class="trait" href="ops/trait.Add.html" title="trait std::ops::Add">Add</a>&lt;&amp;'a <a class="primitive" href="primitive.str.html">str</a>&gt; for <a class="enum" href="borrow/enum.Cow.html" title="enum std::borrow::Cow">Cow</a>&lt;'a, <a class="primitive" href="primitive.str.html">str</a>&gt;</h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Output-8" class="associatedtype trait-impl"><a href="#associatedtype.Output-8" class="anchor">Â§</a><h4 class="code-header">type <a href="ops/trait.Add.html#associatedtype.Output" class="associatedtype">Output</a> = <a class="enum" href="borrow/enum.Cow.html" title="enum std::borrow::Cow">Cow</a>&lt;'a, <a class="primitive" href="primitive.str.html">str</a>&gt;</h4></section></summary><div class='docblock'>The resulting type after applying the <code>+</code> operator.</div></details><details class="toggle method-toggle" open><summary><section id="method.add" class="method trait-impl"><a class="src rightside" href="../src/alloc/borrow.rs.html#447">source</a><a href="#method.add" class="anchor">Â§</a><h4 class="code-header">fn <a href="ops/trait.Add.html#tymethod.add" class="fn">add</a>(self, rhs: &amp;'a <a class="primitive" href="primitive.str.html">str</a>) -&gt; &lt;<a class="enum" href="borrow/enum.Cow.html" title="enum std::borrow::Cow">Cow</a>&lt;'a, <a class="primitive" href="primitive.str.html">str</a>&gt; as <a class="trait" href="ops/trait.Add.html" title="trait std::ops::Add">Add</a>&lt;&amp;'a <a class="primitive" href="primitive.str.html">str</a>&gt;&gt;::<a class="associatedtype" href="ops/trait.Add.html#associatedtype.Output" title="type std::ops::Add::Output">Output</a></h4></section></summary><div class='docblock'>Performs the <code>+</code> operation. <a href="ops/trait.Add.html#tymethod.add">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Add%3C%26str%3E-for-String" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="../src/alloc/string.rs.html#2432">source</a></span><a href="#impl-Add%3C%26str%3E-for-String" class="anchor">Â§</a><h3 class="code-header">impl <a class="trait" href="ops/trait.Add.html" title="trait std::ops::Add">Add</a>&lt;&amp;<a class="primitive" href="primitive.str.html">str</a>&gt; for <a class="struct" href="string/struct.String.html" title="struct std::string::String">String</a></h3></section></summary><div class="docblock"><p>Implements the <code>+</code> operator for concatenating two strings.</p>
<p>This consumes the <code>String</code> on the left-hand side and re-uses its buffer (growing it if
necessary). This is done to avoid allocating a new <code>String</code> and copying the entire contents on
every operation, which would lead to <em>O</em>(<em>n</em>^2) running time when building an <em>n</em>-byte string by
repeated concatenation.</p>
<p>The string on the right-hand side is only borrowed; its contents are copied into the returned
<code>String</code>.</p>
<h4 id="examples-76"><a class="doc-anchor" href="#examples-76">Â§</a>Examples</h4>
<p>Concatenating two <code>String</code>s takes the first by value and borrows the second:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>a = String::from(<span class="string">"hello"</span>);
<span class="kw">let </span>b = String::from(<span class="string">" world"</span>);
<span class="kw">let </span>c = a + <span class="kw-2">&amp;</span>b;
<span class="comment">// `a` is moved and can no longer be used here.</span></code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+a+=+String::from(%22hello%22);%0A++++let+b+=+String::from(%22+world%22);%0A++++let+c+=+a+%2B+%26b;%0A++++//+%60a%60+is+moved+and+can+no+longer+be+used+here.%0A%7D&amp;edition=2021">Run</a></div>
<p>If you want to keep using the first <code>String</code>, you can clone it and append to the clone instead:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>a = String::from(<span class="string">"hello"</span>);
<span class="kw">let </span>b = String::from(<span class="string">" world"</span>);
<span class="kw">let </span>c = a.clone() + <span class="kw-2">&amp;</span>b;
<span class="comment">// `a` is still valid here.</span></code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+a+=+String::from(%22hello%22);%0A++++let+b+=+String::from(%22+world%22);%0A++++let+c+=+a.clone()+%2B+%26b;%0A++++//+%60a%60+is+still+valid+here.%0A%7D&amp;edition=2021">Run</a></div>
<p>Concatenating <code>&amp;str</code> slices can be done by converting the first to a <code>String</code>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>a = <span class="string">"hello"</span>;
<span class="kw">let </span>b = <span class="string">" world"</span>;
<span class="kw">let </span>c = a.to_string() + b;</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+a+=+%22hello%22;%0A++++let+b+=+%22+world%22;%0A++++let+c+=+a.to_string()+%2B+b;%0A%7D&amp;edition=2021">Run</a></div>
</div><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Output-9" class="associatedtype trait-impl"><a href="#associatedtype.Output-9" class="anchor">Â§</a><h4 class="code-header">type <a href="ops/trait.Add.html#associatedtype.Output" class="associatedtype">Output</a> = <a class="struct" href="string/struct.String.html" title="struct std::string::String">String</a></h4></section></summary><div class='docblock'>The resulting type after applying the <code>+</code> operator.</div></details><details class="toggle method-toggle" open><summary><section id="method.add-1" class="method trait-impl"><a class="src rightside" href="../src/alloc/string.rs.html#2436">source</a><a href="#method.add-1" class="anchor">Â§</a><h4 class="code-header">fn <a href="ops/trait.Add.html#tymethod.add" class="fn">add</a>(self, other: &amp;<a class="primitive" href="primitive.str.html">str</a>) -&gt; <a class="struct" href="string/struct.String.html" title="struct std::string::String">String</a></h4></section></summary><div class='docblock'>Performs the <code>+</code> operation. <a href="ops/trait.Add.html#tymethod.add">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-AddAssign%3C%26str%3E-for-Cow%3C'a,+str%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.14.0">1.14.0</span> Â· <a class="src" href="../src/alloc/borrow.rs.html#467">source</a></span><a href="#impl-AddAssign%3C%26str%3E-for-Cow%3C'a,+str%3E" class="anchor">Â§</a><h3 class="code-header">impl&lt;'a&gt; <a class="trait" href="ops/trait.AddAssign.html" title="trait std::ops::AddAssign">AddAssign</a>&lt;&amp;'a <a class="primitive" href="primitive.str.html">str</a>&gt; for <a class="enum" href="borrow/enum.Cow.html" title="enum std::borrow::Cow">Cow</a>&lt;'a, <a class="primitive" href="primitive.str.html">str</a>&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.add_assign" class="method trait-impl"><a class="src rightside" href="../src/alloc/borrow.rs.html#468">source</a><a href="#method.add_assign" class="anchor">Â§</a><h4 class="code-header">fn <a href="ops/trait.AddAssign.html#tymethod.add_assign" class="fn">add_assign</a>(&amp;mut self, rhs: &amp;'a <a class="primitive" href="primitive.str.html">str</a>)</h4></section></summary><div class='docblock'>Performs the <code>+=</code> operation. <a href="ops/trait.AddAssign.html#tymethod.add_assign">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-AddAssign%3C%26str%3E-for-String" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.12.0">1.12.0</span> Â· <a class="src" href="../src/alloc/string.rs.html#2447">source</a></span><a href="#impl-AddAssign%3C%26str%3E-for-String" class="anchor">Â§</a><h3 class="code-header">impl <a class="trait" href="ops/trait.AddAssign.html" title="trait std::ops::AddAssign">AddAssign</a>&lt;&amp;<a class="primitive" href="primitive.str.html">str</a>&gt; for <a class="struct" href="string/struct.String.html" title="struct std::string::String">String</a></h3></section></summary><div class="docblock"><p>Implements the <code>+=</code> operator for appending to a <code>String</code>.</p>
<p>This has the same behavior as the <a href="string/struct.String.html#method.push_str" title="method std::string::String::push_str"><code>push_str</code></a> method.</p>
</div><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.add_assign-1" class="method trait-impl"><a class="src rightside" href="../src/alloc/string.rs.html#2449">source</a><a href="#method.add_assign-1" class="anchor">Â§</a><h4 class="code-header">fn <a href="ops/trait.AddAssign.html#tymethod.add_assign" class="fn">add_assign</a>(&amp;mut self, other: &amp;<a class="primitive" href="primitive.str.html">str</a>)</h4></section></summary><div class='docblock'>Performs the <code>+=</code> operation. <a href="ops/trait.AddAssign.html#tymethod.add_assign">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-AsMut%3Cstr%3E-for-String" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.43.0">1.43.0</span> Â· <a class="src" href="../src/alloc/string.rs.html#2692">source</a></span><a href="#impl-AsMut%3Cstr%3E-for-String" class="anchor">Â§</a><h3 class="code-header">impl <a class="trait" href="convert/trait.AsMut.html" title="trait std::convert::AsMut">AsMut</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt; for <a class="struct" href="string/struct.String.html" title="struct std::string::String">String</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.as_mut-1" class="method trait-impl"><a class="src rightside" href="../src/alloc/string.rs.html#2694">source</a><a href="#method.as_mut-1" class="anchor">Â§</a><h4 class="code-header">fn <a href="convert/trait.AsMut.html#tymethod.as_mut" class="fn">as_mut</a>(&amp;mut self) -&gt; &amp;mut <a class="primitive" href="primitive.str.html">str</a></h4></section></summary><div class='docblock'>Converts this type into a mutable reference of the (usually inferred) input type.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-AsMut%3Cstr%3E-for-str" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.51.0">1.51.0</span> Â· <a class="src" href="https://doc.rust-lang.org/1.80.1/src/core/convert/mod.rs.html#846">source</a></span><a href="#impl-AsMut%3Cstr%3E-for-str" class="anchor">Â§</a><h3 class="code-header">impl <a class="trait" href="convert/trait.AsMut.html" title="trait std::convert::AsMut">AsMut</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt; for <a class="primitive" href="primitive.str.html">str</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.as_mut" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/convert/mod.rs.html#848">source</a><a href="#method.as_mut" class="anchor">Â§</a><h4 class="code-header">fn <a href="convert/trait.AsMut.html#tymethod.as_mut" class="fn">as_mut</a>(&amp;mut self) -&gt; &amp;mut <a class="primitive" href="primitive.str.html">str</a></h4></section></summary><div class='docblock'>Converts this type into a mutable reference of the (usually inferred) input type.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-AsRef%3C%5Bu8%5D%3E-for-str" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="https://doc.rust-lang.org/1.80.1/src/core/str/mod.rs.html#2741">source</a></span><a href="#impl-AsRef%3C%5Bu8%5D%3E-for-str" class="anchor">Â§</a><h3 class="code-header">impl <a class="trait" href="convert/trait.AsRef.html" title="trait std::convert::AsRef">AsRef</a>&lt;[<a class="primitive" href="primitive.u8.html">u8</a>]&gt; for <a class="primitive" href="primitive.str.html">str</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.as_ref" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/str/mod.rs.html#2743">source</a><a href="#method.as_ref" class="anchor">Â§</a><h4 class="code-header">fn <a href="convert/trait.AsRef.html#tymethod.as_ref" class="fn">as_ref</a>(&amp;self) -&gt; &amp;[<a class="primitive" href="primitive.u8.html">u8</a>] <a href="#" class="tooltip" data-notable-ty="&amp;[u8]">â“˜</a></h4></section></summary><div class='docblock'>Converts this type into a shared reference of the (usually inferred) input type.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-AsRef%3COsStr%3E-for-str" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="../src/std/ffi/os_str.rs.html#1576-1581">source</a></span><a href="#impl-AsRef%3COsStr%3E-for-str" class="anchor">Â§</a><h3 class="code-header">impl <a class="trait" href="convert/trait.AsRef.html" title="trait std::convert::AsRef">AsRef</a>&lt;<a class="struct" href="ffi/struct.OsStr.html" title="struct std::ffi::OsStr">OsStr</a>&gt; for <a class="primitive" href="primitive.str.html">str</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.as_ref-4" class="method trait-impl"><a class="src rightside" href="../src/std/ffi/os_str.rs.html#1578-1580">source</a><a href="#method.as_ref-4" class="anchor">Â§</a><h4 class="code-header">fn <a href="convert/trait.AsRef.html#tymethod.as_ref" class="fn">as_ref</a>(&amp;self) -&gt; &amp;<a class="struct" href="ffi/struct.OsStr.html" title="struct std::ffi::OsStr">OsStr</a></h4></section></summary><div class='docblock'>Converts this type into a shared reference of the (usually inferred) input type.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-AsRef%3CPath%3E-for-str" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="../src/std/path.rs.html#3174-3179">source</a></span><a href="#impl-AsRef%3CPath%3E-for-str" class="anchor">Â§</a><h3 class="code-header">impl <a class="trait" href="convert/trait.AsRef.html" title="trait std::convert::AsRef">AsRef</a>&lt;<a class="struct" href="path/struct.Path.html" title="struct std::path::Path">Path</a>&gt; for <a class="primitive" href="primitive.str.html">str</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.as_ref-5" class="method trait-impl"><a class="src rightside" href="../src/std/path.rs.html#3176-3178">source</a><a href="#method.as_ref-5" class="anchor">Â§</a><h4 class="code-header">fn <a href="convert/trait.AsRef.html#tymethod.as_ref" class="fn">as_ref</a>(&amp;self) -&gt; &amp;<a class="struct" href="path/struct.Path.html" title="struct std::path::Path">Path</a></h4></section></summary><div class='docblock'>Converts this type into a shared reference of the (usually inferred) input type.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-AsRef%3Cstr%3E-for-Drain%3C'a%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.55.0">1.55.0</span> Â· <a class="src" href="../src/alloc/string.rs.html#2996">source</a></span><a href="#impl-AsRef%3Cstr%3E-for-Drain%3C'a%3E" class="anchor">Â§</a><h3 class="code-header">impl&lt;'a&gt; <a class="trait" href="convert/trait.AsRef.html" title="trait std::convert::AsRef">AsRef</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt; for <a class="struct" href="string/struct.Drain.html" title="struct std::string::Drain">Drain</a>&lt;'a&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.as_ref-2" class="method trait-impl"><a class="src rightside" href="../src/alloc/string.rs.html#2997">source</a><a href="#method.as_ref-2" class="anchor">Â§</a><h4 class="code-header">fn <a href="convert/trait.AsRef.html#tymethod.as_ref" class="fn">as_ref</a>(&amp;self) -&gt; &amp;<a class="primitive" href="primitive.str.html">str</a></h4></section></summary><div class='docblock'>Converts this type into a shared reference of the (usually inferred) input type.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-AsRef%3Cstr%3E-for-String" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="../src/alloc/string.rs.html#2684">source</a></span><a href="#impl-AsRef%3Cstr%3E-for-String" class="anchor">Â§</a><h3 class="code-header">impl <a class="trait" href="convert/trait.AsRef.html" title="trait std::convert::AsRef">AsRef</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt; for <a class="struct" href="string/struct.String.html" title="struct std::string::String">String</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.as_ref-3" class="method trait-impl"><a class="src rightside" href="../src/alloc/string.rs.html#2686">source</a><a href="#method.as_ref-3" class="anchor">Â§</a><h4 class="code-header">fn <a href="convert/trait.AsRef.html#tymethod.as_ref" class="fn">as_ref</a>(&amp;self) -&gt; &amp;<a class="primitive" href="primitive.str.html">str</a></h4></section></summary><div class='docblock'>Converts this type into a shared reference of the (usually inferred) input type.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-AsRef%3Cstr%3E-for-str" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="https://doc.rust-lang.org/1.80.1/src/core/convert/mod.rs.html#838">source</a></span><a href="#impl-AsRef%3Cstr%3E-for-str" class="anchor">Â§</a><h3 class="code-header">impl <a class="trait" href="convert/trait.AsRef.html" title="trait std::convert::AsRef">AsRef</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt; for <a class="primitive" href="primitive.str.html">str</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.as_ref-1" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/convert/mod.rs.html#840">source</a><a href="#method.as_ref-1" class="anchor">Â§</a><h4 class="code-header">fn <a href="convert/trait.AsRef.html#tymethod.as_ref" class="fn">as_ref</a>(&amp;self) -&gt; &amp;<a class="primitive" href="primitive.str.html">str</a></h4></section></summary><div class='docblock'>Converts this type into a shared reference of the (usually inferred) input type.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-AsciiExt-for-str" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="../src/std/ascii.rs.html#207-211">source</a></span><a href="#impl-AsciiExt-for-str" class="anchor">Â§</a><h3 class="code-header">impl <a class="trait" href="ascii/trait.AsciiExt.html" title="trait std::ascii::AsciiExt">AsciiExt</a> for <a class="primitive" href="primitive.str.html">str</a></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Owned-1" class="associatedtype trait-impl"><a href="#associatedtype.Owned-1" class="anchor">Â§</a><h4 class="code-header">type <a href="ascii/trait.AsciiExt.html#associatedtype.Owned" class="associatedtype">Owned</a> = <a class="struct" href="string/struct.String.html" title="struct std::string::String">String</a></h4></section></summary><span class="item-info"><div class="stab deprecated"><span class="emoji">ğŸ‘</span><span>Deprecated since 1.26.0: use inherent methods instead</span></div></span><div class='docblock'>Container type for copied ASCII characters.</div></details><details class="toggle method-toggle" open><summary><section id="method.is_ascii-1" class="method trait-impl"><a class="src rightside" href="../src/std/ascii.rs.html#210">source</a><a href="#method.is_ascii-1" class="anchor">Â§</a><h4 class="code-header">fn <a href="ascii/trait.AsciiExt.html#tymethod.is_ascii" class="fn">is_ascii</a>(&amp;self) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></section></summary><span class="item-info"><div class="stab deprecated"><span class="emoji">ğŸ‘</span><span>Deprecated since 1.26.0: use inherent methods instead</span></div></span><div class='docblock'>Checks if the value is within the ASCII range. <a href="ascii/trait.AsciiExt.html#tymethod.is_ascii">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.to_ascii_uppercase-1" class="method trait-impl"><a class="src rightside" href="../src/std/ascii.rs.html#210">source</a><a href="#method.to_ascii_uppercase-1" class="anchor">Â§</a><h4 class="code-header">fn <a href="ascii/trait.AsciiExt.html#tymethod.to_ascii_uppercase" class="fn">to_ascii_uppercase</a>(&amp;self) -&gt; Self::<a class="associatedtype" href="ascii/trait.AsciiExt.html#associatedtype.Owned" title="type std::ascii::AsciiExt::Owned">Owned</a></h4></section></summary><span class="item-info"><div class="stab deprecated"><span class="emoji">ğŸ‘</span><span>Deprecated since 1.26.0: use inherent methods instead</span></div></span><div class='docblock'>Makes a copy of the value in its ASCII upper case equivalent. <a href="ascii/trait.AsciiExt.html#tymethod.to_ascii_uppercase">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.to_ascii_lowercase-1" class="method trait-impl"><a class="src rightside" href="../src/std/ascii.rs.html#210">source</a><a href="#method.to_ascii_lowercase-1" class="anchor">Â§</a><h4 class="code-header">fn <a href="ascii/trait.AsciiExt.html#tymethod.to_ascii_lowercase" class="fn">to_ascii_lowercase</a>(&amp;self) -&gt; Self::<a class="associatedtype" href="ascii/trait.AsciiExt.html#associatedtype.Owned" title="type std::ascii::AsciiExt::Owned">Owned</a></h4></section></summary><span class="item-info"><div class="stab deprecated"><span class="emoji">ğŸ‘</span><span>Deprecated since 1.26.0: use inherent methods instead</span></div></span><div class='docblock'>Makes a copy of the value in its ASCII lower case equivalent. <a href="ascii/trait.AsciiExt.html#tymethod.to_ascii_lowercase">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.eq_ignore_ascii_case-1" class="method trait-impl"><a class="src rightside" href="../src/std/ascii.rs.html#210">source</a><a href="#method.eq_ignore_ascii_case-1" class="anchor">Â§</a><h4 class="code-header">fn <a href="ascii/trait.AsciiExt.html#tymethod.eq_ignore_ascii_case" class="fn">eq_ignore_ascii_case</a>(&amp;self, o: <a class="primitive" href="primitive.reference.html">&amp;Self</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></section></summary><span class="item-info"><div class="stab deprecated"><span class="emoji">ğŸ‘</span><span>Deprecated since 1.26.0: use inherent methods instead</span></div></span><div class='docblock'>Checks that two values are an ASCII case-insensitive match. <a href="ascii/trait.AsciiExt.html#tymethod.eq_ignore_ascii_case">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.make_ascii_uppercase-1" class="method trait-impl"><a class="src rightside" href="../src/std/ascii.rs.html#210">source</a><a href="#method.make_ascii_uppercase-1" class="anchor">Â§</a><h4 class="code-header">fn <a href="ascii/trait.AsciiExt.html#tymethod.make_ascii_uppercase" class="fn">make_ascii_uppercase</a>(&amp;mut self)</h4></section></summary><span class="item-info"><div class="stab deprecated"><span class="emoji">ğŸ‘</span><span>Deprecated since 1.26.0: use inherent methods instead</span></div></span><div class='docblock'>Converts this type to its ASCII upper case equivalent in-place. <a href="ascii/trait.AsciiExt.html#tymethod.make_ascii_uppercase">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.make_ascii_lowercase-1" class="method trait-impl"><a class="src rightside" href="../src/std/ascii.rs.html#210">source</a><a href="#method.make_ascii_lowercase-1" class="anchor">Â§</a><h4 class="code-header">fn <a href="ascii/trait.AsciiExt.html#tymethod.make_ascii_lowercase" class="fn">make_ascii_lowercase</a>(&amp;mut self)</h4></section></summary><span class="item-info"><div class="stab deprecated"><span class="emoji">ğŸ‘</span><span>Deprecated since 1.26.0: use inherent methods instead</span></div></span><div class='docblock'>Converts this type to its ASCII lower case equivalent in-place. <a href="ascii/trait.AsciiExt.html#tymethod.make_ascii_lowercase">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Borrow%3Cstr%3E-for-String" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="../src/alloc/str.rs.html#190">source</a></span><a href="#impl-Borrow%3Cstr%3E-for-String" class="anchor">Â§</a><h3 class="code-header">impl <a class="trait" href="borrow/trait.Borrow.html" title="trait std::borrow::Borrow">Borrow</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt; for <a class="struct" href="string/struct.String.html" title="struct std::string::String">String</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow" class="method trait-impl"><a class="src rightside" href="../src/alloc/str.rs.html#192">source</a><a href="#method.borrow" class="anchor">Â§</a><h4 class="code-header">fn <a href="borrow/trait.Borrow.html#tymethod.borrow" class="fn">borrow</a>(&amp;self) -&gt; &amp;<a class="primitive" href="primitive.str.html">str</a></h4></section></summary><div class='docblock'>Immutably borrows from an owned value. <a href="borrow/trait.Borrow.html#tymethod.borrow">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-BorrowMut%3Cstr%3E-for-String" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.36.0">1.36.0</span> Â· <a class="src" href="../src/alloc/str.rs.html#198">source</a></span><a href="#impl-BorrowMut%3Cstr%3E-for-String" class="anchor">Â§</a><h3 class="code-header">impl <a class="trait" href="borrow/trait.BorrowMut.html" title="trait std::borrow::BorrowMut">BorrowMut</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt; for <a class="struct" href="string/struct.String.html" title="struct std::string::String">String</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow_mut" class="method trait-impl"><a class="src rightside" href="../src/alloc/str.rs.html#200">source</a><a href="#method.borrow_mut" class="anchor">Â§</a><h4 class="code-header">fn <a href="borrow/trait.BorrowMut.html#tymethod.borrow_mut" class="fn">borrow_mut</a>(&amp;mut self) -&gt; &amp;mut <a class="primitive" href="primitive.str.html">str</a></h4></section></summary><div class='docblock'>Mutably borrows from an owned value. <a href="borrow/trait.BorrowMut.html#tymethod.borrow_mut">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Clone-for-Box%3Cstr%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.3.0">1.3.0</span> Â· <a class="src" href="../src/alloc/boxed.rs.html#1380">source</a></span><a href="#impl-Clone-for-Box%3Cstr%3E" class="anchor">Â§</a><h3 class="code-header">impl <a class="trait" href="clone/trait.Clone.html" title="trait std::clone::Clone">Clone</a> for <a class="struct" href="boxed/struct.Box.html" title="struct std::boxed::Box">Box</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.clone" class="method trait-impl"><a class="src rightside" href="../src/alloc/boxed.rs.html#1381">source</a><a href="#method.clone" class="anchor">Â§</a><h4 class="code-header">fn <a href="clone/trait.Clone.html#tymethod.clone" class="fn">clone</a>(&amp;self) -&gt; <a class="struct" href="boxed/struct.Box.html" title="struct std::boxed::Box">Box</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt;</h4></section></summary><div class='docblock'>Returns a copy of the value. <a href="clone/trait.Clone.html#tymethod.clone">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.clone_from" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="https://doc.rust-lang.org/1.80.1/src/core/clone.rs.html#169">source</a></span><a href="#method.clone_from" class="anchor">Â§</a><h4 class="code-header">fn <a href="clone/trait.Clone.html#method.clone_from" class="fn">clone_from</a>(&amp;mut self, source: <a class="primitive" href="primitive.reference.html">&amp;Self</a>)</h4></section></summary><div class='docblock'>Performs copy-assignment from <code>source</code>. <a href="clone/trait.Clone.html#method.clone_from">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Concat%3Cstr%3E-for-%5BS%5D" class="impl"><a class="src rightside" href="../src/alloc/str.rs.html#63">source</a><a href="#impl-Concat%3Cstr%3E-for-%5BS%5D" class="anchor">Â§</a><h3 class="code-header">impl&lt;S&gt; <a class="trait" href="slice/trait.Concat.html" title="trait std::slice::Concat">Concat</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt; for <a class="primitive" href="primitive.slice.html">[S]</a><div class="where">where
    S: <a class="trait" href="borrow/trait.Borrow.html" title="trait std::borrow::Borrow">Borrow</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt;,</div></h3></section></summary><div class="docblock"><p>Note: <code>str</code> in <code>Concat&lt;str&gt;</code> is not meaningful here.
This type parameter of the trait only exists to enable another impl.</p>
</div><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Output-11" class="associatedtype trait-impl"><a href="#associatedtype.Output-11" class="anchor">Â§</a><h4 class="code-header">type <a href="slice/trait.Concat.html#associatedtype.Output" class="associatedtype">Output</a> = <a class="struct" href="string/struct.String.html" title="struct std::string::String">String</a></h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>slice_concat_trait</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/27747">#27747</a>)</span></div></span><div class='docblock'>The resulting type after concatenation</div></details><details class="toggle method-toggle" open><summary><section id="method.concat" class="method trait-impl"><a class="src rightside" href="../src/alloc/str.rs.html#66">source</a><a href="#method.concat" class="anchor">Â§</a><h4 class="code-header">fn <a href="slice/trait.Concat.html#tymethod.concat" class="fn">concat</a>(slice: &amp;<a class="primitive" href="primitive.slice.html">[S]</a>) -&gt; <a class="struct" href="string/struct.String.html" title="struct std::string::String">String</a></h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>slice_concat_trait</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/27747">#27747</a>)</span></div></span><div class='docblock'>Implementation of <a href="primitive.slice.html#method.concat" title="method slice::concat"><code>[T]::concat</code></a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Debug-for-str" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="https://doc.rust-lang.org/1.80.1/src/core/fmt/mod.rs.html#2398">source</a></span><a href="#impl-Debug-for-str" class="anchor">Â§</a><h3 class="code-header">impl <a class="trait" href="fmt/trait.Debug.html" title="trait std::fmt::Debug">Debug</a> for <a class="primitive" href="primitive.str.html">str</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.fmt-1" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/fmt/mod.rs.html#2399">source</a><a href="#method.fmt-1" class="anchor">Â§</a><h4 class="code-header">fn <a href="fmt/trait.Debug.html#tymethod.fmt" class="fn">fmt</a>(&amp;self, f: &amp;mut <a class="struct" href="fmt/struct.Formatter.html" title="struct std::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="enum" href="result/enum.Result.html" title="enum std::result::Result">Result</a>&lt;<a class="primitive" href="primitive.unit.html">()</a>, <a class="struct" href="fmt/struct.Error.html" title="struct std::fmt::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Formats the value using the given formatter. <a href="fmt/trait.Debug.html#tymethod.fmt">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Default-for-%26mut+str" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.28.0">1.28.0</span> Â· <a class="src" href="https://doc.rust-lang.org/1.80.1/src/core/str/mod.rs.html#2758">source</a></span><a href="#impl-Default-for-%26mut+str" class="anchor">Â§</a><h3 class="code-header">impl <a class="trait" href="default/trait.Default.html" title="trait std::default::Default">Default</a> for &amp;mut <a class="primitive" href="primitive.str.html">str</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.default-1" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/str/mod.rs.html#2761">source</a><a href="#method.default-1" class="anchor">Â§</a><h4 class="code-header">fn <a href="default/trait.Default.html#tymethod.default" class="fn">default</a>() -&gt; &amp;mut <a class="primitive" href="primitive.str.html">str</a></h4></section></summary><div class="docblock"><p>Creates an empty mutable str</p>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Default-for-%26str" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="https://doc.rust-lang.org/1.80.1/src/core/str/mod.rs.html#2749">source</a></span><a href="#impl-Default-for-%26str" class="anchor">Â§</a><h3 class="code-header">impl <a class="trait" href="default/trait.Default.html" title="trait std::default::Default">Default</a> for &amp;<a class="primitive" href="primitive.str.html">str</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.default" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/str/mod.rs.html#2752">source</a><a href="#method.default" class="anchor">Â§</a><h4 class="code-header">fn <a href="default/trait.Default.html#tymethod.default" class="fn">default</a>() -&gt; &amp;<a class="primitive" href="primitive.str.html">str</a></h4></section></summary><div class="docblock"><p>Creates an empty str</p>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Default-for-Box%3Cstr%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.17.0">1.17.0</span> Â· <a class="src" href="../src/alloc/boxed.rs.html#1316">source</a></span><a href="#impl-Default-for-Box%3Cstr%3E" class="anchor">Â§</a><h3 class="code-header">impl <a class="trait" href="default/trait.Default.html" title="trait std::default::Default">Default</a> for <a class="struct" href="boxed/struct.Box.html" title="struct std::boxed::Box">Box</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.default-2" class="method trait-impl"><a class="src rightside" href="../src/alloc/boxed.rs.html#1318">source</a><a href="#method.default-2" class="anchor">Â§</a><h4 class="code-header">fn <a href="default/trait.Default.html#tymethod.default" class="fn">default</a>() -&gt; <a class="struct" href="boxed/struct.Box.html" title="struct std::boxed::Box">Box</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt;</h4></section></summary><div class='docblock'>Returns the â€œdefault valueâ€ for a type. <a href="default/trait.Default.html#tymethod.default">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Display-for-str" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="https://doc.rust-lang.org/1.80.1/src/core/fmt/mod.rs.html#2447">source</a></span><a href="#impl-Display-for-str" class="anchor">Â§</a><h3 class="code-header">impl <a class="trait" href="fmt/trait.Display.html" title="trait std::fmt::Display">Display</a> for <a class="primitive" href="primitive.str.html">str</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.fmt" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/fmt/mod.rs.html#2448">source</a><a href="#method.fmt" class="anchor">Â§</a><h4 class="code-header">fn <a href="fmt/trait.Display.html#tymethod.fmt" class="fn">fmt</a>(&amp;self, f: &amp;mut <a class="struct" href="fmt/struct.Formatter.html" title="struct std::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="enum" href="result/enum.Result.html" title="enum std::result::Result">Result</a>&lt;<a class="primitive" href="primitive.unit.html">()</a>, <a class="struct" href="fmt/struct.Error.html" title="struct std::fmt::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Formats the value using the given formatter. <a href="fmt/trait.Display.html#tymethod.fmt">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Error-for-%26str" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="https://doc.rust-lang.org/1.80.1/src/core/str/mod.rs.html#2779">source</a></span><a href="#impl-Error-for-%26str" class="anchor">Â§</a><h3 class="code-header">impl !<a class="trait" href="error/trait.Error.html" title="trait std::error::Error">Error</a> for &amp;<a class="primitive" href="primitive.str.html">str</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.source" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.30.0">1.30.0</span> Â· <a class="src" href="https://doc.rust-lang.org/1.80.1/src/core/error.rs.html#84">source</a></span><a href="#method.source" class="anchor">Â§</a><h4 class="code-header">fn <a href="error/trait.Error.html#method.source" class="fn">source</a>(&amp;self) -&gt; <a class="enum" href="option/enum.Option.html" title="enum std::option::Option">Option</a>&lt;&amp;(dyn <a class="trait" href="error/trait.Error.html" title="trait std::error::Error">Error</a> + 'static)&gt;</h4></section></summary><div class='docblock'>The lower-level source of this error, if any. <a href="error/trait.Error.html#method.source">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.description" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="https://doc.rust-lang.org/1.80.1/src/core/error.rs.html#110">source</a></span><a href="#method.description" class="anchor">Â§</a><h4 class="code-header">fn <a href="error/trait.Error.html#method.description" class="fn">description</a>(&amp;self) -&gt; &amp;<a class="primitive" href="primitive.str.html">str</a></h4></section></summary><span class="item-info"><div class="stab deprecated"><span class="emoji">ğŸ‘</span><span>Deprecated since 1.42.0: use the Display impl or to_string()</span></div></span><div class='docblock'> <a href="error/trait.Error.html#method.description">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.cause" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="https://doc.rust-lang.org/1.80.1/src/core/error.rs.html#120">source</a></span><a href="#method.cause" class="anchor">Â§</a><h4 class="code-header">fn <a href="error/trait.Error.html#method.cause" class="fn">cause</a>(&amp;self) -&gt; <a class="enum" href="option/enum.Option.html" title="enum std::option::Option">Option</a>&lt;&amp;dyn <a class="trait" href="error/trait.Error.html" title="trait std::error::Error">Error</a>&gt;</h4></section></summary><span class="item-info"><div class="stab deprecated"><span class="emoji">ğŸ‘</span><span>Deprecated since 1.33.0: replaced by Error::source, which can support downcasting</span></div></span></details><details class="toggle method-toggle" open><summary><section id="method.provide" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/error.rs.html#184">source</a><a href="#method.provide" class="anchor">Â§</a><h4 class="code-header">fn <a href="error/trait.Error.html#method.provide" class="fn">provide</a>&lt;'a&gt;(&amp;'a self, request: &amp;mut <a class="struct" href="error/struct.Request.html" title="struct std::error::Request">Request</a>&lt;'a&gt;)</h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>error_generic_member_access</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/99301">#99301</a>)</span></div></span><div class='docblock'>Provides type based access to context intended for error reports. <a href="error/trait.Error.html#method.provide">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Extend%3C%26str%3E-for-String" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="../src/alloc/string.rs.html#2231">source</a></span><a href="#impl-Extend%3C%26str%3E-for-String" class="anchor">Â§</a><h3 class="code-header">impl&lt;'a&gt; <a class="trait" href="iter/trait.Extend.html" title="trait std::iter::Extend">Extend</a>&lt;&amp;'a <a class="primitive" href="primitive.str.html">str</a>&gt; for <a class="struct" href="string/struct.String.html" title="struct std::string::String">String</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.extend" class="method trait-impl"><a class="src rightside" href="../src/alloc/string.rs.html#2232">source</a><a href="#method.extend" class="anchor">Â§</a><h4 class="code-header">fn <a href="iter/trait.Extend.html#tymethod.extend" class="fn">extend</a>&lt;I&gt;(&amp;mut self, iter: I)<div class="where">where
    I: <a class="trait" href="iter/trait.IntoIterator.html" title="trait std::iter::IntoIterator">IntoIterator</a>&lt;Item = &amp;'a <a class="primitive" href="primitive.str.html">str</a>&gt;,</div></h4></section></summary><div class='docblock'>Extends a collection with the contents of an iterator. <a href="iter/trait.Extend.html#tymethod.extend">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.extend_one" class="method trait-impl"><a class="src rightside" href="../src/alloc/string.rs.html#2237">source</a><a href="#method.extend_one" class="anchor">Â§</a><h4 class="code-header">fn <a href="iter/trait.Extend.html#method.extend_one" class="fn">extend_one</a>(&amp;mut self, s: &amp;'a <a class="primitive" href="primitive.str.html">str</a>)</h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>extend_one</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/72631">#72631</a>)</span></div></span><div class='docblock'>Extends a collection with exactly one element.</div></details><details class="toggle method-toggle" open><summary><section id="method.extend_reserve" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/iter/traits/collect.rs.html#461">source</a><a href="#method.extend_reserve" class="anchor">Â§</a><h4 class="code-header">fn <a href="iter/trait.Extend.html#method.extend_reserve" class="fn">extend_reserve</a>(&amp;mut self, additional: <a class="primitive" href="primitive.usize.html">usize</a>)</h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>extend_one</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/72631">#72631</a>)</span></div></span><div class='docblock'>Reserves capacity in a collection for the given number of additional elements. <a href="iter/trait.Extend.html#method.extend_reserve">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-From%3C%26mut+str%3E-for-String" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.44.0">1.44.0</span> Â· <a class="src" href="../src/alloc/string.rs.html#2721">source</a></span><a href="#impl-From%3C%26mut+str%3E-for-String" class="anchor">Â§</a><h3 class="code-header">impl <a class="trait" href="convert/trait.From.html" title="trait std::convert::From">From</a>&lt;&amp;mut <a class="primitive" href="primitive.str.html">str</a>&gt; for <a class="struct" href="string/struct.String.html" title="struct std::string::String">String</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from-7" class="method trait-impl"><a class="src rightside" href="../src/alloc/string.rs.html#2726">source</a><a href="#method.from-7" class="anchor">Â§</a><h4 class="code-header">fn <a href="convert/trait.From.html#tymethod.from" class="fn">from</a>(s: &amp;mut <a class="primitive" href="primitive.str.html">str</a>) -&gt; <a class="struct" href="string/struct.String.html" title="struct std::string::String">String</a></h4></section></summary><div class="docblock"><p>Converts a <code>&amp;mut str</code> into a <a href="string/struct.String.html" title="struct std::string::String"><code>String</code></a>.</p>
<p>The result is allocated on the heap.</p>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-From%3C%26str%3E-for-Arc%3Cstr%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.21.0">1.21.0</span> Â· <a class="src" href="../src/alloc/sync.rs.html#3539">source</a></span><a href="#impl-From%3C%26str%3E-for-Arc%3Cstr%3E" class="anchor">Â§</a><h3 class="code-header">impl <a class="trait" href="convert/trait.From.html" title="trait std::convert::From">From</a>&lt;&amp;<a class="primitive" href="primitive.str.html">str</a>&gt; for <a class="struct" href="sync/struct.Arc.html" title="struct std::sync::Arc">Arc</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from-6" class="method trait-impl"><a class="src rightside" href="../src/alloc/sync.rs.html#3550">source</a><a href="#method.from-6" class="anchor">Â§</a><h4 class="code-header">fn <a href="convert/trait.From.html#tymethod.from" class="fn">from</a>(v: &amp;<a class="primitive" href="primitive.str.html">str</a>) -&gt; <a class="struct" href="sync/struct.Arc.html" title="struct std::sync::Arc">Arc</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt;</h4></section></summary><div class="docblock"><p>Allocate a reference-counted <code>str</code> and copy <code>v</code> into it.</p>
<h5 id="example-2"><a class="doc-anchor" href="#example-2">Â§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>shared: Arc&lt;str&gt; = Arc::from(<span class="string">"eggplant"</span>);
<span class="macro">assert_eq!</span>(<span class="string">"eggplant"</span>, <span class="kw-2">&amp;</span>shared[..]);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::sync::Arc;%0A++++let+shared:+Arc%3Cstr%3E+=+Arc::from(%22eggplant%22);%0A++++assert_eq!(%22eggplant%22,+%26shared%5B..%5D);%0A%7D&amp;edition=2021">Run</a></div>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-From%3C%26str%3E-for-Box%3Cdyn+Error%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.6.0">1.6.0</span> Â· <a class="src" href="../src/alloc/boxed.rs.html#2559">source</a></span><a href="#impl-From%3C%26str%3E-for-Box%3Cdyn+Error%3E" class="anchor">Â§</a><h3 class="code-header">impl&lt;'a&gt; <a class="trait" href="convert/trait.From.html" title="trait std::convert::From">From</a>&lt;&amp;<a class="primitive" href="primitive.str.html">str</a>&gt; for <a class="struct" href="boxed/struct.Box.html" title="struct std::boxed::Box">Box</a>&lt;dyn <a class="trait" href="error/trait.Error.html" title="trait std::error::Error">Error</a> + 'a&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from" class="method trait-impl"><a class="src rightside" href="../src/alloc/boxed.rs.html#2574">source</a><a href="#method.from" class="anchor">Â§</a><h4 class="code-header">fn <a href="convert/trait.From.html#tymethod.from" class="fn">from</a>(err: &amp;<a class="primitive" href="primitive.str.html">str</a>) -&gt; <a class="struct" href="boxed/struct.Box.html" title="struct std::boxed::Box">Box</a>&lt;dyn <a class="trait" href="error/trait.Error.html" title="trait std::error::Error">Error</a> + 'a&gt;</h4></section></summary><div class="docblock"><p>Converts a <a href="primitive.str.html" title="primitive str"><code>str</code></a> into a box of dyn <a href="error/trait.Error.html" title="trait std::error::Error"><code>Error</code></a>.</p>
<h5 id="examples-77"><a class="doc-anchor" href="#examples-77">Â§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::error::Error;
<span class="kw">use </span>std::mem;

<span class="kw">let </span>a_str_error = <span class="string">"a str error"</span>;
<span class="kw">let </span>a_boxed_error = Box::&lt;<span class="kw">dyn </span>Error&gt;::from(a_str_error);
<span class="macro">assert!</span>(mem::size_of::&lt;Box&lt;<span class="kw">dyn </span>Error&gt;&gt;() == mem::size_of_val(<span class="kw-2">&amp;</span>a_boxed_error))</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::error::Error;%0A++++use+std::mem;%0A++++%0A++++let+a_str_error+=+%22a+str+error%22;%0A++++let+a_boxed_error+=+Box::%3Cdyn+Error%3E::from(a_str_error);%0A++++assert!(mem::size_of::%3CBox%3Cdyn+Error%3E%3E()+==+mem::size_of_val(%26a_boxed_error))%0A%7D&amp;edition=2021">Run</a></div>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-From%3C%26str%3E-for-Box%3Cdyn+Error+%2B+Send+%2B+Sync%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="../src/alloc/boxed.rs.html#2535">source</a></span><a href="#impl-From%3C%26str%3E-for-Box%3Cdyn+Error+%2B+Send+%2B+Sync%3E" class="anchor">Â§</a><h3 class="code-header">impl&lt;'a&gt; <a class="trait" href="convert/trait.From.html" title="trait std::convert::From">From</a>&lt;&amp;<a class="primitive" href="primitive.str.html">str</a>&gt; for <a class="struct" href="boxed/struct.Box.html" title="struct std::boxed::Box">Box</a>&lt;dyn <a class="trait" href="error/trait.Error.html" title="trait std::error::Error">Error</a> + <a class="trait" href="marker/trait.Send.html" title="trait std::marker::Send">Send</a> + <a class="trait" href="marker/trait.Sync.html" title="trait std::marker::Sync">Sync</a> + 'a&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from-9" class="method trait-impl"><a class="src rightside" href="../src/alloc/boxed.rs.html#2552">source</a><a href="#method.from-9" class="anchor">Â§</a><h4 class="code-header">fn <a href="convert/trait.From.html#tymethod.from" class="fn">from</a>(err: &amp;<a class="primitive" href="primitive.str.html">str</a>) -&gt; <a class="struct" href="boxed/struct.Box.html" title="struct std::boxed::Box">Box</a>&lt;dyn <a class="trait" href="error/trait.Error.html" title="trait std::error::Error">Error</a> + <a class="trait" href="marker/trait.Send.html" title="trait std::marker::Send">Send</a> + <a class="trait" href="marker/trait.Sync.html" title="trait std::marker::Sync">Sync</a> + 'a&gt;</h4></section></summary><div class="docblock"><p>Converts a <a href="primitive.str.html" title="primitive str"><code>str</code></a> into a box of dyn <a href="error/trait.Error.html" title="trait std::error::Error"><code>Error</code></a> + <a href="marker/trait.Send.html" title="trait std::marker::Send"><code>Send</code></a> + <a href="marker/trait.Sync.html" title="trait std::marker::Sync"><code>Sync</code></a>.</p>
<h5 id="examples-82"><a class="doc-anchor" href="#examples-82">Â§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::error::Error;
<span class="kw">use </span>std::mem;

<span class="kw">let </span>a_str_error = <span class="string">"a str error"</span>;
<span class="kw">let </span>a_boxed_error = Box::&lt;<span class="kw">dyn </span>Error + Send + Sync&gt;::from(a_str_error);
<span class="macro">assert!</span>(
    mem::size_of::&lt;Box&lt;<span class="kw">dyn </span>Error + Send + Sync&gt;&gt;() == mem::size_of_val(<span class="kw-2">&amp;</span>a_boxed_error))</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::error::Error;%0A++++use+std::mem;%0A++++%0A++++let+a_str_error+=+%22a+str+error%22;%0A++++let+a_boxed_error+=+Box::%3Cdyn+Error+%2B+Send+%2B+Sync%3E::from(a_str_error);%0A++++assert!(%0A++++++++mem::size_of::%3CBox%3Cdyn+Error+%2B+Send+%2B+Sync%3E%3E()+==+mem::size_of_val(%26a_boxed_error))%0A%7D&amp;edition=2021">Run</a></div>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-From%3C%26str%3E-for-Box%3Cstr%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.17.0">1.17.0</span> Â· <a class="src" href="../src/alloc/boxed.rs.html#1602">source</a></span><a href="#impl-From%3C%26str%3E-for-Box%3Cstr%3E" class="anchor">Â§</a><h3 class="code-header">impl <a class="trait" href="convert/trait.From.html" title="trait std::convert::From">From</a>&lt;&amp;<a class="primitive" href="primitive.str.html">str</a>&gt; for <a class="struct" href="boxed/struct.Box.html" title="struct std::boxed::Box">Box</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from-2" class="method trait-impl"><a class="src rightside" href="../src/alloc/boxed.rs.html#1615">source</a><a href="#method.from-2" class="anchor">Â§</a><h4 class="code-header">fn <a href="convert/trait.From.html#tymethod.from" class="fn">from</a>(s: &amp;<a class="primitive" href="primitive.str.html">str</a>) -&gt; <a class="struct" href="boxed/struct.Box.html" title="struct std::boxed::Box">Box</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt;</h4></section></summary><div class="docblock"><p>Converts a <code>&amp;str</code> into a <code>Box&lt;str&gt;</code></p>
<p>This conversion allocates on the heap
and performs a copy of <code>s</code>.</p>
<h5 id="examples-79"><a class="doc-anchor" href="#examples-79">Â§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>boxed: Box&lt;str&gt; = Box::from(<span class="string">"hello"</span>);
<span class="macro">println!</span>(<span class="string">"{boxed}"</span>);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+boxed:+Box%3Cstr%3E+=+Box::from(%22hello%22);%0A++++println!(%22%7Bboxed%7D%22);%0A%7D&amp;edition=2021">Run</a></div>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-From%3C%26str%3E-for-Cow%3C'a,+str%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="../src/alloc/string.rs.html#2809">source</a></span><a href="#impl-From%3C%26str%3E-for-Cow%3C'a,+str%3E" class="anchor">Â§</a><h3 class="code-header">impl&lt;'a&gt; <a class="trait" href="convert/trait.From.html" title="trait std::convert::From">From</a>&lt;&amp;'a <a class="primitive" href="primitive.str.html">str</a>&gt; for <a class="enum" href="borrow/enum.Cow.html" title="enum std::borrow::Cow">Cow</a>&lt;'a, <a class="primitive" href="primitive.str.html">str</a>&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from-5" class="method trait-impl"><a class="src rightside" href="../src/alloc/string.rs.html#2823">source</a><a href="#method.from-5" class="anchor">Â§</a><h4 class="code-header">fn <a href="convert/trait.From.html#tymethod.from" class="fn">from</a>(s: &amp;'a <a class="primitive" href="primitive.str.html">str</a>) -&gt; <a class="enum" href="borrow/enum.Cow.html" title="enum std::borrow::Cow">Cow</a>&lt;'a, <a class="primitive" href="primitive.str.html">str</a>&gt;</h4></section></summary><div class="docblock"><p>Converts a string slice into a <a href="borrow/enum.Cow.html#variant.Borrowed" title="borrow::Cow::Borrowed"><code>Borrowed</code></a> variant.
No heap allocation is performed, and the string
is not copied.</p>
<h5 id="example-1"><a class="doc-anchor" href="#example-1">Â§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(Cow::from(<span class="string">"eggplant"</span>), Cow::Borrowed(<span class="string">"eggplant"</span>));</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::borrow::Cow;%0A++++assert_eq!(Cow::from(%22eggplant%22),+Cow::Borrowed(%22eggplant%22));%0A%7D&amp;edition=2021">Run</a></div>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-From%3C%26str%3E-for-Rc%3Cstr%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.21.0">1.21.0</span> Â· <a class="src" href="../src/alloc/rc.rs.html#2580">source</a></span><a href="#impl-From%3C%26str%3E-for-Rc%3Cstr%3E" class="anchor">Â§</a><h3 class="code-header">impl <a class="trait" href="convert/trait.From.html" title="trait std::convert::From">From</a>&lt;&amp;<a class="primitive" href="primitive.str.html">str</a>&gt; for <a class="struct" href="rc/struct.Rc.html" title="struct std::rc::Rc">Rc</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from-3" class="method trait-impl"><a class="src rightside" href="../src/alloc/rc.rs.html#2591">source</a><a href="#method.from-3" class="anchor">Â§</a><h4 class="code-header">fn <a href="convert/trait.From.html#tymethod.from" class="fn">from</a>(v: &amp;<a class="primitive" href="primitive.str.html">str</a>) -&gt; <a class="struct" href="rc/struct.Rc.html" title="struct std::rc::Rc">Rc</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt;</h4></section></summary><div class="docblock"><p>Allocate a reference-counted string slice and copy <code>v</code> into it.</p>
<h5 id="example"><a class="doc-anchor" href="#example">Â§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>shared: Rc&lt;str&gt; = Rc::from(<span class="string">"statue"</span>);
<span class="macro">assert_eq!</span>(<span class="string">"statue"</span>, <span class="kw-2">&amp;</span>shared[..]);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::rc::Rc;%0A++++let+shared:+Rc%3Cstr%3E+=+Rc::from(%22statue%22);%0A++++assert_eq!(%22statue%22,+%26shared%5B..%5D);%0A%7D&amp;edition=2021">Run</a></div>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-From%3C%26str%3E-for-String" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="../src/alloc/string.rs.html#2709">source</a></span><a href="#impl-From%3C%26str%3E-for-String" class="anchor">Â§</a><h3 class="code-header">impl <a class="trait" href="convert/trait.From.html" title="trait std::convert::From">From</a>&lt;&amp;<a class="primitive" href="primitive.str.html">str</a>&gt; for <a class="struct" href="string/struct.String.html" title="struct std::string::String">String</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from-10" class="method trait-impl"><a class="src rightside" href="../src/alloc/string.rs.html#2714">source</a><a href="#method.from-10" class="anchor">Â§</a><h4 class="code-header">fn <a href="convert/trait.From.html#tymethod.from" class="fn">from</a>(s: &amp;<a class="primitive" href="primitive.str.html">str</a>) -&gt; <a class="struct" href="string/struct.String.html" title="struct std::string::String">String</a></h4></section></summary><div class="docblock"><p>Converts a <code>&amp;str</code> into a <a href="string/struct.String.html" title="struct std::string::String"><code>String</code></a>.</p>
<p>The result is allocated on the heap.</p>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-From%3C%26str%3E-for-Vec%3Cu8%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="../src/alloc/vec/mod.rs.html#3497">source</a></span><a href="#impl-From%3C%26str%3E-for-Vec%3Cu8%3E" class="anchor">Â§</a><h3 class="code-header">impl <a class="trait" href="convert/trait.From.html" title="trait std::convert::From">From</a>&lt;&amp;<a class="primitive" href="primitive.str.html">str</a>&gt; for <a class="struct" href="vec/struct.Vec.html" title="struct std::vec::Vec">Vec</a>&lt;<a class="primitive" href="primitive.u8.html">u8</a>&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from-4" class="method trait-impl"><a class="src rightside" href="../src/alloc/vec/mod.rs.html#3505">source</a><a href="#method.from-4" class="anchor">Â§</a><h4 class="code-header">fn <a href="convert/trait.From.html#tymethod.from" class="fn">from</a>(s: &amp;<a class="primitive" href="primitive.str.html">str</a>) -&gt; <a class="struct" href="vec/struct.Vec.html" title="struct std::vec::Vec">Vec</a>&lt;<a class="primitive" href="primitive.u8.html">u8</a>&gt; <a href="#" class="tooltip" data-notable-ty="Vec&lt;u8&gt;">â“˜</a></h4></section></summary><div class="docblock"><p>Allocate a <code>Vec&lt;u8&gt;</code> and fill it with a UTF-8 string.</p>
<h5 id="examples-80"><a class="doc-anchor" href="#examples-80">Â§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(Vec::from(<span class="string">"123"</span>), <span class="macro">vec!</span>[<span class="string">b'1'</span>, <span class="string">b'2'</span>, <span class="string">b'3'</span>]);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++assert_eq!(Vec::from(%22123%22),+vec!%5Bb'1',+b'2',+b'3'%5D);%0A%7D&amp;edition=2021">Run</a></div>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-From%3CCow%3C'_,+str%3E%3E-for-Box%3Cstr%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.45.0">1.45.0</span> Â· <a class="src" href="../src/alloc/boxed.rs.html#1622">source</a></span><a href="#impl-From%3CCow%3C'_,+str%3E%3E-for-Box%3Cstr%3E" class="anchor">Â§</a><h3 class="code-header">impl <a class="trait" href="convert/trait.From.html" title="trait std::convert::From">From</a>&lt;<a class="enum" href="borrow/enum.Cow.html" title="enum std::borrow::Cow">Cow</a>&lt;'_, <a class="primitive" href="primitive.str.html">str</a>&gt;&gt; for <a class="struct" href="boxed/struct.Box.html" title="struct std::boxed::Box">Box</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from-8" class="method trait-impl"><a class="src rightside" href="../src/alloc/boxed.rs.html#1647">source</a><a href="#method.from-8" class="anchor">Â§</a><h4 class="code-header">fn <a href="convert/trait.From.html#tymethod.from" class="fn">from</a>(cow: <a class="enum" href="borrow/enum.Cow.html" title="enum std::borrow::Cow">Cow</a>&lt;'_, <a class="primitive" href="primitive.str.html">str</a>&gt;) -&gt; <a class="struct" href="boxed/struct.Box.html" title="struct std::boxed::Box">Box</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt;</h4></section></summary><div class="docblock"><p>Converts a <code>Cow&lt;'_, str&gt;</code> into a <code>Box&lt;str&gt;</code></p>
<p>When <code>cow</code> is the <code>Cow::Borrowed</code> variant, this
conversion allocates on the heap and copies the
underlying <code>str</code>. Otherwise, it will try to reuse the owned
<code>String</code>â€™s allocation.</p>
<h5 id="examples-81"><a class="doc-anchor" href="#examples-81">Â§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::borrow::Cow;

<span class="kw">let </span>unboxed = Cow::Borrowed(<span class="string">"hello"</span>);
<span class="kw">let </span>boxed: Box&lt;str&gt; = Box::from(unboxed);
<span class="macro">println!</span>(<span class="string">"{boxed}"</span>);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::borrow::Cow;%0A++++%0A++++let+unboxed+=+Cow::Borrowed(%22hello%22);%0A++++let+boxed:+Box%3Cstr%3E+=+Box::from(unboxed);%0A++++println!(%22%7Bboxed%7D%22);%0A%7D&amp;edition=2021">Run</a></div>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>unboxed = Cow::Owned(<span class="string">"hello"</span>.to_string());
<span class="kw">let </span>boxed: Box&lt;str&gt; = Box::from(unboxed);
<span class="macro">println!</span>(<span class="string">"{boxed}"</span>);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::borrow::Cow;%0A++++let+unboxed+=+Cow::Owned(%22hello%22.to_string());%0A++++let+boxed:+Box%3Cstr%3E+=+Box::from(unboxed);%0A++++println!(%22%7Bboxed%7D%22);%0A%7D&amp;edition=2021">Run</a></div>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-From%3CString%3E-for-Box%3Cstr%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.20.0">1.20.0</span> Â· <a class="src" href="../src/alloc/string.rs.html#2766">source</a></span><a href="#impl-From%3CString%3E-for-Box%3Cstr%3E" class="anchor">Â§</a><h3 class="code-header">impl <a class="trait" href="convert/trait.From.html" title="trait std::convert::From">From</a>&lt;<a class="struct" href="string/struct.String.html" title="struct std::string::String">String</a>&gt; for <a class="struct" href="boxed/struct.Box.html" title="struct std::boxed::Box">Box</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from-1" class="method trait-impl"><a class="src rightside" href="../src/alloc/string.rs.html#2778">source</a><a href="#method.from-1" class="anchor">Â§</a><h4 class="code-header">fn <a href="convert/trait.From.html#tymethod.from" class="fn">from</a>(s: <a class="struct" href="string/struct.String.html" title="struct std::string::String">String</a>) -&gt; <a class="struct" href="boxed/struct.Box.html" title="struct std::boxed::Box">Box</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt;</h4></section></summary><div class="docblock"><p>Converts the given <a href="string/struct.String.html" title="struct std::string::String"><code>String</code></a> to a boxed <code>str</code> slice that is owned.</p>
<h5 id="examples-78"><a class="doc-anchor" href="#examples-78">Â§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>s1: String = String::from(<span class="string">"hello world"</span>);
<span class="kw">let </span>s2: Box&lt;str&gt; = Box::from(s1);
<span class="kw">let </span>s3: String = String::from(s2);

<span class="macro">assert_eq!</span>(<span class="string">"hello world"</span>, s3)</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+s1:+String+=+String::from(%22hello+world%22);%0A++++let+s2:+Box%3Cstr%3E+=+Box::from(s1);%0A++++let+s3:+String+=+String::from(s2);%0A++++%0A++++assert_eq!(%22hello+world%22,+s3)%0A%7D&amp;edition=2021">Run</a></div>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-FromIterator%3C%26char%3E-for-Box%3Cstr%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.80.0">1.80.0</span> Â· <a class="src" href="../src/alloc/boxed.rs.html#2179">source</a></span><a href="#impl-FromIterator%3C%26char%3E-for-Box%3Cstr%3E" class="anchor">Â§</a><h3 class="code-header">impl&lt;'a&gt; <a class="trait" href="iter/trait.FromIterator.html" title="trait std::iter::FromIterator">FromIterator</a>&lt;&amp;'a <a class="primitive" href="primitive.char.html">char</a>&gt; for <a class="struct" href="boxed/struct.Box.html" title="struct std::boxed::Box">Box</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from_iter-5" class="method trait-impl"><a class="src rightside" href="../src/alloc/boxed.rs.html#2180">source</a><a href="#method.from_iter-5" class="anchor">Â§</a><h4 class="code-header">fn <a href="iter/trait.FromIterator.html#tymethod.from_iter" class="fn">from_iter</a>&lt;T&gt;(iter: T) -&gt; <a class="struct" href="boxed/struct.Box.html" title="struct std::boxed::Box">Box</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt;<div class="where">where
    T: <a class="trait" href="iter/trait.IntoIterator.html" title="trait std::iter::IntoIterator">IntoIterator</a>&lt;Item = &amp;'a <a class="primitive" href="primitive.char.html">char</a>&gt;,</div></h4></section></summary><div class='docblock'>Creates a value from an iterator. <a href="iter/trait.FromIterator.html#tymethod.from_iter">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-FromIterator%3C%26str%3E-for-Box%3Cstr%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.80.0">1.80.0</span> Â· <a class="src" href="../src/alloc/boxed.rs.html#2187">source</a></span><a href="#impl-FromIterator%3C%26str%3E-for-Box%3Cstr%3E" class="anchor">Â§</a><h3 class="code-header">impl&lt;'a&gt; <a class="trait" href="iter/trait.FromIterator.html" title="trait std::iter::FromIterator">FromIterator</a>&lt;&amp;'a <a class="primitive" href="primitive.str.html">str</a>&gt; for <a class="struct" href="boxed/struct.Box.html" title="struct std::boxed::Box">Box</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from_iter-6" class="method trait-impl"><a class="src rightside" href="../src/alloc/boxed.rs.html#2188">source</a><a href="#method.from_iter-6" class="anchor">Â§</a><h4 class="code-header">fn <a href="iter/trait.FromIterator.html#tymethod.from_iter" class="fn">from_iter</a>&lt;T&gt;(iter: T) -&gt; <a class="struct" href="boxed/struct.Box.html" title="struct std::boxed::Box">Box</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt;<div class="where">where
    T: <a class="trait" href="iter/trait.IntoIterator.html" title="trait std::iter::IntoIterator">IntoIterator</a>&lt;Item = &amp;'a <a class="primitive" href="primitive.str.html">str</a>&gt;,</div></h4></section></summary><div class='docblock'>Creates a value from an iterator. <a href="iter/trait.FromIterator.html#tymethod.from_iter">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-FromIterator%3C%26str%3E-for-Cow%3C'a,+str%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.12.0">1.12.0</span> Â· <a class="src" href="../src/alloc/string.rs.html#2883">source</a></span><a href="#impl-FromIterator%3C%26str%3E-for-Cow%3C'a,+str%3E" class="anchor">Â§</a><h3 class="code-header">impl&lt;'a, 'b&gt; <a class="trait" href="iter/trait.FromIterator.html" title="trait std::iter::FromIterator">FromIterator</a>&lt;&amp;'b <a class="primitive" href="primitive.str.html">str</a>&gt; for <a class="enum" href="borrow/enum.Cow.html" title="enum std::borrow::Cow">Cow</a>&lt;'a, <a class="primitive" href="primitive.str.html">str</a>&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from_iter-3" class="method trait-impl"><a class="src rightside" href="../src/alloc/string.rs.html#2884">source</a><a href="#method.from_iter-3" class="anchor">Â§</a><h4 class="code-header">fn <a href="iter/trait.FromIterator.html#tymethod.from_iter" class="fn">from_iter</a>&lt;I&gt;(it: I) -&gt; <a class="enum" href="borrow/enum.Cow.html" title="enum std::borrow::Cow">Cow</a>&lt;'a, <a class="primitive" href="primitive.str.html">str</a>&gt;<div class="where">where
    I: <a class="trait" href="iter/trait.IntoIterator.html" title="trait std::iter::IntoIterator">IntoIterator</a>&lt;Item = &amp;'b <a class="primitive" href="primitive.str.html">str</a>&gt;,</div></h4></section></summary><div class='docblock'>Creates a value from an iterator. <a href="iter/trait.FromIterator.html#tymethod.from_iter">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-FromIterator%3C%26str%3E-for-String" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="../src/alloc/string.rs.html#2133">source</a></span><a href="#impl-FromIterator%3C%26str%3E-for-String" class="anchor">Â§</a><h3 class="code-header">impl&lt;'a&gt; <a class="trait" href="iter/trait.FromIterator.html" title="trait std::iter::FromIterator">FromIterator</a>&lt;&amp;'a <a class="primitive" href="primitive.str.html">str</a>&gt; for <a class="struct" href="string/struct.String.html" title="struct std::string::String">String</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from_iter-1" class="method trait-impl"><a class="src rightside" href="../src/alloc/string.rs.html#2134">source</a><a href="#method.from_iter-1" class="anchor">Â§</a><h4 class="code-header">fn <a href="iter/trait.FromIterator.html#tymethod.from_iter" class="fn">from_iter</a>&lt;I&gt;(iter: I) -&gt; <a class="struct" href="string/struct.String.html" title="struct std::string::String">String</a><div class="where">where
    I: <a class="trait" href="iter/trait.IntoIterator.html" title="trait std::iter::IntoIterator">IntoIterator</a>&lt;Item = &amp;'a <a class="primitive" href="primitive.str.html">str</a>&gt;,</div></h4></section></summary><div class='docblock'>Creates a value from an iterator. <a href="iter/trait.FromIterator.html#tymethod.from_iter">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-FromIterator%3CBox%3Cstr,+A%3E%3E-for-Box%3Cstr%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.80.0">1.80.0</span> Â· <a class="src" href="../src/alloc/boxed.rs.html#2203">source</a></span><a href="#impl-FromIterator%3CBox%3Cstr,+A%3E%3E-for-Box%3Cstr%3E" class="anchor">Â§</a><h3 class="code-header">impl&lt;A&gt; <a class="trait" href="iter/trait.FromIterator.html" title="trait std::iter::FromIterator">FromIterator</a>&lt;<a class="struct" href="boxed/struct.Box.html" title="struct std::boxed::Box">Box</a>&lt;<a class="primitive" href="primitive.str.html">str</a>, A&gt;&gt; for <a class="struct" href="boxed/struct.Box.html" title="struct std::boxed::Box">Box</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt;<div class="where">where
    A: <a class="trait" href="alloc/trait.Allocator.html" title="trait std::alloc::Allocator">Allocator</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from_iter-2" class="method trait-impl"><a class="src rightside" href="../src/alloc/boxed.rs.html#2204">source</a><a href="#method.from_iter-2" class="anchor">Â§</a><h4 class="code-header">fn <a href="iter/trait.FromIterator.html#tymethod.from_iter" class="fn">from_iter</a>&lt;T&gt;(iter: T) -&gt; <a class="struct" href="boxed/struct.Box.html" title="struct std::boxed::Box">Box</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt;<div class="where">where
    T: <a class="trait" href="iter/trait.IntoIterator.html" title="trait std::iter::IntoIterator">IntoIterator</a>&lt;Item = <a class="struct" href="boxed/struct.Box.html" title="struct std::boxed::Box">Box</a>&lt;<a class="primitive" href="primitive.str.html">str</a>, A&gt;&gt;,</div></h4></section></summary><div class='docblock'>Creates a value from an iterator. <a href="iter/trait.FromIterator.html#tymethod.from_iter">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-FromIterator%3CCow%3C'a,+str%3E%3E-for-Box%3Cstr%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.80.0">1.80.0</span> Â· <a class="src" href="../src/alloc/boxed.rs.html#2211">source</a></span><a href="#impl-FromIterator%3CCow%3C'a,+str%3E%3E-for-Box%3Cstr%3E" class="anchor">Â§</a><h3 class="code-header">impl&lt;'a&gt; <a class="trait" href="iter/trait.FromIterator.html" title="trait std::iter::FromIterator">FromIterator</a>&lt;<a class="enum" href="borrow/enum.Cow.html" title="enum std::borrow::Cow">Cow</a>&lt;'a, <a class="primitive" href="primitive.str.html">str</a>&gt;&gt; for <a class="struct" href="boxed/struct.Box.html" title="struct std::boxed::Box">Box</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from_iter-7" class="method trait-impl"><a class="src rightside" href="../src/alloc/boxed.rs.html#2212">source</a><a href="#method.from_iter-7" class="anchor">Â§</a><h4 class="code-header">fn <a href="iter/trait.FromIterator.html#tymethod.from_iter" class="fn">from_iter</a>&lt;T&gt;(iter: T) -&gt; <a class="struct" href="boxed/struct.Box.html" title="struct std::boxed::Box">Box</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt;<div class="where">where
    T: <a class="trait" href="iter/trait.IntoIterator.html" title="trait std::iter::IntoIterator">IntoIterator</a>&lt;Item = <a class="enum" href="borrow/enum.Cow.html" title="enum std::borrow::Cow">Cow</a>&lt;'a, <a class="primitive" href="primitive.str.html">str</a>&gt;&gt;,</div></h4></section></summary><div class='docblock'>Creates a value from an iterator. <a href="iter/trait.FromIterator.html#tymethod.from_iter">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-FromIterator%3CString%3E-for-Box%3Cstr%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.80.0">1.80.0</span> Â· <a class="src" href="../src/alloc/boxed.rs.html#2195">source</a></span><a href="#impl-FromIterator%3CString%3E-for-Box%3Cstr%3E" class="anchor">Â§</a><h3 class="code-header">impl <a class="trait" href="iter/trait.FromIterator.html" title="trait std::iter::FromIterator">FromIterator</a>&lt;<a class="struct" href="string/struct.String.html" title="struct std::string::String">String</a>&gt; for <a class="struct" href="boxed/struct.Box.html" title="struct std::boxed::Box">Box</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from_iter-4" class="method trait-impl"><a class="src rightside" href="../src/alloc/boxed.rs.html#2196">source</a><a href="#method.from_iter-4" class="anchor">Â§</a><h4 class="code-header">fn <a href="iter/trait.FromIterator.html#tymethod.from_iter" class="fn">from_iter</a>&lt;T&gt;(iter: T) -&gt; <a class="struct" href="boxed/struct.Box.html" title="struct std::boxed::Box">Box</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt;<div class="where">where
    T: <a class="trait" href="iter/trait.IntoIterator.html" title="trait std::iter::IntoIterator">IntoIterator</a>&lt;Item = <a class="struct" href="string/struct.String.html" title="struct std::string::String">String</a>&gt;,</div></h4></section></summary><div class='docblock'>Creates a value from an iterator. <a href="iter/trait.FromIterator.html#tymethod.from_iter">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-FromIterator%3Cchar%3E-for-Box%3Cstr%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.80.0">1.80.0</span> Â· <a class="src" href="../src/alloc/boxed.rs.html#2171">source</a></span><a href="#impl-FromIterator%3Cchar%3E-for-Box%3Cstr%3E" class="anchor">Â§</a><h3 class="code-header">impl <a class="trait" href="iter/trait.FromIterator.html" title="trait std::iter::FromIterator">FromIterator</a>&lt;<a class="primitive" href="primitive.char.html">char</a>&gt; for <a class="struct" href="boxed/struct.Box.html" title="struct std::boxed::Box">Box</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from_iter" class="method trait-impl"><a class="src rightside" href="../src/alloc/boxed.rs.html#2172">source</a><a href="#method.from_iter" class="anchor">Â§</a><h4 class="code-header">fn <a href="iter/trait.FromIterator.html#tymethod.from_iter" class="fn">from_iter</a>&lt;T&gt;(iter: T) -&gt; <a class="struct" href="boxed/struct.Box.html" title="struct std::boxed::Box">Box</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt;<div class="where">where
    T: <a class="trait" href="iter/trait.IntoIterator.html" title="trait std::iter::IntoIterator">IntoIterator</a>&lt;Item = <a class="primitive" href="primitive.char.html">char</a>&gt;,</div></h4></section></summary><div class='docblock'>Creates a value from an iterator. <a href="iter/trait.FromIterator.html#tymethod.from_iter">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Hash-for-str" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="https://doc.rust-lang.org/1.80.1/src/core/hash/mod.rs.html#868">source</a></span><a href="#impl-Hash-for-str" class="anchor">Â§</a><h3 class="code-header">impl <a class="trait" href="hash/trait.Hash.html" title="trait std::hash::Hash">Hash</a> for <a class="primitive" href="primitive.str.html">str</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.hash" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/hash/mod.rs.html#870">source</a><a href="#method.hash" class="anchor">Â§</a><h4 class="code-header">fn <a href="hash/trait.Hash.html#tymethod.hash" class="fn">hash</a>&lt;H&gt;(&amp;self, state: <a class="primitive" href="primitive.reference.html">&amp;mut H</a>)<div class="where">where
    H: <a class="trait" href="hash/trait.Hasher.html" title="trait std::hash::Hasher">Hasher</a>,</div></h4></section></summary><div class='docblock'>Feeds this value into the given <a href="hash/trait.Hasher.html" title="trait std::hash::Hasher"><code>Hasher</code></a>. <a href="hash/trait.Hash.html#tymethod.hash">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Index%3CI%3E-for-str" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="https://doc.rust-lang.org/1.80.1/src/core/str/traits.rs.html#54-56">source</a></span><a href="#impl-Index%3CI%3E-for-str" class="anchor">Â§</a><h3 class="code-header">impl&lt;I&gt; <a class="trait" href="ops/trait.Index.html" title="trait std::ops::Index">Index</a>&lt;I&gt; for <a class="primitive" href="primitive.str.html">str</a><div class="where">where
    I: <a class="trait" href="slice/trait.SliceIndex.html" title="trait std::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Output" class="associatedtype trait-impl"><a href="#associatedtype.Output" class="anchor">Â§</a><h4 class="code-header">type <a href="ops/trait.Index.html#associatedtype.Output" class="associatedtype">Output</a> = &lt;I as <a class="trait" href="slice/trait.SliceIndex.html" title="trait std::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt;&gt;::<a class="associatedtype" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type std::slice::SliceIndex::Output">Output</a></h4></section></summary><div class='docblock'>The returned type after indexing.</div></details><details class="toggle method-toggle" open><summary><section id="method.index" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/str/traits.rs.html#61">source</a><a href="#method.index" class="anchor">Â§</a><h4 class="code-header">fn <a href="ops/trait.Index.html#tymethod.index" class="fn">index</a>(&amp;self, index: I) -&gt; &amp;&lt;I as <a class="trait" href="slice/trait.SliceIndex.html" title="trait std::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt;&gt;::<a class="associatedtype" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type std::slice::SliceIndex::Output">Output</a></h4></section></summary><div class='docblock'>Performs the indexing (<code>container[index]</code>) operation. <a href="ops/trait.Index.html#tymethod.index">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-IndexMut%3CI%3E-for-str" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="https://doc.rust-lang.org/1.80.1/src/core/str/traits.rs.html#67-69">source</a></span><a href="#impl-IndexMut%3CI%3E-for-str" class="anchor">Â§</a><h3 class="code-header">impl&lt;I&gt; <a class="trait" href="ops/trait.IndexMut.html" title="trait std::ops::IndexMut">IndexMut</a>&lt;I&gt; for <a class="primitive" href="primitive.str.html">str</a><div class="where">where
    I: <a class="trait" href="slice/trait.SliceIndex.html" title="trait std::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.index_mut-7" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/str/traits.rs.html#72">source</a><a href="#method.index_mut-7" class="anchor">Â§</a><h4 class="code-header">fn <a href="ops/trait.IndexMut.html#tymethod.index_mut" class="fn">index_mut</a>(&amp;mut self, index: I) -&gt; &amp;mut &lt;I as <a class="trait" href="slice/trait.SliceIndex.html" title="trait std::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt;&gt;::<a class="associatedtype" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type std::slice::SliceIndex::Output">Output</a></h4></section></summary><div class='docblock'>Performs the mutable indexing (<code>container[index]</code>) operation. <a href="ops/trait.IndexMut.html#tymethod.index_mut">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Join%3C%26str%3E-for-%5BS%5D" class="impl"><a class="src rightside" href="../src/alloc/str.rs.html#73">source</a><a href="#impl-Join%3C%26str%3E-for-%5BS%5D" class="anchor">Â§</a><h3 class="code-header">impl&lt;S&gt; <a class="trait" href="slice/trait.Join.html" title="trait std::slice::Join">Join</a>&lt;&amp;<a class="primitive" href="primitive.str.html">str</a>&gt; for <a class="primitive" href="primitive.slice.html">[S]</a><div class="where">where
    S: <a class="trait" href="borrow/trait.Borrow.html" title="trait std::borrow::Borrow">Borrow</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Output-10" class="associatedtype trait-impl"><a href="#associatedtype.Output-10" class="anchor">Â§</a><h4 class="code-header">type <a href="slice/trait.Join.html#associatedtype.Output" class="associatedtype">Output</a> = <a class="struct" href="string/struct.String.html" title="struct std::string::String">String</a></h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>slice_concat_trait</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/27747">#27747</a>)</span></div></span><div class='docblock'>The resulting type after concatenation</div></details><details class="toggle method-toggle" open><summary><section id="method.join" class="method trait-impl"><a class="src rightside" href="../src/alloc/str.rs.html#76">source</a><a href="#method.join" class="anchor">Â§</a><h4 class="code-header">fn <a href="slice/trait.Join.html#tymethod.join" class="fn">join</a>(slice: &amp;<a class="primitive" href="primitive.slice.html">[S]</a>, sep: &amp;<a class="primitive" href="primitive.str.html">str</a>) -&gt; <a class="struct" href="string/struct.String.html" title="struct std::string::String">String</a></h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>slice_concat_trait</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/27747">#27747</a>)</span></div></span><div class='docblock'>Implementation of <a href="primitive.slice.html#method.join" title="method slice::join"><code>[T]::join</code></a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Ord-for-str" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="https://doc.rust-lang.org/1.80.1/src/core/str/traits.rs.html#20">source</a></span><a href="#impl-Ord-for-str" class="anchor">Â§</a><h3 class="code-header">impl <a class="trait" href="cmp/trait.Ord.html" title="trait std::cmp::Ord">Ord</a> for <a class="primitive" href="primitive.str.html">str</a></h3></section></summary><div class="docblock"><p>Implements ordering of strings.</p>
<p>Strings are ordered  <a href="cmp/trait.Ord.html#lexicographical-comparison" title="trait std::cmp::Ord">lexicographically</a> by their byte values. This orders Unicode code
points based on their positions in the code charts. This is not necessarily the same as
â€œalphabeticalâ€ order, which varies by language and locale. Sorting strings according to
culturally-accepted standards requires locale-specific data that is outside the scope of
the <code>str</code> type.</p>
</div><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.cmp" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/str/traits.rs.html#22">source</a><a href="#method.cmp" class="anchor">Â§</a><h4 class="code-header">fn <a href="cmp/trait.Ord.html#tymethod.cmp" class="fn">cmp</a>(&amp;self, other: &amp;<a class="primitive" href="primitive.str.html">str</a>) -&gt; <a class="enum" href="cmp/enum.Ordering.html" title="enum std::cmp::Ordering">Ordering</a></h4></section></summary><div class='docblock'>This method returns an <a href="cmp/enum.Ordering.html" title="enum std::cmp::Ordering"><code>Ordering</code></a> between <code>self</code> and <code>other</code>. <a href="cmp/trait.Ord.html#tymethod.cmp">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-PartialEq%3C%26str%3E-for-Cow%3C'a,+str%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="../src/alloc/string.rs.html#2356">source</a></span><a href="#impl-PartialEq%3C%26str%3E-for-Cow%3C'a,+str%3E" class="anchor">Â§</a><h3 class="code-header">impl&lt;'a, 'b&gt; <a class="trait" href="cmp/trait.PartialEq.html" title="trait std::cmp::PartialEq">PartialEq</a>&lt;&amp;'b <a class="primitive" href="primitive.str.html">str</a>&gt; for <a class="enum" href="borrow/enum.Cow.html" title="enum std::borrow::Cow">Cow</a>&lt;'a, <a class="primitive" href="primitive.str.html">str</a>&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.eq-3" class="method trait-impl"><a class="src rightside" href="../src/alloc/string.rs.html#2356">source</a><a href="#method.eq-3" class="anchor">Â§</a><h4 class="code-header">fn <a href="cmp/trait.PartialEq.html#tymethod.eq" class="fn">eq</a>(&amp;self, other: &amp;&amp;'b <a class="primitive" href="primitive.str.html">str</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>This method tests for <code>self</code> and <code>other</code> values to be equal, and is used
by <code>==</code>.</div></details><details class="toggle method-toggle" open><summary><section id="method.ne-3" class="method trait-impl"><a class="src rightside" href="../src/alloc/string.rs.html#2356">source</a><a href="#method.ne-3" class="anchor">Â§</a><h4 class="code-header">fn <a href="cmp/trait.PartialEq.html#method.ne" class="fn">ne</a>(&amp;self, other: &amp;&amp;'b <a class="primitive" href="primitive.str.html">str</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>This method tests for <code>!=</code>. The default implementation is almost always
sufficient, and should not be overridden without very good reason.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-PartialEq%3C%26str%3E-for-OsString" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.29.0">1.29.0</span> Â· <a class="src" href="../src/std/ffi/os_str.rs.html#657-662">source</a></span><a href="#impl-PartialEq%3C%26str%3E-for-OsString" class="anchor">Â§</a><h3 class="code-header">impl <a class="trait" href="cmp/trait.PartialEq.html" title="trait std::cmp::PartialEq">PartialEq</a>&lt;&amp;<a class="primitive" href="primitive.str.html">str</a>&gt; for <a class="struct" href="ffi/struct.OsString.html" title="struct std::ffi::OsString">OsString</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.eq-11" class="method trait-impl"><a class="src rightside" href="../src/std/ffi/os_str.rs.html#659-661">source</a><a href="#method.eq-11" class="anchor">Â§</a><h4 class="code-header">fn <a href="cmp/trait.PartialEq.html#tymethod.eq" class="fn">eq</a>(&amp;self, other: &amp;&amp;<a class="primitive" href="primitive.str.html">str</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>This method tests for <code>self</code> and <code>other</code> values to be equal, and is used
by <code>==</code>.</div></details><details class="toggle method-toggle" open><summary><section id="method.ne-11" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="https://doc.rust-lang.org/1.80.1/src/core/cmp.rs.html#263">source</a></span><a href="#method.ne-11" class="anchor">Â§</a><h4 class="code-header">fn <a href="cmp/trait.PartialEq.html#method.ne" class="fn">ne</a>(&amp;self, other: <a class="primitive" href="primitive.reference.html">&amp;Rhs</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>This method tests for <code>!=</code>. The default implementation is almost always
sufficient, and should not be overridden without very good reason.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-PartialEq%3C%26str%3E-for-String" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="../src/alloc/string.rs.html#2352">source</a></span><a href="#impl-PartialEq%3C%26str%3E-for-String" class="anchor">Â§</a><h3 class="code-header">impl&lt;'a, 'b&gt; <a class="trait" href="cmp/trait.PartialEq.html" title="trait std::cmp::PartialEq">PartialEq</a>&lt;&amp;'a <a class="primitive" href="primitive.str.html">str</a>&gt; for <a class="struct" href="string/struct.String.html" title="struct std::string::String">String</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.eq-6" class="method trait-impl"><a class="src rightside" href="../src/alloc/string.rs.html#2352">source</a><a href="#method.eq-6" class="anchor">Â§</a><h4 class="code-header">fn <a href="cmp/trait.PartialEq.html#tymethod.eq" class="fn">eq</a>(&amp;self, other: &amp;&amp;'a <a class="primitive" href="primitive.str.html">str</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>This method tests for <code>self</code> and <code>other</code> values to be equal, and is used
by <code>==</code>.</div></details><details class="toggle method-toggle" open><summary><section id="method.ne-6" class="method trait-impl"><a class="src rightside" href="../src/alloc/string.rs.html#2352">source</a><a href="#method.ne-6" class="anchor">Â§</a><h4 class="code-header">fn <a href="cmp/trait.PartialEq.html#method.ne" class="fn">ne</a>(&amp;self, other: &amp;&amp;'a <a class="primitive" href="primitive.str.html">str</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>This method tests for <code>!=</code>. The default implementation is almost always
sufficient, and should not be overridden without very good reason.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-PartialEq%3CCow%3C'a,+str%3E%3E-for-%26str" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="../src/alloc/string.rs.html#2356">source</a></span><a href="#impl-PartialEq%3CCow%3C'a,+str%3E%3E-for-%26str" class="anchor">Â§</a><h3 class="code-header">impl&lt;'a, 'b&gt; <a class="trait" href="cmp/trait.PartialEq.html" title="trait std::cmp::PartialEq">PartialEq</a>&lt;<a class="enum" href="borrow/enum.Cow.html" title="enum std::borrow::Cow">Cow</a>&lt;'a, <a class="primitive" href="primitive.str.html">str</a>&gt;&gt; for &amp;'b <a class="primitive" href="primitive.str.html">str</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.eq-7" class="method trait-impl"><a class="src rightside" href="../src/alloc/string.rs.html#2356">source</a><a href="#method.eq-7" class="anchor">Â§</a><h4 class="code-header">fn <a href="cmp/trait.PartialEq.html#tymethod.eq" class="fn">eq</a>(&amp;self, other: &amp;<a class="enum" href="borrow/enum.Cow.html" title="enum std::borrow::Cow">Cow</a>&lt;'a, <a class="primitive" href="primitive.str.html">str</a>&gt;) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>This method tests for <code>self</code> and <code>other</code> values to be equal, and is used
by <code>==</code>.</div></details><details class="toggle method-toggle" open><summary><section id="method.ne-7" class="method trait-impl"><a class="src rightside" href="../src/alloc/string.rs.html#2356">source</a><a href="#method.ne-7" class="anchor">Â§</a><h4 class="code-header">fn <a href="cmp/trait.PartialEq.html#method.ne" class="fn">ne</a>(&amp;self, other: &amp;<a class="enum" href="borrow/enum.Cow.html" title="enum std::borrow::Cow">Cow</a>&lt;'a, <a class="primitive" href="primitive.str.html">str</a>&gt;) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>This method tests for <code>!=</code>. The default implementation is almost always
sufficient, and should not be overridden without very good reason.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-PartialEq%3CCow%3C'a,+str%3E%3E-for-str" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="../src/alloc/string.rs.html#2354">source</a></span><a href="#impl-PartialEq%3CCow%3C'a,+str%3E%3E-for-str" class="anchor">Â§</a><h3 class="code-header">impl&lt;'a, 'b&gt; <a class="trait" href="cmp/trait.PartialEq.html" title="trait std::cmp::PartialEq">PartialEq</a>&lt;<a class="enum" href="borrow/enum.Cow.html" title="enum std::borrow::Cow">Cow</a>&lt;'a, <a class="primitive" href="primitive.str.html">str</a>&gt;&gt; for <a class="primitive" href="primitive.str.html">str</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.eq-2" class="method trait-impl"><a class="src rightside" href="../src/alloc/string.rs.html#2354">source</a><a href="#method.eq-2" class="anchor">Â§</a><h4 class="code-header">fn <a href="cmp/trait.PartialEq.html#tymethod.eq" class="fn">eq</a>(&amp;self, other: &amp;<a class="enum" href="borrow/enum.Cow.html" title="enum std::borrow::Cow">Cow</a>&lt;'a, <a class="primitive" href="primitive.str.html">str</a>&gt;) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>This method tests for <code>self</code> and <code>other</code> values to be equal, and is used
by <code>==</code>.</div></details><details class="toggle method-toggle" open><summary><section id="method.ne-2" class="method trait-impl"><a class="src rightside" href="../src/alloc/string.rs.html#2354">source</a><a href="#method.ne-2" class="anchor">Â§</a><h4 class="code-header">fn <a href="cmp/trait.PartialEq.html#method.ne" class="fn">ne</a>(&amp;self, other: &amp;<a class="enum" href="borrow/enum.Cow.html" title="enum std::borrow::Cow">Cow</a>&lt;'a, <a class="primitive" href="primitive.str.html">str</a>&gt;) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>This method tests for <code>!=</code>. The default implementation is almost always
sufficient, and should not be overridden without very good reason.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-PartialEq%3COsStr%3E-for-str" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="../src/std/ffi/os_str.rs.html#1372-1377">source</a></span><a href="#impl-PartialEq%3COsStr%3E-for-str" class="anchor">Â§</a><h3 class="code-header">impl <a class="trait" href="cmp/trait.PartialEq.html" title="trait std::cmp::PartialEq">PartialEq</a>&lt;<a class="struct" href="ffi/struct.OsStr.html" title="struct std::ffi::OsStr">OsStr</a>&gt; for <a class="primitive" href="primitive.str.html">str</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.eq-12" class="method trait-impl"><a class="src rightside" href="../src/std/ffi/os_str.rs.html#1374-1376">source</a><a href="#method.eq-12" class="anchor">Â§</a><h4 class="code-header">fn <a href="cmp/trait.PartialEq.html#tymethod.eq" class="fn">eq</a>(&amp;self, other: &amp;<a class="struct" href="ffi/struct.OsStr.html" title="struct std::ffi::OsStr">OsStr</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>This method tests for <code>self</code> and <code>other</code> values to be equal, and is used
by <code>==</code>.</div></details><details class="toggle method-toggle" open><summary><section id="method.ne-12" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="https://doc.rust-lang.org/1.80.1/src/core/cmp.rs.html#263">source</a></span><a href="#method.ne-12" class="anchor">Â§</a><h4 class="code-header">fn <a href="cmp/trait.PartialEq.html#method.ne" class="fn">ne</a>(&amp;self, other: <a class="primitive" href="primitive.reference.html">&amp;Rhs</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>This method tests for <code>!=</code>. The default implementation is almost always
sufficient, and should not be overridden without very good reason.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-PartialEq%3COsString%3E-for-%26str" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.29.0">1.29.0</span> Â· <a class="src" href="../src/std/ffi/os_str.rs.html#665-670">source</a></span><a href="#impl-PartialEq%3COsString%3E-for-%26str" class="anchor">Â§</a><h3 class="code-header">impl&lt;'a&gt; <a class="trait" href="cmp/trait.PartialEq.html" title="trait std::cmp::PartialEq">PartialEq</a>&lt;<a class="struct" href="ffi/struct.OsString.html" title="struct std::ffi::OsString">OsString</a>&gt; for &amp;'a <a class="primitive" href="primitive.str.html">str</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.eq-9" class="method trait-impl"><a class="src rightside" href="../src/std/ffi/os_str.rs.html#667-669">source</a><a href="#method.eq-9" class="anchor">Â§</a><h4 class="code-header">fn <a href="cmp/trait.PartialEq.html#tymethod.eq" class="fn">eq</a>(&amp;self, other: &amp;<a class="struct" href="ffi/struct.OsString.html" title="struct std::ffi::OsString">OsString</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>This method tests for <code>self</code> and <code>other</code> values to be equal, and is used
by <code>==</code>.</div></details><details class="toggle method-toggle" open><summary><section id="method.ne-9" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="https://doc.rust-lang.org/1.80.1/src/core/cmp.rs.html#263">source</a></span><a href="#method.ne-9" class="anchor">Â§</a><h4 class="code-header">fn <a href="cmp/trait.PartialEq.html#method.ne" class="fn">ne</a>(&amp;self, other: <a class="primitive" href="primitive.reference.html">&amp;Rhs</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>This method tests for <code>!=</code>. The default implementation is almost always
sufficient, and should not be overridden without very good reason.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-PartialEq%3COsString%3E-for-str" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="../src/std/ffi/os_str.rs.html#649-654">source</a></span><a href="#impl-PartialEq%3COsString%3E-for-str" class="anchor">Â§</a><h3 class="code-header">impl <a class="trait" href="cmp/trait.PartialEq.html" title="trait std::cmp::PartialEq">PartialEq</a>&lt;<a class="struct" href="ffi/struct.OsString.html" title="struct std::ffi::OsString">OsString</a>&gt; for <a class="primitive" href="primitive.str.html">str</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.eq-10" class="method trait-impl"><a class="src rightside" href="../src/std/ffi/os_str.rs.html#651-653">source</a><a href="#method.eq-10" class="anchor">Â§</a><h4 class="code-header">fn <a href="cmp/trait.PartialEq.html#tymethod.eq" class="fn">eq</a>(&amp;self, other: &amp;<a class="struct" href="ffi/struct.OsString.html" title="struct std::ffi::OsString">OsString</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>This method tests for <code>self</code> and <code>other</code> values to be equal, and is used
by <code>==</code>.</div></details><details class="toggle method-toggle" open><summary><section id="method.ne-10" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="https://doc.rust-lang.org/1.80.1/src/core/cmp.rs.html#263">source</a></span><a href="#method.ne-10" class="anchor">Â§</a><h4 class="code-header">fn <a href="cmp/trait.PartialEq.html#method.ne" class="fn">ne</a>(&amp;self, other: <a class="primitive" href="primitive.reference.html">&amp;Rhs</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>This method tests for <code>!=</code>. The default implementation is almost always
sufficient, and should not be overridden without very good reason.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-PartialEq%3CString%3E-for-%26str" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="../src/alloc/string.rs.html#2352">source</a></span><a href="#impl-PartialEq%3CString%3E-for-%26str" class="anchor">Â§</a><h3 class="code-header">impl&lt;'a, 'b&gt; <a class="trait" href="cmp/trait.PartialEq.html" title="trait std::cmp::PartialEq">PartialEq</a>&lt;<a class="struct" href="string/struct.String.html" title="struct std::string::String">String</a>&gt; for &amp;'a <a class="primitive" href="primitive.str.html">str</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.eq-8" class="method trait-impl"><a class="src rightside" href="../src/alloc/string.rs.html#2352">source</a><a href="#method.eq-8" class="anchor">Â§</a><h4 class="code-header">fn <a href="cmp/trait.PartialEq.html#tymethod.eq" class="fn">eq</a>(&amp;self, other: &amp;<a class="struct" href="string/struct.String.html" title="struct std::string::String">String</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>This method tests for <code>self</code> and <code>other</code> values to be equal, and is used
by <code>==</code>.</div></details><details class="toggle method-toggle" open><summary><section id="method.ne-8" class="method trait-impl"><a class="src rightside" href="../src/alloc/string.rs.html#2352">source</a><a href="#method.ne-8" class="anchor">Â§</a><h4 class="code-header">fn <a href="cmp/trait.PartialEq.html#method.ne" class="fn">ne</a>(&amp;self, other: &amp;<a class="struct" href="string/struct.String.html" title="struct std::string::String">String</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>This method tests for <code>!=</code>. The default implementation is almost always
sufficient, and should not be overridden without very good reason.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-PartialEq%3CString%3E-for-str" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="../src/alloc/string.rs.html#2351">source</a></span><a href="#impl-PartialEq%3CString%3E-for-str" class="anchor">Â§</a><h3 class="code-header">impl&lt;'a, 'b&gt; <a class="trait" href="cmp/trait.PartialEq.html" title="trait std::cmp::PartialEq">PartialEq</a>&lt;<a class="struct" href="string/struct.String.html" title="struct std::string::String">String</a>&gt; for <a class="primitive" href="primitive.str.html">str</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.eq-5" class="method trait-impl"><a class="src rightside" href="../src/alloc/string.rs.html#2351">source</a><a href="#method.eq-5" class="anchor">Â§</a><h4 class="code-header">fn <a href="cmp/trait.PartialEq.html#tymethod.eq" class="fn">eq</a>(&amp;self, other: &amp;<a class="struct" href="string/struct.String.html" title="struct std::string::String">String</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>This method tests for <code>self</code> and <code>other</code> values to be equal, and is used
by <code>==</code>.</div></details><details class="toggle method-toggle" open><summary><section id="method.ne-5" class="method trait-impl"><a class="src rightside" href="../src/alloc/string.rs.html#2351">source</a><a href="#method.ne-5" class="anchor">Â§</a><h4 class="code-header">fn <a href="cmp/trait.PartialEq.html#method.ne" class="fn">ne</a>(&amp;self, other: &amp;<a class="struct" href="string/struct.String.html" title="struct std::string::String">String</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>This method tests for <code>!=</code>. The default implementation is almost always
sufficient, and should not be overridden without very good reason.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-PartialEq%3Cstr%3E-for-Cow%3C'a,+str%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="../src/alloc/string.rs.html#2354">source</a></span><a href="#impl-PartialEq%3Cstr%3E-for-Cow%3C'a,+str%3E" class="anchor">Â§</a><h3 class="code-header">impl&lt;'a, 'b&gt; <a class="trait" href="cmp/trait.PartialEq.html" title="trait std::cmp::PartialEq">PartialEq</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt; for <a class="enum" href="borrow/enum.Cow.html" title="enum std::borrow::Cow">Cow</a>&lt;'a, <a class="primitive" href="primitive.str.html">str</a>&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.eq-1" class="method trait-impl"><a class="src rightside" href="../src/alloc/string.rs.html#2354">source</a><a href="#method.eq-1" class="anchor">Â§</a><h4 class="code-header">fn <a href="cmp/trait.PartialEq.html#tymethod.eq" class="fn">eq</a>(&amp;self, other: &amp;<a class="primitive" href="primitive.str.html">str</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>This method tests for <code>self</code> and <code>other</code> values to be equal, and is used
by <code>==</code>.</div></details><details class="toggle method-toggle" open><summary><section id="method.ne-1" class="method trait-impl"><a class="src rightside" href="../src/alloc/string.rs.html#2354">source</a><a href="#method.ne-1" class="anchor">Â§</a><h4 class="code-header">fn <a href="cmp/trait.PartialEq.html#method.ne" class="fn">ne</a>(&amp;self, other: &amp;<a class="primitive" href="primitive.str.html">str</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>This method tests for <code>!=</code>. The default implementation is almost always
sufficient, and should not be overridden without very good reason.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-PartialEq%3Cstr%3E-for-OsStr" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="../src/std/ffi/os_str.rs.html#1364-1369">source</a></span><a href="#impl-PartialEq%3Cstr%3E-for-OsStr" class="anchor">Â§</a><h3 class="code-header">impl <a class="trait" href="cmp/trait.PartialEq.html" title="trait std::cmp::PartialEq">PartialEq</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt; for <a class="struct" href="ffi/struct.OsStr.html" title="struct std::ffi::OsStr">OsStr</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.eq-14" class="method trait-impl"><a class="src rightside" href="../src/std/ffi/os_str.rs.html#1366-1368">source</a><a href="#method.eq-14" class="anchor">Â§</a><h4 class="code-header">fn <a href="cmp/trait.PartialEq.html#tymethod.eq" class="fn">eq</a>(&amp;self, other: &amp;<a class="primitive" href="primitive.str.html">str</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>This method tests for <code>self</code> and <code>other</code> values to be equal, and is used
by <code>==</code>.</div></details><details class="toggle method-toggle" open><summary><section id="method.ne-14" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="https://doc.rust-lang.org/1.80.1/src/core/cmp.rs.html#263">source</a></span><a href="#method.ne-14" class="anchor">Â§</a><h4 class="code-header">fn <a href="cmp/trait.PartialEq.html#method.ne" class="fn">ne</a>(&amp;self, other: <a class="primitive" href="primitive.reference.html">&amp;Rhs</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>This method tests for <code>!=</code>. The default implementation is almost always
sufficient, and should not be overridden without very good reason.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-PartialEq%3Cstr%3E-for-OsString" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="../src/std/ffi/os_str.rs.html#641-646">source</a></span><a href="#impl-PartialEq%3Cstr%3E-for-OsString" class="anchor">Â§</a><h3 class="code-header">impl <a class="trait" href="cmp/trait.PartialEq.html" title="trait std::cmp::PartialEq">PartialEq</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt; for <a class="struct" href="ffi/struct.OsString.html" title="struct std::ffi::OsString">OsString</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.eq-13" class="method trait-impl"><a class="src rightside" href="../src/std/ffi/os_str.rs.html#643-645">source</a><a href="#method.eq-13" class="anchor">Â§</a><h4 class="code-header">fn <a href="cmp/trait.PartialEq.html#tymethod.eq" class="fn">eq</a>(&amp;self, other: &amp;<a class="primitive" href="primitive.str.html">str</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>This method tests for <code>self</code> and <code>other</code> values to be equal, and is used
by <code>==</code>.</div></details><details class="toggle method-toggle" open><summary><section id="method.ne-13" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="https://doc.rust-lang.org/1.80.1/src/core/cmp.rs.html#263">source</a></span><a href="#method.ne-13" class="anchor">Â§</a><h4 class="code-header">fn <a href="cmp/trait.PartialEq.html#method.ne" class="fn">ne</a>(&amp;self, other: <a class="primitive" href="primitive.reference.html">&amp;Rhs</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>This method tests for <code>!=</code>. The default implementation is almost always
sufficient, and should not be overridden without very good reason.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-PartialEq%3Cstr%3E-for-String" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="../src/alloc/string.rs.html#2351">source</a></span><a href="#impl-PartialEq%3Cstr%3E-for-String" class="anchor">Â§</a><h3 class="code-header">impl&lt;'a, 'b&gt; <a class="trait" href="cmp/trait.PartialEq.html" title="trait std::cmp::PartialEq">PartialEq</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt; for <a class="struct" href="string/struct.String.html" title="struct std::string::String">String</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.eq-4" class="method trait-impl"><a class="src rightside" href="../src/alloc/string.rs.html#2351">source</a><a href="#method.eq-4" class="anchor">Â§</a><h4 class="code-header">fn <a href="cmp/trait.PartialEq.html#tymethod.eq" class="fn">eq</a>(&amp;self, other: &amp;<a class="primitive" href="primitive.str.html">str</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>This method tests for <code>self</code> and <code>other</code> values to be equal, and is used
by <code>==</code>.</div></details><details class="toggle method-toggle" open><summary><section id="method.ne-4" class="method trait-impl"><a class="src rightside" href="../src/alloc/string.rs.html#2351">source</a><a href="#method.ne-4" class="anchor">Â§</a><h4 class="code-header">fn <a href="cmp/trait.PartialEq.html#method.ne" class="fn">ne</a>(&amp;self, other: &amp;<a class="primitive" href="primitive.str.html">str</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>This method tests for <code>!=</code>. The default implementation is almost always
sufficient, and should not be overridden without very good reason.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-PartialEq-for-str" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="https://doc.rust-lang.org/1.80.1/src/core/str/traits.rs.html#28">source</a></span><a href="#impl-PartialEq-for-str" class="anchor">Â§</a><h3 class="code-header">impl <a class="trait" href="cmp/trait.PartialEq.html" title="trait std::cmp::PartialEq">PartialEq</a> for <a class="primitive" href="primitive.str.html">str</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.eq" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/str/traits.rs.html#30">source</a><a href="#method.eq" class="anchor">Â§</a><h4 class="code-header">fn <a href="cmp/trait.PartialEq.html#tymethod.eq" class="fn">eq</a>(&amp;self, other: &amp;<a class="primitive" href="primitive.str.html">str</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>This method tests for <code>self</code> and <code>other</code> values to be equal, and is used
by <code>==</code>.</div></details><details class="toggle method-toggle" open><summary><section id="method.ne" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="https://doc.rust-lang.org/1.80.1/src/core/cmp.rs.html#263">source</a></span><a href="#method.ne" class="anchor">Â§</a><h4 class="code-header">fn <a href="cmp/trait.PartialEq.html#method.ne" class="fn">ne</a>(&amp;self, other: <a class="primitive" href="primitive.reference.html">&amp;Rhs</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>This method tests for <code>!=</code>. The default implementation is almost always
sufficient, and should not be overridden without very good reason.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-PartialOrd%3Cstr%3E-for-OsStr" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="../src/std/ffi/os_str.rs.html#1407-1412">source</a></span><a href="#impl-PartialOrd%3Cstr%3E-for-OsStr" class="anchor">Â§</a><h3 class="code-header">impl <a class="trait" href="cmp/trait.PartialOrd.html" title="trait std::cmp::PartialOrd">PartialOrd</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt; for <a class="struct" href="ffi/struct.OsStr.html" title="struct std::ffi::OsStr">OsStr</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.partial_cmp-2" class="method trait-impl"><a class="src rightside" href="../src/std/ffi/os_str.rs.html#1409-1411">source</a><a href="#method.partial_cmp-2" class="anchor">Â§</a><h4 class="code-header">fn <a href="cmp/trait.PartialOrd.html#tymethod.partial_cmp" class="fn">partial_cmp</a>(&amp;self, other: &amp;<a class="primitive" href="primitive.str.html">str</a>) -&gt; <a class="enum" href="option/enum.Option.html" title="enum std::option::Option">Option</a>&lt;<a class="enum" href="cmp/enum.Ordering.html" title="enum std::cmp::Ordering">Ordering</a>&gt;</h4></section></summary><div class='docblock'>This method returns an ordering between <code>self</code> and <code>other</code> values if one exists. <a href="cmp/trait.PartialOrd.html#tymethod.partial_cmp">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.lt-2" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="https://doc.rust-lang.org/1.80.1/src/core/cmp.rs.html#1180">source</a></span><a href="#method.lt-2" class="anchor">Â§</a><h4 class="code-header">fn <a href="cmp/trait.PartialOrd.html#method.lt" class="fn">lt</a>(&amp;self, other: <a class="primitive" href="primitive.reference.html">&amp;Rhs</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>This method tests less than (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;</code> operator. <a href="cmp/trait.PartialOrd.html#method.lt">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.le-2" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="https://doc.rust-lang.org/1.80.1/src/core/cmp.rs.html#1198">source</a></span><a href="#method.le-2" class="anchor">Â§</a><h4 class="code-header">fn <a href="cmp/trait.PartialOrd.html#method.le" class="fn">le</a>(&amp;self, other: <a class="primitive" href="primitive.reference.html">&amp;Rhs</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>This method tests less than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;=</code>
operator. <a href="cmp/trait.PartialOrd.html#method.le">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.gt-2" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="https://doc.rust-lang.org/1.80.1/src/core/cmp.rs.html#1215">source</a></span><a href="#method.gt-2" class="anchor">Â§</a><h4 class="code-header">fn <a href="cmp/trait.PartialOrd.html#method.gt" class="fn">gt</a>(&amp;self, other: <a class="primitive" href="primitive.reference.html">&amp;Rhs</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>This method tests greater than (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;</code> operator. <a href="cmp/trait.PartialOrd.html#method.gt">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.ge-2" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="https://doc.rust-lang.org/1.80.1/src/core/cmp.rs.html#1233">source</a></span><a href="#method.ge-2" class="anchor">Â§</a><h4 class="code-header">fn <a href="cmp/trait.PartialOrd.html#method.ge" class="fn">ge</a>(&amp;self, other: <a class="primitive" href="primitive.reference.html">&amp;Rhs</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>This method tests greater than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;=</code>
operator. <a href="cmp/trait.PartialOrd.html#method.ge">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-PartialOrd%3Cstr%3E-for-OsString" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="../src/std/ffi/os_str.rs.html#700-705">source</a></span><a href="#impl-PartialOrd%3Cstr%3E-for-OsString" class="anchor">Â§</a><h3 class="code-header">impl <a class="trait" href="cmp/trait.PartialOrd.html" title="trait std::cmp::PartialOrd">PartialOrd</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt; for <a class="struct" href="ffi/struct.OsString.html" title="struct std::ffi::OsString">OsString</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.partial_cmp-1" class="method trait-impl"><a class="src rightside" href="../src/std/ffi/os_str.rs.html#702-704">source</a><a href="#method.partial_cmp-1" class="anchor">Â§</a><h4 class="code-header">fn <a href="cmp/trait.PartialOrd.html#tymethod.partial_cmp" class="fn">partial_cmp</a>(&amp;self, other: &amp;<a class="primitive" href="primitive.str.html">str</a>) -&gt; <a class="enum" href="option/enum.Option.html" title="enum std::option::Option">Option</a>&lt;<a class="enum" href="cmp/enum.Ordering.html" title="enum std::cmp::Ordering">Ordering</a>&gt;</h4></section></summary><div class='docblock'>This method returns an ordering between <code>self</code> and <code>other</code> values if one exists. <a href="cmp/trait.PartialOrd.html#tymethod.partial_cmp">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.lt-1" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="https://doc.rust-lang.org/1.80.1/src/core/cmp.rs.html#1180">source</a></span><a href="#method.lt-1" class="anchor">Â§</a><h4 class="code-header">fn <a href="cmp/trait.PartialOrd.html#method.lt" class="fn">lt</a>(&amp;self, other: <a class="primitive" href="primitive.reference.html">&amp;Rhs</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>This method tests less than (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;</code> operator. <a href="cmp/trait.PartialOrd.html#method.lt">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.le-1" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="https://doc.rust-lang.org/1.80.1/src/core/cmp.rs.html#1198">source</a></span><a href="#method.le-1" class="anchor">Â§</a><h4 class="code-header">fn <a href="cmp/trait.PartialOrd.html#method.le" class="fn">le</a>(&amp;self, other: <a class="primitive" href="primitive.reference.html">&amp;Rhs</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>This method tests less than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;=</code>
operator. <a href="cmp/trait.PartialOrd.html#method.le">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.gt-1" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="https://doc.rust-lang.org/1.80.1/src/core/cmp.rs.html#1215">source</a></span><a href="#method.gt-1" class="anchor">Â§</a><h4 class="code-header">fn <a href="cmp/trait.PartialOrd.html#method.gt" class="fn">gt</a>(&amp;self, other: <a class="primitive" href="primitive.reference.html">&amp;Rhs</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>This method tests greater than (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;</code> operator. <a href="cmp/trait.PartialOrd.html#method.gt">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.ge-1" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="https://doc.rust-lang.org/1.80.1/src/core/cmp.rs.html#1233">source</a></span><a href="#method.ge-1" class="anchor">Â§</a><h4 class="code-header">fn <a href="cmp/trait.PartialOrd.html#method.ge" class="fn">ge</a>(&amp;self, other: <a class="primitive" href="primitive.reference.html">&amp;Rhs</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>This method tests greater than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;=</code>
operator. <a href="cmp/trait.PartialOrd.html#method.ge">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-PartialOrd-for-str" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="https://doc.rust-lang.org/1.80.1/src/core/str/traits.rs.html#46">source</a></span><a href="#impl-PartialOrd-for-str" class="anchor">Â§</a><h3 class="code-header">impl <a class="trait" href="cmp/trait.PartialOrd.html" title="trait std::cmp::PartialOrd">PartialOrd</a> for <a class="primitive" href="primitive.str.html">str</a></h3></section></summary><div class="docblock"><p>Implements comparison operations on strings.</p>
<p>Strings are compared <a href="cmp/trait.Ord.html#lexicographical-comparison" title="trait std::cmp::Ord">lexicographically</a> by their byte values. This compares Unicode code
points based on their positions in the code charts. This is not necessarily the same as
â€œalphabeticalâ€ order, which varies by language and locale. Comparing strings according to
culturally-accepted standards requires locale-specific data that is outside the scope of
the <code>str</code> type.</p>
</div><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.partial_cmp" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/str/traits.rs.html#48">source</a><a href="#method.partial_cmp" class="anchor">Â§</a><h4 class="code-header">fn <a href="cmp/trait.PartialOrd.html#tymethod.partial_cmp" class="fn">partial_cmp</a>(&amp;self, other: &amp;<a class="primitive" href="primitive.str.html">str</a>) -&gt; <a class="enum" href="option/enum.Option.html" title="enum std::option::Option">Option</a>&lt;<a class="enum" href="cmp/enum.Ordering.html" title="enum std::cmp::Ordering">Ordering</a>&gt;</h4></section></summary><div class='docblock'>This method returns an ordering between <code>self</code> and <code>other</code> values if one exists. <a href="cmp/trait.PartialOrd.html#tymethod.partial_cmp">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.lt" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="https://doc.rust-lang.org/1.80.1/src/core/cmp.rs.html#1180">source</a></span><a href="#method.lt" class="anchor">Â§</a><h4 class="code-header">fn <a href="cmp/trait.PartialOrd.html#method.lt" class="fn">lt</a>(&amp;self, other: <a class="primitive" href="primitive.reference.html">&amp;Rhs</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>This method tests less than (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;</code> operator. <a href="cmp/trait.PartialOrd.html#method.lt">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.le" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="https://doc.rust-lang.org/1.80.1/src/core/cmp.rs.html#1198">source</a></span><a href="#method.le" class="anchor">Â§</a><h4 class="code-header">fn <a href="cmp/trait.PartialOrd.html#method.le" class="fn">le</a>(&amp;self, other: <a class="primitive" href="primitive.reference.html">&amp;Rhs</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>This method tests less than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;=</code>
operator. <a href="cmp/trait.PartialOrd.html#method.le">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.gt" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="https://doc.rust-lang.org/1.80.1/src/core/cmp.rs.html#1215">source</a></span><a href="#method.gt" class="anchor">Â§</a><h4 class="code-header">fn <a href="cmp/trait.PartialOrd.html#method.gt" class="fn">gt</a>(&amp;self, other: <a class="primitive" href="primitive.reference.html">&amp;Rhs</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>This method tests greater than (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;</code> operator. <a href="cmp/trait.PartialOrd.html#method.gt">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.ge" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="https://doc.rust-lang.org/1.80.1/src/core/cmp.rs.html#1233">source</a></span><a href="#method.ge" class="anchor">Â§</a><h4 class="code-header">fn <a href="cmp/trait.PartialOrd.html#method.ge" class="fn">ge</a>(&amp;self, other: <a class="primitive" href="primitive.reference.html">&amp;Rhs</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>This method tests greater than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;=</code>
operator. <a href="cmp/trait.PartialOrd.html#method.ge">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Pattern%3C'a%3E-for-%26str" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/str/pattern.rs.html#952">source</a><a href="#impl-Pattern%3C'a%3E-for-%26str" class="anchor">Â§</a><h3 class="code-header">impl&lt;'a, 'b&gt; <a class="trait" href="str/pattern/trait.Pattern.html" title="trait std::str::pattern::Pattern">Pattern</a>&lt;'a&gt; for &amp;'b <a class="primitive" href="primitive.str.html">str</a></h3></section></summary><div class="docblock"><p>Non-allocating substring search.</p>
<p>Will handle the pattern <code>&quot;&quot;</code> as returning empty matches at each character
boundary.</p>
<h4 id="examples-75"><a class="doc-anchor" href="#examples-75">Â§</a>Examples</h4>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(<span class="string">"Hello world"</span>.find(<span class="string">"world"</span>), <span class="prelude-val">Some</span>(<span class="number">6</span>));</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++assert_eq!(%22Hello+world%22.find(%22world%22),+Some(6));%0A%7D&amp;edition=2021">Run</a></div>
</div><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.is_prefix_of" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/str/pattern.rs.html#962">source</a><a href="#method.is_prefix_of" class="anchor">Â§</a><h4 class="code-header">fn <a href="str/pattern/trait.Pattern.html#method.is_prefix_of" class="fn">is_prefix_of</a>(self, haystack: &amp;'a <a class="primitive" href="primitive.str.html">str</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>pattern</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/27721">#27721</a>)</span></div></span></summary><div class="docblock"><p>Checks whether the pattern matches at the front of the haystack.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.is_contained_in" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/str/pattern.rs.html#968">source</a><a href="#method.is_contained_in" class="anchor">Â§</a><h4 class="code-header">fn <a href="str/pattern/trait.Pattern.html#method.is_contained_in" class="fn">is_contained_in</a>(self, haystack: &amp;'a <a class="primitive" href="primitive.str.html">str</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>pattern</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/27721">#27721</a>)</span></div></span></summary><div class="docblock"><p>Checks whether the pattern matches anywhere in the haystack</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.strip_prefix_of" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/str/pattern.rs.html#994">source</a><a href="#method.strip_prefix_of" class="anchor">Â§</a><h4 class="code-header">fn <a href="str/pattern/trait.Pattern.html#method.strip_prefix_of" class="fn">strip_prefix_of</a>(self, haystack: &amp;'a <a class="primitive" href="primitive.str.html">str</a>) -&gt; <a class="enum" href="option/enum.Option.html" title="enum std::option::Option">Option</a>&lt;&amp;'a <a class="primitive" href="primitive.str.html">str</a>&gt;</h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>pattern</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/27721">#27721</a>)</span></div></span></summary><div class="docblock"><p>Removes the pattern from the front of haystack, if it matches.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.is_suffix_of" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/str/pattern.rs.html#1005">source</a><a href="#method.is_suffix_of" class="anchor">Â§</a><h4 class="code-header">fn <a href="str/pattern/trait.Pattern.html#method.is_suffix_of" class="fn">is_suffix_of</a>(self, haystack: &amp;'a <a class="primitive" href="primitive.str.html">str</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>pattern</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/27721">#27721</a>)</span></div></span></summary><div class="docblock"><p>Checks whether the pattern matches at the back of the haystack.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.strip_suffix_of" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/str/pattern.rs.html#1011">source</a><a href="#method.strip_suffix_of" class="anchor">Â§</a><h4 class="code-header">fn <a href="str/pattern/trait.Pattern.html#method.strip_suffix_of" class="fn">strip_suffix_of</a>(self, haystack: &amp;'a <a class="primitive" href="primitive.str.html">str</a>) -&gt; <a class="enum" href="option/enum.Option.html" title="enum std::option::Option">Option</a>&lt;&amp;'a <a class="primitive" href="primitive.str.html">str</a>&gt;</h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>pattern</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/27721">#27721</a>)</span></div></span></summary><div class="docblock"><p>Removes the pattern from the back of haystack, if it matches.</p>
</div></details><details class="toggle" open><summary><section id="associatedtype.Searcher" class="associatedtype trait-impl"><a href="#associatedtype.Searcher" class="anchor">Â§</a><h4 class="code-header">type <a href="str/pattern/trait.Pattern.html#associatedtype.Searcher" class="associatedtype">Searcher</a> = <a class="struct" href="str/pattern/struct.StrSearcher.html" title="struct std::str::pattern::StrSearcher">StrSearcher</a>&lt;'a, 'b&gt;</h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>pattern</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/27721">#27721</a>)</span></div></span><div class='docblock'>Associated searcher for this pattern</div></details><details class="toggle method-toggle" open><summary><section id="method.into_searcher" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/str/pattern.rs.html#956">source</a><a href="#method.into_searcher" class="anchor">Â§</a><h4 class="code-header">fn <a href="str/pattern/trait.Pattern.html#tymethod.into_searcher" class="fn">into_searcher</a>(self, haystack: &amp;'a <a class="primitive" href="primitive.str.html">str</a>) -&gt; <a class="struct" href="str/pattern/struct.StrSearcher.html" title="struct std::str::pattern::StrSearcher">StrSearcher</a>&lt;'a, 'b&gt;</h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>pattern</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/27721">#27721</a>)</span></div></span><div class='docblock'>Constructs the associated searcher from
<code>self</code> and the <code>haystack</code> to search in.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-SliceIndex%3Cstr%3E-for-(Bound%3Cusize%3E,+Bound%3Cusize%3E)" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.73.0">1.73.0</span> Â· <a class="src" href="https://doc.rust-lang.org/1.80.1/src/core/str/traits.rs.html#278">source</a></span><a href="#impl-SliceIndex%3Cstr%3E-for-(Bound%3Cusize%3E,+Bound%3Cusize%3E)" class="anchor">Â§</a><h3 class="code-header">impl <a class="trait" href="slice/trait.SliceIndex.html" title="trait std::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt; for (<a class="enum" href="ops/enum.Bound.html" title="enum std::ops::Bound">Bound</a>&lt;<a class="primitive" href="primitive.usize.html">usize</a>&gt;, <a class="enum" href="ops/enum.Bound.html" title="enum std::ops::Bound">Bound</a>&lt;<a class="primitive" href="primitive.usize.html">usize</a>&gt;)</h3></section></summary><div class="docblock"><p>Implements substring slicing for arbitrary bounds.</p>
<p>Returns a slice of the given string bounded by the byte indices
provided by each bound.</p>
<p>This operation is <em>O</em>(1).</p>
<h4 id="panics-4"><a class="doc-anchor" href="#panics-4">Â§</a>Panics</h4>
<p>Panics if <code>begin</code> or <code>end</code> (if it exists and once adjusted for
inclusion/exclusion) does not point to the starting byte offset of
a character (as defined by <code>is_char_boundary</code>), if <code>begin &gt; end</code>, or if
<code>end &gt; len</code>.</p>
</div><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Output-2" class="associatedtype trait-impl"><a href="#associatedtype.Output-2" class="anchor">Â§</a><h4 class="code-header">type <a href="slice/trait.SliceIndex.html#associatedtype.Output" class="associatedtype">Output</a> = <a class="primitive" href="primitive.str.html">str</a></h4></section></summary><div class='docblock'>The output type returned by methods.</div></details><details class="toggle method-toggle" open><summary><section id="method.get-2" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/str/traits.rs.html#282">source</a><a href="#method.get-2" class="anchor">Â§</a><h4 class="code-header">fn <a href="slice/trait.SliceIndex.html#tymethod.get" class="fn">get</a>(self, slice: &amp;<a class="primitive" href="primitive.str.html">str</a>) -&gt; <a class="enum" href="option/enum.Option.html" title="enum std::option::Option">Option</a>&lt;&amp;<a class="primitive" href="primitive.str.html">str</a>&gt;</h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span></div></span><div class='docblock'>Returns a shared reference to the output at this location, if in
bounds.</div></details><details class="toggle method-toggle" open><summary><section id="method.get_mut-2" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/str/traits.rs.html#287">source</a><a href="#method.get_mut-2" class="anchor">Â§</a><h4 class="code-header">fn <a href="slice/trait.SliceIndex.html#tymethod.get_mut" class="fn">get_mut</a>(self, slice: &amp;mut <a class="primitive" href="primitive.str.html">str</a>) -&gt; <a class="enum" href="option/enum.Option.html" title="enum std::option::Option">Option</a>&lt;&amp;mut <a class="primitive" href="primitive.str.html">str</a>&gt;</h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span></div></span><div class='docblock'>Returns a mutable reference to the output at this location, if in
bounds.</div></details><details class="toggle method-toggle" open><summary><section id="method.get_unchecked-2" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/str/traits.rs.html#292">source</a><a href="#method.get_unchecked-2" class="anchor">Â§</a><h4 class="code-header">unsafe fn <a href="slice/trait.SliceIndex.html#tymethod.get_unchecked" class="fn">get_unchecked</a>(self, slice: <a class="primitive" href="primitive.pointer.html">*const </a><a class="primitive" href="primitive.str.html">str</a>) -&gt; <a class="primitive" href="primitive.pointer.html">*const </a><a class="primitive" href="primitive.str.html">str</a></h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span></div></span><div class='docblock'>Returns a pointer to the output at this location, without
performing any bounds checking.
Calling this method with an out-of-bounds index or a dangling <code>slice</code> pointer
is <em><a href="https://doc.rust-lang.org/reference/behavior-considered-undefined.html">undefined behavior</a></em> even if the resulting pointer is not used.</div></details><details class="toggle method-toggle" open><summary><section id="method.get_unchecked_mut-2" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/str/traits.rs.html#299">source</a><a href="#method.get_unchecked_mut-2" class="anchor">Â§</a><h4 class="code-header">unsafe fn <a href="slice/trait.SliceIndex.html#tymethod.get_unchecked_mut" class="fn">get_unchecked_mut</a>(self, slice: <a class="primitive" href="primitive.pointer.html">*mut </a><a class="primitive" href="primitive.str.html">str</a>) -&gt; <a class="primitive" href="primitive.pointer.html">*mut </a><a class="primitive" href="primitive.str.html">str</a></h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span></div></span><div class='docblock'>Returns a mutable pointer to the output at this location, without
performing any bounds checking.
Calling this method with an out-of-bounds index or a dangling <code>slice</code> pointer
is <em><a href="https://doc.rust-lang.org/reference/behavior-considered-undefined.html">undefined behavior</a></em> even if the resulting pointer is not used.</div></details><details class="toggle method-toggle" open><summary><section id="method.index-2" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/str/traits.rs.html#306">source</a><a href="#method.index-2" class="anchor">Â§</a><h4 class="code-header">fn <a href="slice/trait.SliceIndex.html#tymethod.index" class="fn">index</a>(self, slice: &amp;<a class="primitive" href="primitive.str.html">str</a>) -&gt; &amp;<a class="primitive" href="primitive.str.html">str</a></h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span></div></span><div class='docblock'>Returns a shared reference to the output at this location, panicking
if out of bounds.</div></details><details class="toggle method-toggle" open><summary><section id="method.index_mut-1" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/str/traits.rs.html#311">source</a><a href="#method.index_mut-1" class="anchor">Â§</a><h4 class="code-header">fn <a href="slice/trait.SliceIndex.html#tymethod.index_mut" class="fn">index_mut</a>(self, slice: &amp;mut <a class="primitive" href="primitive.str.html">str</a>) -&gt; &amp;mut <a class="primitive" href="primitive.str.html">str</a></h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span></div></span><div class='docblock'>Returns a mutable reference to the output at this location, panicking
if out of bounds.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-SliceIndex%3Cstr%3E-for-Range%3Cusize%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.20.0, const unstable">1.20.0 (const: unstable)</span> Â· <a class="src" href="https://doc.rust-lang.org/1.80.1/src/core/str/traits.rs.html#163">source</a></span><a href="#impl-SliceIndex%3Cstr%3E-for-Range%3Cusize%3E" class="anchor">Â§</a><h3 class="code-header">impl <a class="trait" href="slice/trait.SliceIndex.html" title="trait std::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt; for <a class="struct" href="ops/struct.Range.html" title="struct std::ops::Range">Range</a>&lt;<a class="primitive" href="primitive.usize.html">usize</a>&gt;</h3></section></summary><div class="docblock"><p>Implements substring slicing with syntax <code>&amp;self[begin .. end]</code> or <code>&amp;mut self[begin .. end]</code>.</p>
<p>Returns a slice of the given string from the byte range
[<code>begin</code>, <code>end</code>).</p>
<p>This operation is <em>O</em>(1).</p>
<p>Prior to 1.20.0, these indexing operations were still supported by
direct implementation of <code>Index</code> and <code>IndexMut</code>.</p>
<h4 id="panics-7"><a class="doc-anchor" href="#panics-7">Â§</a>Panics</h4>
<p>Panics if <code>begin</code> or <code>end</code> does not point to the starting byte offset of
a character (as defined by <code>is_char_boundary</code>), if <code>begin &gt; end</code>, or if
<code>end &gt; len</code>.</p>
<h4 id="examples-74"><a class="doc-anchor" href="#examples-74">Â§</a>Examples</h4>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>s = <span class="string">"LÃ¶we è€è™ LÃ©opard"</span>;
<span class="macro">assert_eq!</span>(<span class="kw-2">&amp;</span>s[<span class="number">0 </span>.. <span class="number">1</span>], <span class="string">"L"</span>);

<span class="macro">assert_eq!</span>(<span class="kw-2">&amp;</span>s[<span class="number">1 </span>.. <span class="number">9</span>], <span class="string">"Ã¶we è€"</span>);

<span class="comment">// these will panic:
// byte 2 lies within `Ã¶`:
// &amp;s[2 ..3];

// byte 8 lies within `è€`
// &amp;s[1 .. 8];

// byte 100 is outside the string
// &amp;s[3 .. 100];</span></code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+s+=+%22L%C3%B6we+%E8%80%81%E8%99%8E+L%C3%A9opard%22;%0A++++assert_eq!(%26s%5B0+..+1%5D,+%22L%22);%0A++++%0A++++assert_eq!(%26s%5B1+..+9%5D,+%22%C3%B6we+%E8%80%81%22);%0A++++%0A++++//+these+will+panic:%0A++++//+byte+2+lies+within+%60%C3%B6%60:%0A++++//+%26s%5B2+..3%5D;%0A++++%0A++++//+byte+8+lies+within+%60%E8%80%81%60%0A++++//+%26s%5B1+..+8%5D;%0A++++%0A++++//+byte+100+is+outside+the+string%0A++++//+%26s%5B3+..+100%5D;%0A%7D&amp;edition=2021">Run</a></div>
</div><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Output-5" class="associatedtype trait-impl"><a href="#associatedtype.Output-5" class="anchor">Â§</a><h4 class="code-header">type <a href="slice/trait.SliceIndex.html#associatedtype.Output" class="associatedtype">Output</a> = <a class="primitive" href="primitive.str.html">str</a></h4></section></summary><div class='docblock'>The output type returned by methods.</div></details><details class="toggle method-toggle" open><summary><section id="method.get-5" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/str/traits.rs.html#166">source</a><a href="#method.get-5" class="anchor">Â§</a><h4 class="code-header">fn <a href="slice/trait.SliceIndex.html#tymethod.get" class="fn">get</a>(self, slice: &amp;<a class="primitive" href="primitive.str.html">str</a>) -&gt; <a class="enum" href="option/enum.Option.html" title="enum std::option::Option">Option</a>&lt;&amp;&lt;<a class="struct" href="ops/struct.Range.html" title="struct std::ops::Range">Range</a>&lt;<a class="primitive" href="primitive.usize.html">usize</a>&gt; as <a class="trait" href="slice/trait.SliceIndex.html" title="trait std::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt;&gt;::<a class="associatedtype" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type std::slice::SliceIndex::Output">Output</a>&gt;</h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span></div></span><div class='docblock'>Returns a shared reference to the output at this location, if in
bounds.</div></details><details class="toggle method-toggle" open><summary><section id="method.get_mut-5" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/str/traits.rs.html#180">source</a><a href="#method.get_mut-5" class="anchor">Â§</a><h4 class="code-header">fn <a href="slice/trait.SliceIndex.html#tymethod.get_mut" class="fn">get_mut</a>(
    self,
    slice: &amp;mut <a class="primitive" href="primitive.str.html">str</a>,
) -&gt; <a class="enum" href="option/enum.Option.html" title="enum std::option::Option">Option</a>&lt;&amp;mut &lt;<a class="struct" href="ops/struct.Range.html" title="struct std::ops::Range">Range</a>&lt;<a class="primitive" href="primitive.usize.html">usize</a>&gt; as <a class="trait" href="slice/trait.SliceIndex.html" title="trait std::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt;&gt;::<a class="associatedtype" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type std::slice::SliceIndex::Output">Output</a>&gt;</h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span></div></span><div class='docblock'>Returns a mutable reference to the output at this location, if in
bounds.</div></details><details class="toggle method-toggle" open><summary><section id="method.get_unchecked-5" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/str/traits.rs.html#193">source</a><a href="#method.get_unchecked-5" class="anchor">Â§</a><h4 class="code-header">unsafe fn <a href="slice/trait.SliceIndex.html#tymethod.get_unchecked" class="fn">get_unchecked</a>(
    self,
    slice: <a class="primitive" href="primitive.pointer.html">*const </a><a class="primitive" href="primitive.str.html">str</a>,
) -&gt; <a class="primitive" href="primitive.pointer.html">*const </a>&lt;<a class="struct" href="ops/struct.Range.html" title="struct std::ops::Range">Range</a>&lt;<a class="primitive" href="primitive.usize.html">usize</a>&gt; as <a class="trait" href="slice/trait.SliceIndex.html" title="trait std::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt;&gt;::<a class="associatedtype" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type std::slice::SliceIndex::Output">Output</a></h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span></div></span><div class='docblock'>Returns a pointer to the output at this location, without
performing any bounds checking.
Calling this method with an out-of-bounds index or a dangling <code>slice</code> pointer
is <em><a href="https://doc.rust-lang.org/reference/behavior-considered-undefined.html">undefined behavior</a></em> even if the resulting pointer is not used.</div></details><details class="toggle method-toggle" open><summary><section id="method.get_unchecked_mut-5" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/str/traits.rs.html#220">source</a><a href="#method.get_unchecked_mut-5" class="anchor">Â§</a><h4 class="code-header">unsafe fn <a href="slice/trait.SliceIndex.html#tymethod.get_unchecked_mut" class="fn">get_unchecked_mut</a>(
    self,
    slice: <a class="primitive" href="primitive.pointer.html">*mut </a><a class="primitive" href="primitive.str.html">str</a>,
) -&gt; <a class="primitive" href="primitive.pointer.html">*mut </a>&lt;<a class="struct" href="ops/struct.Range.html" title="struct std::ops::Range">Range</a>&lt;<a class="primitive" href="primitive.usize.html">usize</a>&gt; as <a class="trait" href="slice/trait.SliceIndex.html" title="trait std::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt;&gt;::<a class="associatedtype" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type std::slice::SliceIndex::Output">Output</a></h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span></div></span><div class='docblock'>Returns a mutable pointer to the output at this location, without
performing any bounds checking.
Calling this method with an out-of-bounds index or a dangling <code>slice</code> pointer
is <em><a href="https://doc.rust-lang.org/reference/behavior-considered-undefined.html">undefined behavior</a></em> even if the resulting pointer is not used.</div></details><details class="toggle method-toggle" open><summary><section id="method.index-5" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/str/traits.rs.html#240">source</a><a href="#method.index-5" class="anchor">Â§</a><h4 class="code-header">fn <a href="slice/trait.SliceIndex.html#tymethod.index" class="fn">index</a>(self, slice: &amp;<a class="primitive" href="primitive.str.html">str</a>) -&gt; &amp;&lt;<a class="struct" href="ops/struct.Range.html" title="struct std::ops::Range">Range</a>&lt;<a class="primitive" href="primitive.usize.html">usize</a>&gt; as <a class="trait" href="slice/trait.SliceIndex.html" title="trait std::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt;&gt;::<a class="associatedtype" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type std::slice::SliceIndex::Output">Output</a> <a href="#" class="tooltip" data-notable-ty="&amp;&lt;Range&lt;usize&gt; as SliceIndex&lt;str&gt;&gt;::Output">â“˜</a></h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span></div></span><div class='docblock'>Returns a shared reference to the output at this location, panicking
if out of bounds.</div></details><details class="toggle method-toggle" open><summary><section id="method.index_mut-4" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/str/traits.rs.html#248">source</a><a href="#method.index_mut-4" class="anchor">Â§</a><h4 class="code-header">fn <a href="slice/trait.SliceIndex.html#tymethod.index_mut" class="fn">index_mut</a>(
    self,
    slice: &amp;mut <a class="primitive" href="primitive.str.html">str</a>,
) -&gt; &amp;mut &lt;<a class="struct" href="ops/struct.Range.html" title="struct std::ops::Range">Range</a>&lt;<a class="primitive" href="primitive.usize.html">usize</a>&gt; as <a class="trait" href="slice/trait.SliceIndex.html" title="trait std::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt;&gt;::<a class="associatedtype" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type std::slice::SliceIndex::Output">Output</a> <a href="#" class="tooltip" data-notable-ty="&amp;mut &lt;Range&lt;usize&gt; as SliceIndex&lt;str&gt;&gt;::Output">â“˜</a></h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span></div></span><div class='docblock'>Returns a mutable reference to the output at this location, panicking
if out of bounds.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-SliceIndex%3Cstr%3E-for-RangeFrom%3Cusize%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.20.0, const unstable">1.20.0 (const: unstable)</span> Â· <a class="src" href="https://doc.rust-lang.org/1.80.1/src/core/str/traits.rs.html#402">source</a></span><a href="#impl-SliceIndex%3Cstr%3E-for-RangeFrom%3Cusize%3E" class="anchor">Â§</a><h3 class="code-header">impl <a class="trait" href="slice/trait.SliceIndex.html" title="trait std::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt; for <a class="struct" href="ops/struct.RangeFrom.html" title="struct std::ops::RangeFrom">RangeFrom</a>&lt;<a class="primitive" href="primitive.usize.html">usize</a>&gt;</h3></section></summary><div class="docblock"><p>Implements substring slicing with syntax <code>&amp;self[begin ..]</code> or <code>&amp;mut self[begin ..]</code>.</p>
<p>Returns a slice of the given string from the byte range [<code>begin</code>, <code>len</code>).
Equivalent to <code>&amp;self[begin .. len]</code> or <code>&amp;mut self[begin .. len]</code>.</p>
<p>This operation is <em>O</em>(1).</p>
<p>Prior to 1.20.0, these indexing operations were still supported by
direct implementation of <code>Index</code> and <code>IndexMut</code>.</p>
<h4 id="panics-8"><a class="doc-anchor" href="#panics-8">Â§</a>Panics</h4>
<p>Panics if <code>begin</code> does not point to the starting byte offset of
a character (as defined by <code>is_char_boundary</code>), or if <code>begin &gt; len</code>.</p>
</div><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Output-6" class="associatedtype trait-impl"><a href="#associatedtype.Output-6" class="anchor">Â§</a><h4 class="code-header">type <a href="slice/trait.SliceIndex.html#associatedtype.Output" class="associatedtype">Output</a> = <a class="primitive" href="primitive.str.html">str</a></h4></section></summary><div class='docblock'>The output type returned by methods.</div></details><details class="toggle method-toggle" open><summary><section id="method.get-6" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/str/traits.rs.html#405">source</a><a href="#method.get-6" class="anchor">Â§</a><h4 class="code-header">fn <a href="slice/trait.SliceIndex.html#tymethod.get" class="fn">get</a>(
    self,
    slice: &amp;<a class="primitive" href="primitive.str.html">str</a>,
) -&gt; <a class="enum" href="option/enum.Option.html" title="enum std::option::Option">Option</a>&lt;&amp;&lt;<a class="struct" href="ops/struct.RangeFrom.html" title="struct std::ops::RangeFrom">RangeFrom</a>&lt;<a class="primitive" href="primitive.usize.html">usize</a>&gt; as <a class="trait" href="slice/trait.SliceIndex.html" title="trait std::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt;&gt;::<a class="associatedtype" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type std::slice::SliceIndex::Output">Output</a>&gt;</h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span></div></span><div class='docblock'>Returns a shared reference to the output at this location, if in
bounds.</div></details><details class="toggle method-toggle" open><summary><section id="method.get_mut-6" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/str/traits.rs.html#415">source</a><a href="#method.get_mut-6" class="anchor">Â§</a><h4 class="code-header">fn <a href="slice/trait.SliceIndex.html#tymethod.get_mut" class="fn">get_mut</a>(
    self,
    slice: &amp;mut <a class="primitive" href="primitive.str.html">str</a>,
) -&gt; <a class="enum" href="option/enum.Option.html" title="enum std::option::Option">Option</a>&lt;&amp;mut &lt;<a class="struct" href="ops/struct.RangeFrom.html" title="struct std::ops::RangeFrom">RangeFrom</a>&lt;<a class="primitive" href="primitive.usize.html">usize</a>&gt; as <a class="trait" href="slice/trait.SliceIndex.html" title="trait std::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt;&gt;::<a class="associatedtype" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type std::slice::SliceIndex::Output">Output</a>&gt;</h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span></div></span><div class='docblock'>Returns a mutable reference to the output at this location, if in
bounds.</div></details><details class="toggle method-toggle" open><summary><section id="method.get_unchecked-6" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/str/traits.rs.html#425">source</a><a href="#method.get_unchecked-6" class="anchor">Â§</a><h4 class="code-header">unsafe fn <a href="slice/trait.SliceIndex.html#tymethod.get_unchecked" class="fn">get_unchecked</a>(
    self,
    slice: <a class="primitive" href="primitive.pointer.html">*const </a><a class="primitive" href="primitive.str.html">str</a>,
) -&gt; <a class="primitive" href="primitive.pointer.html">*const </a>&lt;<a class="struct" href="ops/struct.RangeFrom.html" title="struct std::ops::RangeFrom">RangeFrom</a>&lt;<a class="primitive" href="primitive.usize.html">usize</a>&gt; as <a class="trait" href="slice/trait.SliceIndex.html" title="trait std::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt;&gt;::<a class="associatedtype" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type std::slice::SliceIndex::Output">Output</a></h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span></div></span><div class='docblock'>Returns a pointer to the output at this location, without
performing any bounds checking.
Calling this method with an out-of-bounds index or a dangling <code>slice</code> pointer
is <em><a href="https://doc.rust-lang.org/reference/behavior-considered-undefined.html">undefined behavior</a></em> even if the resulting pointer is not used.</div></details><details class="toggle method-toggle" open><summary><section id="method.get_unchecked_mut-6" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/str/traits.rs.html#431">source</a><a href="#method.get_unchecked_mut-6" class="anchor">Â§</a><h4 class="code-header">unsafe fn <a href="slice/trait.SliceIndex.html#tymethod.get_unchecked_mut" class="fn">get_unchecked_mut</a>(
    self,
    slice: <a class="primitive" href="primitive.pointer.html">*mut </a><a class="primitive" href="primitive.str.html">str</a>,
) -&gt; <a class="primitive" href="primitive.pointer.html">*mut </a>&lt;<a class="struct" href="ops/struct.RangeFrom.html" title="struct std::ops::RangeFrom">RangeFrom</a>&lt;<a class="primitive" href="primitive.usize.html">usize</a>&gt; as <a class="trait" href="slice/trait.SliceIndex.html" title="trait std::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt;&gt;::<a class="associatedtype" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type std::slice::SliceIndex::Output">Output</a></h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span></div></span><div class='docblock'>Returns a mutable pointer to the output at this location, without
performing any bounds checking.
Calling this method with an out-of-bounds index or a dangling <code>slice</code> pointer
is <em><a href="https://doc.rust-lang.org/reference/behavior-considered-undefined.html">undefined behavior</a></em> even if the resulting pointer is not used.</div></details><details class="toggle method-toggle" open><summary><section id="method.index-6" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/str/traits.rs.html#437">source</a><a href="#method.index-6" class="anchor">Â§</a><h4 class="code-header">fn <a href="slice/trait.SliceIndex.html#tymethod.index" class="fn">index</a>(self, slice: &amp;<a class="primitive" href="primitive.str.html">str</a>) -&gt; &amp;&lt;<a class="struct" href="ops/struct.RangeFrom.html" title="struct std::ops::RangeFrom">RangeFrom</a>&lt;<a class="primitive" href="primitive.usize.html">usize</a>&gt; as <a class="trait" href="slice/trait.SliceIndex.html" title="trait std::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt;&gt;::<a class="associatedtype" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type std::slice::SliceIndex::Output">Output</a> <a href="#" class="tooltip" data-notable-ty="&amp;&lt;RangeFrom&lt;usize&gt; as SliceIndex&lt;str&gt;&gt;::Output">â“˜</a></h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span></div></span><div class='docblock'>Returns a shared reference to the output at this location, panicking
if out of bounds.</div></details><details class="toggle method-toggle" open><summary><section id="method.index_mut-5" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/str/traits.rs.html#445">source</a><a href="#method.index_mut-5" class="anchor">Â§</a><h4 class="code-header">fn <a href="slice/trait.SliceIndex.html#tymethod.index_mut" class="fn">index_mut</a>(
    self,
    slice: &amp;mut <a class="primitive" href="primitive.str.html">str</a>,
) -&gt; &amp;mut &lt;<a class="struct" href="ops/struct.RangeFrom.html" title="struct std::ops::RangeFrom">RangeFrom</a>&lt;<a class="primitive" href="primitive.usize.html">usize</a>&gt; as <a class="trait" href="slice/trait.SliceIndex.html" title="trait std::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt;&gt;::<a class="associatedtype" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type std::slice::SliceIndex::Output">Output</a> <a href="#" class="tooltip" data-notable-ty="&amp;mut &lt;RangeFrom&lt;usize&gt; as SliceIndex&lt;str&gt;&gt;::Output">â“˜</a></h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span></div></span><div class='docblock'>Returns a mutable reference to the output at this location, panicking
if out of bounds.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-SliceIndex%3Cstr%3E-for-RangeFull" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.20.0, const unstable">1.20.0 (const: unstable)</span> Â· <a class="src" href="https://doc.rust-lang.org/1.80.1/src/core/str/traits.rs.html#98">source</a></span><a href="#impl-SliceIndex%3Cstr%3E-for-RangeFull" class="anchor">Â§</a><h3 class="code-header">impl <a class="trait" href="slice/trait.SliceIndex.html" title="trait std::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt; for <a class="struct" href="ops/struct.RangeFull.html" title="struct std::ops::RangeFull">RangeFull</a></h3></section></summary><div class="docblock"><p>Implements substring slicing with syntax <code>&amp;self[..]</code> or <code>&amp;mut self[..]</code>.</p>
<p>Returns a slice of the whole string, i.e., returns <code>&amp;self</code> or <code>&amp;mut self</code>. Equivalent to <code>&amp;self[0 .. len]</code> or <code>&amp;mut self[0 .. len]</code>. Unlike
other indexing operations, this can never panic.</p>
<p>This operation is <em>O</em>(1).</p>
<p>Prior to 1.20.0, these indexing operations were still supported by
direct implementation of <code>Index</code> and <code>IndexMut</code>.</p>
<p>Equivalent to <code>&amp;self[0 .. len]</code> or <code>&amp;mut self[0 .. len]</code>.</p>
</div><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Output-7" class="associatedtype trait-impl"><a href="#associatedtype.Output-7" class="anchor">Â§</a><h4 class="code-header">type <a href="slice/trait.SliceIndex.html#associatedtype.Output" class="associatedtype">Output</a> = <a class="primitive" href="primitive.str.html">str</a></h4></section></summary><div class='docblock'>The output type returned by methods.</div></details><details class="toggle method-toggle" open><summary><section id="method.get-7" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/str/traits.rs.html#101">source</a><a href="#method.get-7" class="anchor">Â§</a><h4 class="code-header">fn <a href="slice/trait.SliceIndex.html#tymethod.get" class="fn">get</a>(self, slice: &amp;<a class="primitive" href="primitive.str.html">str</a>) -&gt; <a class="enum" href="option/enum.Option.html" title="enum std::option::Option">Option</a>&lt;&amp;&lt;<a class="struct" href="ops/struct.RangeFull.html" title="struct std::ops::RangeFull">RangeFull</a> as <a class="trait" href="slice/trait.SliceIndex.html" title="trait std::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt;&gt;::<a class="associatedtype" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type std::slice::SliceIndex::Output">Output</a>&gt;</h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span></div></span><div class='docblock'>Returns a shared reference to the output at this location, if in
bounds.</div></details><details class="toggle method-toggle" open><summary><section id="method.get_mut-7" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/str/traits.rs.html#105">source</a><a href="#method.get_mut-7" class="anchor">Â§</a><h4 class="code-header">fn <a href="slice/trait.SliceIndex.html#tymethod.get_mut" class="fn">get_mut</a>(
    self,
    slice: &amp;mut <a class="primitive" href="primitive.str.html">str</a>,
) -&gt; <a class="enum" href="option/enum.Option.html" title="enum std::option::Option">Option</a>&lt;&amp;mut &lt;<a class="struct" href="ops/struct.RangeFull.html" title="struct std::ops::RangeFull">RangeFull</a> as <a class="trait" href="slice/trait.SliceIndex.html" title="trait std::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt;&gt;::<a class="associatedtype" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type std::slice::SliceIndex::Output">Output</a>&gt;</h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span></div></span><div class='docblock'>Returns a mutable reference to the output at this location, if in
bounds.</div></details><details class="toggle method-toggle" open><summary><section id="method.get_unchecked-7" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/str/traits.rs.html#109">source</a><a href="#method.get_unchecked-7" class="anchor">Â§</a><h4 class="code-header">unsafe fn <a href="slice/trait.SliceIndex.html#tymethod.get_unchecked" class="fn">get_unchecked</a>(
    self,
    slice: <a class="primitive" href="primitive.pointer.html">*const </a><a class="primitive" href="primitive.str.html">str</a>,
) -&gt; <a class="primitive" href="primitive.pointer.html">*const </a>&lt;<a class="struct" href="ops/struct.RangeFull.html" title="struct std::ops::RangeFull">RangeFull</a> as <a class="trait" href="slice/trait.SliceIndex.html" title="trait std::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt;&gt;::<a class="associatedtype" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type std::slice::SliceIndex::Output">Output</a></h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span></div></span><div class='docblock'>Returns a pointer to the output at this location, without
performing any bounds checking.
Calling this method with an out-of-bounds index or a dangling <code>slice</code> pointer
is <em><a href="https://doc.rust-lang.org/reference/behavior-considered-undefined.html">undefined behavior</a></em> even if the resulting pointer is not used.</div></details><details class="toggle method-toggle" open><summary><section id="method.get_unchecked_mut-7" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/str/traits.rs.html#113">source</a><a href="#method.get_unchecked_mut-7" class="anchor">Â§</a><h4 class="code-header">unsafe fn <a href="slice/trait.SliceIndex.html#tymethod.get_unchecked_mut" class="fn">get_unchecked_mut</a>(
    self,
    slice: <a class="primitive" href="primitive.pointer.html">*mut </a><a class="primitive" href="primitive.str.html">str</a>,
) -&gt; <a class="primitive" href="primitive.pointer.html">*mut </a>&lt;<a class="struct" href="ops/struct.RangeFull.html" title="struct std::ops::RangeFull">RangeFull</a> as <a class="trait" href="slice/trait.SliceIndex.html" title="trait std::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt;&gt;::<a class="associatedtype" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type std::slice::SliceIndex::Output">Output</a></h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span></div></span><div class='docblock'>Returns a mutable pointer to the output at this location, without
performing any bounds checking.
Calling this method with an out-of-bounds index or a dangling <code>slice</code> pointer
is <em><a href="https://doc.rust-lang.org/reference/behavior-considered-undefined.html">undefined behavior</a></em> even if the resulting pointer is not used.</div></details><details class="toggle method-toggle" open><summary><section id="method.index-7" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/str/traits.rs.html#117">source</a><a href="#method.index-7" class="anchor">Â§</a><h4 class="code-header">fn <a href="slice/trait.SliceIndex.html#tymethod.index" class="fn">index</a>(self, slice: &amp;<a class="primitive" href="primitive.str.html">str</a>) -&gt; &amp;&lt;<a class="struct" href="ops/struct.RangeFull.html" title="struct std::ops::RangeFull">RangeFull</a> as <a class="trait" href="slice/trait.SliceIndex.html" title="trait std::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt;&gt;::<a class="associatedtype" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type std::slice::SliceIndex::Output">Output</a></h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span></div></span><div class='docblock'>Returns a shared reference to the output at this location, panicking
if out of bounds.</div></details><details class="toggle method-toggle" open><summary><section id="method.index_mut-6" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/str/traits.rs.html#121">source</a><a href="#method.index_mut-6" class="anchor">Â§</a><h4 class="code-header">fn <a href="slice/trait.SliceIndex.html#tymethod.index_mut" class="fn">index_mut</a>(
    self,
    slice: &amp;mut <a class="primitive" href="primitive.str.html">str</a>,
) -&gt; &amp;mut &lt;<a class="struct" href="ops/struct.RangeFull.html" title="struct std::ops::RangeFull">RangeFull</a> as <a class="trait" href="slice/trait.SliceIndex.html" title="trait std::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt;&gt;::<a class="associatedtype" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type std::slice::SliceIndex::Output">Output</a></h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span></div></span><div class='docblock'>Returns a mutable reference to the output at this location, panicking
if out of bounds.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-SliceIndex%3Cstr%3E-for-RangeInclusive%3Cusize%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.26.0, const unstable">1.26.0 (const: unstable)</span> Â· <a class="src" href="https://doc.rust-lang.org/1.80.1/src/core/str/traits.rs.html#474">source</a></span><a href="#impl-SliceIndex%3Cstr%3E-for-RangeInclusive%3Cusize%3E" class="anchor">Â§</a><h3 class="code-header">impl <a class="trait" href="slice/trait.SliceIndex.html" title="trait std::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt; for <a class="struct" href="ops/struct.RangeInclusive.html" title="struct std::ops::RangeInclusive">RangeInclusive</a>&lt;<a class="primitive" href="primitive.usize.html">usize</a>&gt;</h3></section></summary><div class="docblock"><p>Implements substring slicing with syntax <code>&amp;self[begin ..= end]</code> or <code>&amp;mut self[begin ..= end]</code>.</p>
<p>Returns a slice of the given string from the byte range
[<code>begin</code>, <code>end</code>]. Equivalent to <code>&amp;self [begin .. end + 1]</code> or <code>&amp;mut self[begin .. end + 1]</code>, except if <code>end</code> has the maximum value for
<code>usize</code>.</p>
<p>This operation is <em>O</em>(1).</p>
<h4 id="panics-3"><a class="doc-anchor" href="#panics-3">Â§</a>Panics</h4>
<p>Panics if <code>begin</code> does not point to the starting byte offset of
a character (as defined by <code>is_char_boundary</code>), if <code>end</code> does not point
to the ending byte offset of a character (<code>end + 1</code> is either a starting
byte offset or equal to <code>len</code>), if <code>begin &gt; end</code>, or if <code>end &gt;= len</code>.</p>
</div><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Output-1" class="associatedtype trait-impl"><a href="#associatedtype.Output-1" class="anchor">Â§</a><h4 class="code-header">type <a href="slice/trait.SliceIndex.html#associatedtype.Output" class="associatedtype">Output</a> = <a class="primitive" href="primitive.str.html">str</a></h4></section></summary><div class='docblock'>The output type returned by methods.</div></details><details class="toggle method-toggle" open><summary><section id="method.get-1" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/str/traits.rs.html#477">source</a><a href="#method.get-1" class="anchor">Â§</a><h4 class="code-header">fn <a href="slice/trait.SliceIndex.html#tymethod.get" class="fn">get</a>(
    self,
    slice: &amp;<a class="primitive" href="primitive.str.html">str</a>,
) -&gt; <a class="enum" href="option/enum.Option.html" title="enum std::option::Option">Option</a>&lt;&amp;&lt;<a class="struct" href="ops/struct.RangeInclusive.html" title="struct std::ops::RangeInclusive">RangeInclusive</a>&lt;<a class="primitive" href="primitive.usize.html">usize</a>&gt; as <a class="trait" href="slice/trait.SliceIndex.html" title="trait std::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt;&gt;::<a class="associatedtype" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type std::slice::SliceIndex::Output">Output</a>&gt;</h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span></div></span><div class='docblock'>Returns a shared reference to the output at this location, if in
bounds.</div></details><details class="toggle method-toggle" open><summary><section id="method.get_mut-1" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/str/traits.rs.html#481">source</a><a href="#method.get_mut-1" class="anchor">Â§</a><h4 class="code-header">fn <a href="slice/trait.SliceIndex.html#tymethod.get_mut" class="fn">get_mut</a>(
    self,
    slice: &amp;mut <a class="primitive" href="primitive.str.html">str</a>,
) -&gt; <a class="enum" href="option/enum.Option.html" title="enum std::option::Option">Option</a>&lt;&amp;mut &lt;<a class="struct" href="ops/struct.RangeInclusive.html" title="struct std::ops::RangeInclusive">RangeInclusive</a>&lt;<a class="primitive" href="primitive.usize.html">usize</a>&gt; as <a class="trait" href="slice/trait.SliceIndex.html" title="trait std::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt;&gt;::<a class="associatedtype" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type std::slice::SliceIndex::Output">Output</a>&gt;</h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span></div></span><div class='docblock'>Returns a mutable reference to the output at this location, if in
bounds.</div></details><details class="toggle method-toggle" open><summary><section id="method.get_unchecked-1" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/str/traits.rs.html#485">source</a><a href="#method.get_unchecked-1" class="anchor">Â§</a><h4 class="code-header">unsafe fn <a href="slice/trait.SliceIndex.html#tymethod.get_unchecked" class="fn">get_unchecked</a>(
    self,
    slice: <a class="primitive" href="primitive.pointer.html">*const </a><a class="primitive" href="primitive.str.html">str</a>,
) -&gt; <a class="primitive" href="primitive.pointer.html">*const </a>&lt;<a class="struct" href="ops/struct.RangeInclusive.html" title="struct std::ops::RangeInclusive">RangeInclusive</a>&lt;<a class="primitive" href="primitive.usize.html">usize</a>&gt; as <a class="trait" href="slice/trait.SliceIndex.html" title="trait std::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt;&gt;::<a class="associatedtype" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type std::slice::SliceIndex::Output">Output</a></h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span></div></span><div class='docblock'>Returns a pointer to the output at this location, without
performing any bounds checking.
Calling this method with an out-of-bounds index or a dangling <code>slice</code> pointer
is <em><a href="https://doc.rust-lang.org/reference/behavior-considered-undefined.html">undefined behavior</a></em> even if the resulting pointer is not used.</div></details><details class="toggle method-toggle" open><summary><section id="method.get_unchecked_mut-1" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/str/traits.rs.html#490">source</a><a href="#method.get_unchecked_mut-1" class="anchor">Â§</a><h4 class="code-header">unsafe fn <a href="slice/trait.SliceIndex.html#tymethod.get_unchecked_mut" class="fn">get_unchecked_mut</a>(
    self,
    slice: <a class="primitive" href="primitive.pointer.html">*mut </a><a class="primitive" href="primitive.str.html">str</a>,
) -&gt; <a class="primitive" href="primitive.pointer.html">*mut </a>&lt;<a class="struct" href="ops/struct.RangeInclusive.html" title="struct std::ops::RangeInclusive">RangeInclusive</a>&lt;<a class="primitive" href="primitive.usize.html">usize</a>&gt; as <a class="trait" href="slice/trait.SliceIndex.html" title="trait std::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt;&gt;::<a class="associatedtype" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type std::slice::SliceIndex::Output">Output</a></h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span></div></span><div class='docblock'>Returns a mutable pointer to the output at this location, without
performing any bounds checking.
Calling this method with an out-of-bounds index or a dangling <code>slice</code> pointer
is <em><a href="https://doc.rust-lang.org/reference/behavior-considered-undefined.html">undefined behavior</a></em> even if the resulting pointer is not used.</div></details><details class="toggle method-toggle" open><summary><section id="method.index-1" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/str/traits.rs.html#495">source</a><a href="#method.index-1" class="anchor">Â§</a><h4 class="code-header">fn <a href="slice/trait.SliceIndex.html#tymethod.index" class="fn">index</a>(
    self,
    slice: &amp;<a class="primitive" href="primitive.str.html">str</a>,
) -&gt; &amp;&lt;<a class="struct" href="ops/struct.RangeInclusive.html" title="struct std::ops::RangeInclusive">RangeInclusive</a>&lt;<a class="primitive" href="primitive.usize.html">usize</a>&gt; as <a class="trait" href="slice/trait.SliceIndex.html" title="trait std::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt;&gt;::<a class="associatedtype" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type std::slice::SliceIndex::Output">Output</a> <a href="#" class="tooltip" data-notable-ty="&amp;&lt;RangeInclusive&lt;usize&gt; as SliceIndex&lt;str&gt;&gt;::Output">â“˜</a></h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span></div></span><div class='docblock'>Returns a shared reference to the output at this location, panicking
if out of bounds.</div></details><details class="toggle method-toggle" open><summary><section id="method.index_mut" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/str/traits.rs.html#502">source</a><a href="#method.index_mut" class="anchor">Â§</a><h4 class="code-header">fn <a href="slice/trait.SliceIndex.html#tymethod.index_mut" class="fn">index_mut</a>(
    self,
    slice: &amp;mut <a class="primitive" href="primitive.str.html">str</a>,
) -&gt; &amp;mut &lt;<a class="struct" href="ops/struct.RangeInclusive.html" title="struct std::ops::RangeInclusive">RangeInclusive</a>&lt;<a class="primitive" href="primitive.usize.html">usize</a>&gt; as <a class="trait" href="slice/trait.SliceIndex.html" title="trait std::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt;&gt;::<a class="associatedtype" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type std::slice::SliceIndex::Output">Output</a> <a href="#" class="tooltip" data-notable-ty="&amp;mut &lt;RangeInclusive&lt;usize&gt; as SliceIndex&lt;str&gt;&gt;::Output">â“˜</a></h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span></div></span><div class='docblock'>Returns a mutable reference to the output at this location, panicking
if out of bounds.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-SliceIndex%3Cstr%3E-for-RangeTo%3Cusize%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.20.0, const unstable">1.20.0 (const: unstable)</span> Â· <a class="src" href="https://doc.rust-lang.org/1.80.1/src/core/str/traits.rs.html#333">source</a></span><a href="#impl-SliceIndex%3Cstr%3E-for-RangeTo%3Cusize%3E" class="anchor">Â§</a><h3 class="code-header">impl <a class="trait" href="slice/trait.SliceIndex.html" title="trait std::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt; for <a class="struct" href="ops/struct.RangeTo.html" title="struct std::ops::RangeTo">RangeTo</a>&lt;<a class="primitive" href="primitive.usize.html">usize</a>&gt;</h3></section></summary><div class="docblock"><p>Implements substring slicing with syntax <code>&amp;self[.. end]</code> or <code>&amp;mut self[.. end]</code>.</p>
<p>Returns a slice of the given string from the byte range [0, <code>end</code>).
Equivalent to <code>&amp;self[0 .. end]</code> or <code>&amp;mut self[0 .. end]</code>.</p>
<p>This operation is <em>O</em>(1).</p>
<p>Prior to 1.20.0, these indexing operations were still supported by
direct implementation of <code>Index</code> and <code>IndexMut</code>.</p>
<h4 id="panics-5"><a class="doc-anchor" href="#panics-5">Â§</a>Panics</h4>
<p>Panics if <code>end</code> does not point to the starting byte offset of a
character (as defined by <code>is_char_boundary</code>), or if <code>end &gt; len</code>.</p>
</div><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Output-3" class="associatedtype trait-impl"><a href="#associatedtype.Output-3" class="anchor">Â§</a><h4 class="code-header">type <a href="slice/trait.SliceIndex.html#associatedtype.Output" class="associatedtype">Output</a> = <a class="primitive" href="primitive.str.html">str</a></h4></section></summary><div class='docblock'>The output type returned by methods.</div></details><details class="toggle method-toggle" open><summary><section id="method.get-3" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/str/traits.rs.html#336">source</a><a href="#method.get-3" class="anchor">Â§</a><h4 class="code-header">fn <a href="slice/trait.SliceIndex.html#tymethod.get" class="fn">get</a>(
    self,
    slice: &amp;<a class="primitive" href="primitive.str.html">str</a>,
) -&gt; <a class="enum" href="option/enum.Option.html" title="enum std::option::Option">Option</a>&lt;&amp;&lt;<a class="struct" href="ops/struct.RangeTo.html" title="struct std::ops::RangeTo">RangeTo</a>&lt;<a class="primitive" href="primitive.usize.html">usize</a>&gt; as <a class="trait" href="slice/trait.SliceIndex.html" title="trait std::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt;&gt;::<a class="associatedtype" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type std::slice::SliceIndex::Output">Output</a>&gt;</h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span></div></span><div class='docblock'>Returns a shared reference to the output at this location, if in
bounds.</div></details><details class="toggle method-toggle" open><summary><section id="method.get_mut-3" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/str/traits.rs.html#346">source</a><a href="#method.get_mut-3" class="anchor">Â§</a><h4 class="code-header">fn <a href="slice/trait.SliceIndex.html#tymethod.get_mut" class="fn">get_mut</a>(
    self,
    slice: &amp;mut <a class="primitive" href="primitive.str.html">str</a>,
) -&gt; <a class="enum" href="option/enum.Option.html" title="enum std::option::Option">Option</a>&lt;&amp;mut &lt;<a class="struct" href="ops/struct.RangeTo.html" title="struct std::ops::RangeTo">RangeTo</a>&lt;<a class="primitive" href="primitive.usize.html">usize</a>&gt; as <a class="trait" href="slice/trait.SliceIndex.html" title="trait std::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt;&gt;::<a class="associatedtype" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type std::slice::SliceIndex::Output">Output</a>&gt;</h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span></div></span><div class='docblock'>Returns a mutable reference to the output at this location, if in
bounds.</div></details><details class="toggle method-toggle" open><summary><section id="method.get_unchecked-3" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/str/traits.rs.html#356">source</a><a href="#method.get_unchecked-3" class="anchor">Â§</a><h4 class="code-header">unsafe fn <a href="slice/trait.SliceIndex.html#tymethod.get_unchecked" class="fn">get_unchecked</a>(
    self,
    slice: <a class="primitive" href="primitive.pointer.html">*const </a><a class="primitive" href="primitive.str.html">str</a>,
) -&gt; <a class="primitive" href="primitive.pointer.html">*const </a>&lt;<a class="struct" href="ops/struct.RangeTo.html" title="struct std::ops::RangeTo">RangeTo</a>&lt;<a class="primitive" href="primitive.usize.html">usize</a>&gt; as <a class="trait" href="slice/trait.SliceIndex.html" title="trait std::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt;&gt;::<a class="associatedtype" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type std::slice::SliceIndex::Output">Output</a></h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span></div></span><div class='docblock'>Returns a pointer to the output at this location, without
performing any bounds checking.
Calling this method with an out-of-bounds index or a dangling <code>slice</code> pointer
is <em><a href="https://doc.rust-lang.org/reference/behavior-considered-undefined.html">undefined behavior</a></em> even if the resulting pointer is not used.</div></details><details class="toggle method-toggle" open><summary><section id="method.get_unchecked_mut-3" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/str/traits.rs.html#361">source</a><a href="#method.get_unchecked_mut-3" class="anchor">Â§</a><h4 class="code-header">unsafe fn <a href="slice/trait.SliceIndex.html#tymethod.get_unchecked_mut" class="fn">get_unchecked_mut</a>(
    self,
    slice: <a class="primitive" href="primitive.pointer.html">*mut </a><a class="primitive" href="primitive.str.html">str</a>,
) -&gt; <a class="primitive" href="primitive.pointer.html">*mut </a>&lt;<a class="struct" href="ops/struct.RangeTo.html" title="struct std::ops::RangeTo">RangeTo</a>&lt;<a class="primitive" href="primitive.usize.html">usize</a>&gt; as <a class="trait" href="slice/trait.SliceIndex.html" title="trait std::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt;&gt;::<a class="associatedtype" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type std::slice::SliceIndex::Output">Output</a></h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span></div></span><div class='docblock'>Returns a mutable pointer to the output at this location, without
performing any bounds checking.
Calling this method with an out-of-bounds index or a dangling <code>slice</code> pointer
is <em><a href="https://doc.rust-lang.org/reference/behavior-considered-undefined.html">undefined behavior</a></em> even if the resulting pointer is not used.</div></details><details class="toggle method-toggle" open><summary><section id="method.index-3" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/str/traits.rs.html#366">source</a><a href="#method.index-3" class="anchor">Â§</a><h4 class="code-header">fn <a href="slice/trait.SliceIndex.html#tymethod.index" class="fn">index</a>(self, slice: &amp;<a class="primitive" href="primitive.str.html">str</a>) -&gt; &amp;&lt;<a class="struct" href="ops/struct.RangeTo.html" title="struct std::ops::RangeTo">RangeTo</a>&lt;<a class="primitive" href="primitive.usize.html">usize</a>&gt; as <a class="trait" href="slice/trait.SliceIndex.html" title="trait std::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt;&gt;::<a class="associatedtype" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type std::slice::SliceIndex::Output">Output</a></h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span></div></span><div class='docblock'>Returns a shared reference to the output at this location, panicking
if out of bounds.</div></details><details class="toggle method-toggle" open><summary><section id="method.index_mut-2" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/str/traits.rs.html#374">source</a><a href="#method.index_mut-2" class="anchor">Â§</a><h4 class="code-header">fn <a href="slice/trait.SliceIndex.html#tymethod.index_mut" class="fn">index_mut</a>(
    self,
    slice: &amp;mut <a class="primitive" href="primitive.str.html">str</a>,
) -&gt; &amp;mut &lt;<a class="struct" href="ops/struct.RangeTo.html" title="struct std::ops::RangeTo">RangeTo</a>&lt;<a class="primitive" href="primitive.usize.html">usize</a>&gt; as <a class="trait" href="slice/trait.SliceIndex.html" title="trait std::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt;&gt;::<a class="associatedtype" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type std::slice::SliceIndex::Output">Output</a></h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span></div></span><div class='docblock'>Returns a mutable reference to the output at this location, panicking
if out of bounds.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-SliceIndex%3Cstr%3E-for-RangeToInclusive%3Cusize%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.26.0, const unstable">1.26.0 (const: unstable)</span> Â· <a class="src" href="https://doc.rust-lang.org/1.80.1/src/core/str/traits.rs.html#526">source</a></span><a href="#impl-SliceIndex%3Cstr%3E-for-RangeToInclusive%3Cusize%3E" class="anchor">Â§</a><h3 class="code-header">impl <a class="trait" href="slice/trait.SliceIndex.html" title="trait std::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt; for <a class="struct" href="ops/struct.RangeToInclusive.html" title="struct std::ops::RangeToInclusive">RangeToInclusive</a>&lt;<a class="primitive" href="primitive.usize.html">usize</a>&gt;</h3></section></summary><div class="docblock"><p>Implements substring slicing with syntax <code>&amp;self[..= end]</code> or <code>&amp;mut self[..= end]</code>.</p>
<p>Returns a slice of the given string from the byte range [0, <code>end</code>].
Equivalent to <code>&amp;self [0 .. end + 1]</code>, except if <code>end</code> has the maximum
value for <code>usize</code>.</p>
<p>This operation is <em>O</em>(1).</p>
<h4 id="panics-6"><a class="doc-anchor" href="#panics-6">Â§</a>Panics</h4>
<p>Panics if <code>end</code> does not point to the ending byte offset of a character
(<code>end + 1</code> is either a starting byte offset as defined by
<code>is_char_boundary</code>, or equal to <code>len</code>), or if <code>end &gt;= len</code>.</p>
</div><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Output-4" class="associatedtype trait-impl"><a href="#associatedtype.Output-4" class="anchor">Â§</a><h4 class="code-header">type <a href="slice/trait.SliceIndex.html#associatedtype.Output" class="associatedtype">Output</a> = <a class="primitive" href="primitive.str.html">str</a></h4></section></summary><div class='docblock'>The output type returned by methods.</div></details><details class="toggle method-toggle" open><summary><section id="method.get-4" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/str/traits.rs.html#529">source</a><a href="#method.get-4" class="anchor">Â§</a><h4 class="code-header">fn <a href="slice/trait.SliceIndex.html#tymethod.get" class="fn">get</a>(
    self,
    slice: &amp;<a class="primitive" href="primitive.str.html">str</a>,
) -&gt; <a class="enum" href="option/enum.Option.html" title="enum std::option::Option">Option</a>&lt;&amp;&lt;<a class="struct" href="ops/struct.RangeToInclusive.html" title="struct std::ops::RangeToInclusive">RangeToInclusive</a>&lt;<a class="primitive" href="primitive.usize.html">usize</a>&gt; as <a class="trait" href="slice/trait.SliceIndex.html" title="trait std::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt;&gt;::<a class="associatedtype" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type std::slice::SliceIndex::Output">Output</a>&gt;</h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span></div></span><div class='docblock'>Returns a shared reference to the output at this location, if in
bounds.</div></details><details class="toggle method-toggle" open><summary><section id="method.get_mut-4" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/str/traits.rs.html#533">source</a><a href="#method.get_mut-4" class="anchor">Â§</a><h4 class="code-header">fn <a href="slice/trait.SliceIndex.html#tymethod.get_mut" class="fn">get_mut</a>(
    self,
    slice: &amp;mut <a class="primitive" href="primitive.str.html">str</a>,
) -&gt; <a class="enum" href="option/enum.Option.html" title="enum std::option::Option">Option</a>&lt;&amp;mut &lt;<a class="struct" href="ops/struct.RangeToInclusive.html" title="struct std::ops::RangeToInclusive">RangeToInclusive</a>&lt;<a class="primitive" href="primitive.usize.html">usize</a>&gt; as <a class="trait" href="slice/trait.SliceIndex.html" title="trait std::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt;&gt;::<a class="associatedtype" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type std::slice::SliceIndex::Output">Output</a>&gt;</h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span></div></span><div class='docblock'>Returns a mutable reference to the output at this location, if in
bounds.</div></details><details class="toggle method-toggle" open><summary><section id="method.get_unchecked-4" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/str/traits.rs.html#537">source</a><a href="#method.get_unchecked-4" class="anchor">Â§</a><h4 class="code-header">unsafe fn <a href="slice/trait.SliceIndex.html#tymethod.get_unchecked" class="fn">get_unchecked</a>(
    self,
    slice: <a class="primitive" href="primitive.pointer.html">*const </a><a class="primitive" href="primitive.str.html">str</a>,
) -&gt; <a class="primitive" href="primitive.pointer.html">*const </a>&lt;<a class="struct" href="ops/struct.RangeToInclusive.html" title="struct std::ops::RangeToInclusive">RangeToInclusive</a>&lt;<a class="primitive" href="primitive.usize.html">usize</a>&gt; as <a class="trait" href="slice/trait.SliceIndex.html" title="trait std::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt;&gt;::<a class="associatedtype" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type std::slice::SliceIndex::Output">Output</a></h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span></div></span><div class='docblock'>Returns a pointer to the output at this location, without
performing any bounds checking.
Calling this method with an out-of-bounds index or a dangling <code>slice</code> pointer
is <em><a href="https://doc.rust-lang.org/reference/behavior-considered-undefined.html">undefined behavior</a></em> even if the resulting pointer is not used.</div></details><details class="toggle method-toggle" open><summary><section id="method.get_unchecked_mut-4" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/str/traits.rs.html#542">source</a><a href="#method.get_unchecked_mut-4" class="anchor">Â§</a><h4 class="code-header">unsafe fn <a href="slice/trait.SliceIndex.html#tymethod.get_unchecked_mut" class="fn">get_unchecked_mut</a>(
    self,
    slice: <a class="primitive" href="primitive.pointer.html">*mut </a><a class="primitive" href="primitive.str.html">str</a>,
) -&gt; <a class="primitive" href="primitive.pointer.html">*mut </a>&lt;<a class="struct" href="ops/struct.RangeToInclusive.html" title="struct std::ops::RangeToInclusive">RangeToInclusive</a>&lt;<a class="primitive" href="primitive.usize.html">usize</a>&gt; as <a class="trait" href="slice/trait.SliceIndex.html" title="trait std::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt;&gt;::<a class="associatedtype" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type std::slice::SliceIndex::Output">Output</a></h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span></div></span><div class='docblock'>Returns a mutable pointer to the output at this location, without
performing any bounds checking.
Calling this method with an out-of-bounds index or a dangling <code>slice</code> pointer
is <em><a href="https://doc.rust-lang.org/reference/behavior-considered-undefined.html">undefined behavior</a></em> even if the resulting pointer is not used.</div></details><details class="toggle method-toggle" open><summary><section id="method.index-4" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/str/traits.rs.html#547">source</a><a href="#method.index-4" class="anchor">Â§</a><h4 class="code-header">fn <a href="slice/trait.SliceIndex.html#tymethod.index" class="fn">index</a>(
    self,
    slice: &amp;<a class="primitive" href="primitive.str.html">str</a>,
) -&gt; &amp;&lt;<a class="struct" href="ops/struct.RangeToInclusive.html" title="struct std::ops::RangeToInclusive">RangeToInclusive</a>&lt;<a class="primitive" href="primitive.usize.html">usize</a>&gt; as <a class="trait" href="slice/trait.SliceIndex.html" title="trait std::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt;&gt;::<a class="associatedtype" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type std::slice::SliceIndex::Output">Output</a></h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span></div></span><div class='docblock'>Returns a shared reference to the output at this location, panicking
if out of bounds.</div></details><details class="toggle method-toggle" open><summary><section id="method.index_mut-3" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/str/traits.rs.html#551">source</a><a href="#method.index_mut-3" class="anchor">Â§</a><h4 class="code-header">fn <a href="slice/trait.SliceIndex.html#tymethod.index_mut" class="fn">index_mut</a>(
    self,
    slice: &amp;mut <a class="primitive" href="primitive.str.html">str</a>,
) -&gt; &amp;mut &lt;<a class="struct" href="ops/struct.RangeToInclusive.html" title="struct std::ops::RangeToInclusive">RangeToInclusive</a>&lt;<a class="primitive" href="primitive.usize.html">usize</a>&gt; as <a class="trait" href="slice/trait.SliceIndex.html" title="trait std::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt;&gt;::<a class="associatedtype" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type std::slice::SliceIndex::Output">Output</a></h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span></div></span><div class='docblock'>Returns a mutable reference to the output at this location, panicking
if out of bounds.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-ToOwned-for-str" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="../src/alloc/str.rs.html#207">source</a></span><a href="#impl-ToOwned-for-str" class="anchor">Â§</a><h3 class="code-header">impl <a class="trait" href="borrow/trait.ToOwned.html" title="trait std::borrow::ToOwned">ToOwned</a> for <a class="primitive" href="primitive.str.html">str</a></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Owned" class="associatedtype trait-impl"><a href="#associatedtype.Owned" class="anchor">Â§</a><h4 class="code-header">type <a href="borrow/trait.ToOwned.html#associatedtype.Owned" class="associatedtype">Owned</a> = <a class="struct" href="string/struct.String.html" title="struct std::string::String">String</a></h4></section></summary><div class='docblock'>The resulting type after obtaining ownership.</div></details><details class="toggle method-toggle" open><summary><section id="method.to_owned" class="method trait-impl"><a class="src rightside" href="../src/alloc/str.rs.html#210">source</a><a href="#method.to_owned" class="anchor">Â§</a><h4 class="code-header">fn <a href="borrow/trait.ToOwned.html#tymethod.to_owned" class="fn">to_owned</a>(&amp;self) -&gt; <a class="struct" href="string/struct.String.html" title="struct std::string::String">String</a></h4></section></summary><div class='docblock'>Creates owned data from borrowed data, usually by cloning. <a href="borrow/trait.ToOwned.html#tymethod.to_owned">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.clone_into" class="method trait-impl"><a class="src rightside" href="../src/alloc/str.rs.html#214">source</a><a href="#method.clone_into" class="anchor">Â§</a><h4 class="code-header">fn <a href="borrow/trait.ToOwned.html#method.clone_into" class="fn">clone_into</a>(&amp;self, target: &amp;mut <a class="struct" href="string/struct.String.html" title="struct std::string::String">String</a>)</h4></section></summary><div class='docblock'>Uses borrowed data to replace owned data, usually by cloning. <a href="borrow/trait.ToOwned.html#method.clone_into">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-ToSocketAddrs-for-str" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="../src/std/net/socket_addr.rs.html#280-290">source</a></span><a href="#impl-ToSocketAddrs-for-str" class="anchor">Â§</a><h3 class="code-header">impl <a class="trait" href="net/trait.ToSocketAddrs.html" title="trait std::net::ToSocketAddrs">ToSocketAddrs</a> for <a class="primitive" href="primitive.str.html">str</a></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Iter" class="associatedtype trait-impl"><a href="#associatedtype.Iter" class="anchor">Â§</a><h4 class="code-header">type <a href="net/trait.ToSocketAddrs.html#associatedtype.Iter" class="associatedtype">Iter</a> = <a class="struct" href="vec/struct.IntoIter.html" title="struct std::vec::IntoIter">IntoIter</a>&lt;<a class="enum" href="net/enum.SocketAddr.html" title="enum std::net::SocketAddr">SocketAddr</a>&gt;</h4></section></summary><div class='docblock'>Returned iterator over socket addresses which this type may correspond
to.</div></details><details class="toggle method-toggle" open><summary><section id="method.to_socket_addrs" class="method trait-impl"><a class="src rightside" href="../src/std/net/socket_addr.rs.html#282-289">source</a><a href="#method.to_socket_addrs" class="anchor">Â§</a><h4 class="code-header">fn <a href="net/trait.ToSocketAddrs.html#tymethod.to_socket_addrs" class="fn">to_socket_addrs</a>(&amp;self) -&gt; <a class="type" href="io/type.Result.html" title="type std::io::Result">Result</a>&lt;<a class="struct" href="vec/struct.IntoIter.html" title="struct std::vec::IntoIter">IntoIter</a>&lt;<a class="enum" href="net/enum.SocketAddr.html" title="enum std::net::SocketAddr">SocketAddr</a>&gt;&gt;</h4></section></summary><div class='docblock'>Converts this object to an iterator of resolved <a href="net/enum.SocketAddr.html" title="enum std::net::SocketAddr"><code>SocketAddr</code></a>s. <a href="net/trait.ToSocketAddrs.html#tymethod.to_socket_addrs">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-TryFrom%3C%26OsStr%3E-for-%26str" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.72.0">1.72.0</span> Â· <a class="src" href="../src/std/ffi/os_str.rs.html#1320-1335">source</a></span><a href="#impl-TryFrom%3C%26OsStr%3E-for-%26str" class="anchor">Â§</a><h3 class="code-header">impl&lt;'a&gt; <a class="trait" href="convert/trait.TryFrom.html" title="trait std::convert::TryFrom">TryFrom</a>&lt;&amp;'a <a class="struct" href="ffi/struct.OsStr.html" title="struct std::ffi::OsStr">OsStr</a>&gt; for &amp;'a <a class="primitive" href="primitive.str.html">str</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.try_from" class="method trait-impl"><a class="src rightside" href="../src/std/ffi/os_str.rs.html#1332-1334">source</a><a href="#method.try_from" class="anchor">Â§</a><h4 class="code-header">fn <a href="convert/trait.TryFrom.html#tymethod.try_from" class="fn">try_from</a>(value: &amp;'a <a class="struct" href="ffi/struct.OsStr.html" title="struct std::ffi::OsStr">OsStr</a>) -&gt; <a class="enum" href="result/enum.Result.html" title="enum std::result::Result">Result</a>&lt;Self, Self::<a class="associatedtype" href="convert/trait.TryFrom.html#associatedtype.Error" title="type std::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>Tries to convert an <code>&amp;OsStr</code> to a <code>&amp;str</code>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::ffi::OsStr;

<span class="kw">let </span>os_str = OsStr::new(<span class="string">"foo"</span>);
<span class="kw">let </span>as_str = &lt;<span class="kw-2">&amp;</span>str&gt;::try_from(os_str).unwrap();
<span class="macro">assert_eq!</span>(as_str, <span class="string">"foo"</span>);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::ffi::OsStr;%0A++++%0A++++let+os_str+=+OsStr::new(%22foo%22);%0A++++let+as_str+=+%3C%26str%3E::try_from(os_str).unwrap();%0A++++assert_eq!(as_str,+%22foo%22);%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="toggle" open><summary><section id="associatedtype.Error" class="associatedtype trait-impl"><a href="#associatedtype.Error" class="anchor">Â§</a><h4 class="code-header">type <a href="convert/trait.TryFrom.html#associatedtype.Error" class="associatedtype">Error</a> = <a class="struct" href="str/struct.Utf8Error.html" title="struct std::str::Utf8Error">Utf8Error</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details></div></details><section id="impl-ConstParamTy-for-str" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/marker.rs.html#992-1003">source</a><a href="#impl-ConstParamTy-for-str" class="anchor">Â§</a><h3 class="code-header">impl <a class="trait" href="marker/trait.ConstParamTy.html" title="trait std::marker::ConstParamTy">ConstParamTy</a> for <a class="primitive" href="primitive.str.html">str</a></h3></section><section id="impl-Eq-for-str" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="https://doc.rust-lang.org/1.80.1/src/core/str/traits.rs.html#36">source</a></span><a href="#impl-Eq-for-str" class="anchor">Â§</a><h3 class="code-header">impl <a class="trait" href="cmp/trait.Eq.html" title="trait std::cmp::Eq">Eq</a> for <a class="primitive" href="primitive.str.html">str</a></h3></section><section id="impl-StructuralPartialEq-for-str" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/marker.rs.html#214-226">source</a><a href="#impl-StructuralPartialEq-for-str" class="anchor">Â§</a><h3 class="code-header">impl <a class="trait" href="marker/trait.StructuralPartialEq.html" title="trait std::marker::StructuralPartialEq">StructuralPartialEq</a> for <a class="primitive" href="primitive.str.html">str</a></h3></section></div><h2 id="synthetic-implementations" class="section-header">Auto Trait Implementations<a href="#synthetic-implementations" class="anchor">Â§</a></h2><div id="synthetic-implementations-list"><section id="impl-Freeze-for-str" class="impl"><a href="#impl-Freeze-for-str" class="anchor">Â§</a><h3 class="code-header">impl <a class="trait" href="marker/trait.Freeze.html" title="trait std::marker::Freeze">Freeze</a> for <a class="primitive" href="primitive.str.html">str</a></h3></section><section id="impl-RefUnwindSafe-for-str" class="impl"><a href="#impl-RefUnwindSafe-for-str" class="anchor">Â§</a><h3 class="code-header">impl <a class="trait" href="panic/trait.RefUnwindSafe.html" title="trait std::panic::RefUnwindSafe">RefUnwindSafe</a> for <a class="primitive" href="primitive.str.html">str</a></h3></section><section id="impl-Send-for-str" class="impl"><a href="#impl-Send-for-str" class="anchor">Â§</a><h3 class="code-header">impl <a class="trait" href="marker/trait.Send.html" title="trait std::marker::Send">Send</a> for <a class="primitive" href="primitive.str.html">str</a></h3></section><section id="impl-Sized-for-str" class="impl"><a href="#impl-Sized-for-str" class="anchor">Â§</a><h3 class="code-header">impl !<a class="trait" href="marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a> for <a class="primitive" href="primitive.str.html">str</a></h3></section><section id="impl-Sync-for-str" class="impl"><a href="#impl-Sync-for-str" class="anchor">Â§</a><h3 class="code-header">impl <a class="trait" href="marker/trait.Sync.html" title="trait std::marker::Sync">Sync</a> for <a class="primitive" href="primitive.str.html">str</a></h3></section><section id="impl-Unpin-for-str" class="impl"><a href="#impl-Unpin-for-str" class="anchor">Â§</a><h3 class="code-header">impl <a class="trait" href="marker/trait.Unpin.html" title="trait std::marker::Unpin">Unpin</a> for <a class="primitive" href="primitive.str.html">str</a></h3></section><section id="impl-UnwindSafe-for-str" class="impl"><a href="#impl-UnwindSafe-for-str" class="anchor">Â§</a><h3 class="code-header">impl <a class="trait" href="panic/trait.UnwindSafe.html" title="trait std::panic::UnwindSafe">UnwindSafe</a> for <a class="primitive" href="primitive.str.html">str</a></h3></section></div><h2 id="blanket-implementations" class="section-header">Blanket Implementations<a href="#blanket-implementations" class="anchor">Â§</a></h2><div id="blanket-implementations-list"><details class="toggle implementors-toggle"><summary><section id="impl-Any-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/any.rs.html#140">source</a><a href="#impl-Any-for-T" class="anchor">Â§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="any/trait.Any.html" title="trait std::any::Any">Any</a> for T<div class="where">where
    T: 'static + ?<a class="trait" href="marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.type_id" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/any.rs.html#141">source</a><a href="#method.type_id" class="anchor">Â§</a><h4 class="code-header">fn <a href="any/trait.Any.html#tymethod.type_id" class="fn">type_id</a>(&amp;self) -&gt; <a class="struct" href="any/struct.TypeId.html" title="struct std::any::TypeId">TypeId</a></h4></section></summary><div class='docblock'>Gets the <code>TypeId</code> of <code>self</code>. <a href="any/trait.Any.html#tymethod.type_id">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Borrow%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/borrow.rs.html#208">source</a><a href="#impl-Borrow%3CT%3E-for-T" class="anchor">Â§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="borrow/trait.Borrow.html" title="trait std::borrow::Borrow">Borrow</a>&lt;T&gt; for T<div class="where">where
    T: ?<a class="trait" href="marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow-1" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/borrow.rs.html#210">source</a><a href="#method.borrow-1" class="anchor">Â§</a><h4 class="code-header">fn <a href="borrow/trait.Borrow.html#tymethod.borrow" class="fn">borrow</a>(&amp;self) -&gt; <a class="primitive" href="primitive.reference.html">&amp;T</a></h4></section></summary><div class='docblock'>Immutably borrows from an owned value. <a href="borrow/trait.Borrow.html#tymethod.borrow">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-BorrowMut%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/borrow.rs.html#216">source</a><a href="#impl-BorrowMut%3CT%3E-for-T" class="anchor">Â§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="borrow/trait.BorrowMut.html" title="trait std::borrow::BorrowMut">BorrowMut</a>&lt;T&gt; for T<div class="where">where
    T: ?<a class="trait" href="marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow_mut-1" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/borrow.rs.html#217">source</a><a href="#method.borrow_mut-1" class="anchor">Â§</a><h4 class="code-header">fn <a href="borrow/trait.BorrowMut.html#tymethod.borrow_mut" class="fn">borrow_mut</a>(&amp;mut self) -&gt; <a class="primitive" href="primitive.reference.html">&amp;mut T</a></h4></section></summary><div class='docblock'>Mutably borrows from an owned value. <a href="borrow/trait.BorrowMut.html#tymethod.borrow_mut">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-ToString-for-T" class="impl"><a class="src rightside" href="../src/alloc/string.rs.html#2552">source</a><a href="#impl-ToString-for-T" class="anchor">Â§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="string/trait.ToString.html" title="trait std::string::ToString">ToString</a> for T<div class="where">where
    T: <a class="trait" href="fmt/trait.Display.html" title="trait std::fmt::Display">Display</a> + ?<a class="trait" href="marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.to_string" class="method trait-impl"><a class="src rightside" href="../src/alloc/string.rs.html#2558">source</a><a href="#method.to_string" class="anchor">Â§</a><h4 class="code-header">default fn <a href="string/trait.ToString.html#tymethod.to_string" class="fn">to_string</a>(&amp;self) -&gt; <a class="struct" href="string/struct.String.html" title="struct std::string::String">String</a></h4></section></summary><div class='docblock'>Converts the given value to a <code>String</code>. <a href="string/trait.ToString.html#tymethod.to_string">Read more</a></div></details></div></details></div><script type="text/json" id="notable-traits-data">{"&<Range<usize> as SliceIndex<str>>::Output":"<h3>Notable traits for <code><a class=\"struct\" href=\"ops/struct.Range.html\" title=\"struct std::ops::Range\">Range</a>&lt;A&gt;</code></h3><pre><code><div class=\"where\">impl&lt;A&gt; <a class=\"trait\" href=\"iter/trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for <a class=\"struct\" href=\"ops/struct.Range.html\" title=\"struct std::ops::Range\">Range</a>&lt;A&gt;<div class=\"where\">where\n    A: <a class=\"trait\" href=\"iter/trait.Step.html\" title=\"trait std::iter::Step\">Step</a>,</div></div><div class=\"where\">    type <a href=\"iter/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = A;</div>","&<RangeFrom<usize> as SliceIndex<str>>::Output":"<h3>Notable traits for <code><a class=\"struct\" href=\"ops/struct.RangeFrom.html\" title=\"struct std::ops::RangeFrom\">RangeFrom</a>&lt;A&gt;</code></h3><pre><code><div class=\"where\">impl&lt;A&gt; <a class=\"trait\" href=\"iter/trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for <a class=\"struct\" href=\"ops/struct.RangeFrom.html\" title=\"struct std::ops::RangeFrom\">RangeFrom</a>&lt;A&gt;<div class=\"where\">where\n    A: <a class=\"trait\" href=\"iter/trait.Step.html\" title=\"trait std::iter::Step\">Step</a>,</div></div><div class=\"where\">    type <a href=\"iter/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = A;</div>","&<RangeInclusive<usize> as SliceIndex<str>>::Output":"<h3>Notable traits for <code><a class=\"struct\" href=\"ops/struct.RangeInclusive.html\" title=\"struct std::ops::RangeInclusive\">RangeInclusive</a>&lt;A&gt;</code></h3><pre><code><div class=\"where\">impl&lt;A&gt; <a class=\"trait\" href=\"iter/trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for <a class=\"struct\" href=\"ops/struct.RangeInclusive.html\" title=\"struct std::ops::RangeInclusive\">RangeInclusive</a>&lt;A&gt;<div class=\"where\">where\n    A: <a class=\"trait\" href=\"iter/trait.Step.html\" title=\"trait std::iter::Step\">Step</a>,</div></div><div class=\"where\">    type <a href=\"iter/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = A;</div>","&[u8]":"<h3>Notable traits for <code>&amp;[<a class=\"primitive\" href=\"primitive.u8.html\">u8</a>]</code></h3><pre><code><div class=\"where\">impl <a class=\"trait\" href=\"io/trait.Read.html\" title=\"trait std::io::Read\">Read</a> for &amp;[<a class=\"primitive\" href=\"primitive.u8.html\">u8</a>]</div>","&mut <Range<usize> as SliceIndex<str>>::Output":"<h3>Notable traits for <code><a class=\"struct\" href=\"ops/struct.Range.html\" title=\"struct std::ops::Range\">Range</a>&lt;A&gt;</code></h3><pre><code><div class=\"where\">impl&lt;A&gt; <a class=\"trait\" href=\"iter/trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for <a class=\"struct\" href=\"ops/struct.Range.html\" title=\"struct std::ops::Range\">Range</a>&lt;A&gt;<div class=\"where\">where\n    A: <a class=\"trait\" href=\"iter/trait.Step.html\" title=\"trait std::iter::Step\">Step</a>,</div></div><div class=\"where\">    type <a href=\"iter/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = A;</div>","&mut <RangeFrom<usize> as SliceIndex<str>>::Output":"<h3>Notable traits for <code><a class=\"struct\" href=\"ops/struct.RangeFrom.html\" title=\"struct std::ops::RangeFrom\">RangeFrom</a>&lt;A&gt;</code></h3><pre><code><div class=\"where\">impl&lt;A&gt; <a class=\"trait\" href=\"iter/trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for <a class=\"struct\" href=\"ops/struct.RangeFrom.html\" title=\"struct std::ops::RangeFrom\">RangeFrom</a>&lt;A&gt;<div class=\"where\">where\n    A: <a class=\"trait\" href=\"iter/trait.Step.html\" title=\"trait std::iter::Step\">Step</a>,</div></div><div class=\"where\">    type <a href=\"iter/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = A;</div>","&mut <RangeInclusive<usize> as SliceIndex<str>>::Output":"<h3>Notable traits for <code><a class=\"struct\" href=\"ops/struct.RangeInclusive.html\" title=\"struct std::ops::RangeInclusive\">RangeInclusive</a>&lt;A&gt;</code></h3><pre><code><div class=\"where\">impl&lt;A&gt; <a class=\"trait\" href=\"iter/trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for <a class=\"struct\" href=\"ops/struct.RangeInclusive.html\" title=\"struct std::ops::RangeInclusive\">RangeInclusive</a>&lt;A&gt;<div class=\"where\">where\n    A: <a class=\"trait\" href=\"iter/trait.Step.html\" title=\"trait std::iter::Step\">Step</a>,</div></div><div class=\"where\">    type <a href=\"iter/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = A;</div>","&mut [u8]":"<h3>Notable traits for <code>&amp;mut [<a class=\"primitive\" href=\"primitive.u8.html\">u8</a>]</code></h3><pre><code><div class=\"where\">impl <a class=\"trait\" href=\"io/trait.Write.html\" title=\"trait std::io::Write\">Write</a> for &amp;mut [<a class=\"primitive\" href=\"primitive.u8.html\">u8</a>]</div>","Bytes<'_>":"<h3>Notable traits for <code><a class=\"struct\" href=\"str/struct.Bytes.html\" title=\"struct std::str::Bytes\">Bytes</a>&lt;'_&gt;</code></h3><pre><code><div class=\"where\">impl <a class=\"trait\" href=\"iter/trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for <a class=\"struct\" href=\"str/struct.Bytes.html\" title=\"struct std::str::Bytes\">Bytes</a>&lt;'_&gt;</div><div class=\"where\">    type <a href=\"iter/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = <a class=\"primitive\" href=\"primitive.u8.html\">u8</a>;</div>","CharIndices<'_>":"<h3>Notable traits for <code><a class=\"struct\" href=\"str/struct.CharIndices.html\" title=\"struct std::str::CharIndices\">CharIndices</a>&lt;'a&gt;</code></h3><pre><code><div class=\"where\">impl&lt;'a&gt; <a class=\"trait\" href=\"iter/trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for <a class=\"struct\" href=\"str/struct.CharIndices.html\" title=\"struct std::str::CharIndices\">CharIndices</a>&lt;'a&gt;</div><div class=\"where\">    type <a href=\"iter/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = (<a class=\"primitive\" href=\"primitive.usize.html\">usize</a>, <a class=\"primitive\" href=\"primitive.char.html\">char</a>);</div>","Chars<'_>":"<h3>Notable traits for <code><a class=\"struct\" href=\"str/struct.Chars.html\" title=\"struct std::str::Chars\">Chars</a>&lt;'a&gt;</code></h3><pre><code><div class=\"where\">impl&lt;'a&gt; <a class=\"trait\" href=\"iter/trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for <a class=\"struct\" href=\"str/struct.Chars.html\" title=\"struct std::str::Chars\">Chars</a>&lt;'a&gt;</div><div class=\"where\">    type <a href=\"iter/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = <a class=\"primitive\" href=\"primitive.char.html\">char</a>;</div>","EncodeUtf16<'_>":"<h3>Notable traits for <code><a class=\"struct\" href=\"str/struct.EncodeUtf16.html\" title=\"struct std::str::EncodeUtf16\">EncodeUtf16</a>&lt;'a&gt;</code></h3><pre><code><div class=\"where\">impl&lt;'a&gt; <a class=\"trait\" href=\"iter/trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for <a class=\"struct\" href=\"str/struct.EncodeUtf16.html\" title=\"struct std::str::EncodeUtf16\">EncodeUtf16</a>&lt;'a&gt;</div><div class=\"where\">    type <a href=\"iter/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = <a class=\"primitive\" href=\"primitive.u16.html\">u16</a>;</div>","EscapeDebug<'_>":"<h3>Notable traits for <code><a class=\"struct\" href=\"str/struct.EscapeDebug.html\" title=\"struct std::str::EscapeDebug\">EscapeDebug</a>&lt;'a&gt;</code></h3><pre><code><div class=\"where\">impl&lt;'a&gt; <a class=\"trait\" href=\"iter/trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for <a class=\"struct\" href=\"str/struct.EscapeDebug.html\" title=\"struct std::str::EscapeDebug\">EscapeDebug</a>&lt;'a&gt;</div><div class=\"where\">    type <a href=\"iter/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = <a class=\"primitive\" href=\"primitive.char.html\">char</a>;</div>","EscapeDefault<'_>":"<h3>Notable traits for <code><a class=\"struct\" href=\"str/struct.EscapeDefault.html\" title=\"struct std::str::EscapeDefault\">EscapeDefault</a>&lt;'a&gt;</code></h3><pre><code><div class=\"where\">impl&lt;'a&gt; <a class=\"trait\" href=\"iter/trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for <a class=\"struct\" href=\"str/struct.EscapeDefault.html\" title=\"struct std::str::EscapeDefault\">EscapeDefault</a>&lt;'a&gt;</div><div class=\"where\">    type <a href=\"iter/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = <a class=\"primitive\" href=\"primitive.char.html\">char</a>;</div>","EscapeUnicode<'_>":"<h3>Notable traits for <code><a class=\"struct\" href=\"str/struct.EscapeUnicode.html\" title=\"struct std::str::EscapeUnicode\">EscapeUnicode</a>&lt;'a&gt;</code></h3><pre><code><div class=\"where\">impl&lt;'a&gt; <a class=\"trait\" href=\"iter/trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for <a class=\"struct\" href=\"str/struct.EscapeUnicode.html\" title=\"struct std::str::EscapeUnicode\">EscapeUnicode</a>&lt;'a&gt;</div><div class=\"where\">    type <a href=\"iter/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = <a class=\"primitive\" href=\"primitive.char.html\">char</a>;</div>","Lines<'_>":"<h3>Notable traits for <code><a class=\"struct\" href=\"str/struct.Lines.html\" title=\"struct std::str::Lines\">Lines</a>&lt;'a&gt;</code></h3><pre><code><div class=\"where\">impl&lt;'a&gt; <a class=\"trait\" href=\"iter/trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for <a class=\"struct\" href=\"str/struct.Lines.html\" title=\"struct std::str::Lines\">Lines</a>&lt;'a&gt;</div><div class=\"where\">    type <a href=\"iter/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = &amp;'a <a class=\"primitive\" href=\"primitive.str.html\">str</a>;</div>","LinesAny<'_>":"<h3>Notable traits for <code><a class=\"struct\" href=\"str/struct.LinesAny.html\" title=\"struct std::str::LinesAny\">LinesAny</a>&lt;'a&gt;</code></h3><pre><code><div class=\"where\">impl&lt;'a&gt; <a class=\"trait\" href=\"iter/trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for <a class=\"struct\" href=\"str/struct.LinesAny.html\" title=\"struct std::str::LinesAny\">LinesAny</a>&lt;'a&gt;</div><div class=\"where\">    type <a href=\"iter/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = &amp;'a <a class=\"primitive\" href=\"primitive.str.html\">str</a>;</div>","MatchIndices<'a, P>":"<h3>Notable traits for <code><a class=\"struct\" href=\"str/struct.MatchIndices.html\" title=\"struct std::str::MatchIndices\">MatchIndices</a>&lt;'a, P&gt;</code></h3><pre><code><div class=\"where\">impl&lt;'a, P&gt; <a class=\"trait\" href=\"iter/trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for <a class=\"struct\" href=\"str/struct.MatchIndices.html\" title=\"struct std::str::MatchIndices\">MatchIndices</a>&lt;'a, P&gt;<div class=\"where\">where\n    P: <a class=\"trait\" href=\"str/pattern/trait.Pattern.html\" title=\"trait std::str::pattern::Pattern\">Pattern</a>&lt;'a&gt;,</div></div><div class=\"where\">    type <a href=\"iter/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = (<a class=\"primitive\" href=\"primitive.usize.html\">usize</a>, &amp;'a <a class=\"primitive\" href=\"primitive.str.html\">str</a>);</div>","Matches<'a, P>":"<h3>Notable traits for <code><a class=\"struct\" href=\"str/struct.Matches.html\" title=\"struct std::str::Matches\">Matches</a>&lt;'a, P&gt;</code></h3><pre><code><div class=\"where\">impl&lt;'a, P&gt; <a class=\"trait\" href=\"iter/trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for <a class=\"struct\" href=\"str/struct.Matches.html\" title=\"struct std::str::Matches\">Matches</a>&lt;'a, P&gt;<div class=\"where\">where\n    P: <a class=\"trait\" href=\"str/pattern/trait.Pattern.html\" title=\"trait std::str::pattern::Pattern\">Pattern</a>&lt;'a&gt;,</div></div><div class=\"where\">    type <a href=\"iter/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = &amp;'a <a class=\"primitive\" href=\"primitive.str.html\">str</a>;</div>","RMatchIndices<'a, P>":"<h3>Notable traits for <code><a class=\"struct\" href=\"str/struct.RMatchIndices.html\" title=\"struct std::str::RMatchIndices\">RMatchIndices</a>&lt;'a, P&gt;</code></h3><pre><code><div class=\"where\">impl&lt;'a, P&gt; <a class=\"trait\" href=\"iter/trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for <a class=\"struct\" href=\"str/struct.RMatchIndices.html\" title=\"struct std::str::RMatchIndices\">RMatchIndices</a>&lt;'a, P&gt;<div class=\"where\">where\n    P: <a class=\"trait\" href=\"str/pattern/trait.Pattern.html\" title=\"trait std::str::pattern::Pattern\">Pattern</a>&lt;'a&gt;,\n    &lt;P as <a class=\"trait\" href=\"str/pattern/trait.Pattern.html\" title=\"trait std::str::pattern::Pattern\">Pattern</a>&lt;'a&gt;&gt;::<a class=\"associatedtype\" href=\"str/pattern/trait.Pattern.html#associatedtype.Searcher\" title=\"type std::str::pattern::Pattern::Searcher\">Searcher</a>: <a class=\"trait\" href=\"str/pattern/trait.ReverseSearcher.html\" title=\"trait std::str::pattern::ReverseSearcher\">ReverseSearcher</a>&lt;'a&gt;,</div></div><div class=\"where\">    type <a href=\"iter/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = (<a class=\"primitive\" href=\"primitive.usize.html\">usize</a>, &amp;'a <a class=\"primitive\" href=\"primitive.str.html\">str</a>);</div>","RMatches<'a, P>":"<h3>Notable traits for <code><a class=\"struct\" href=\"str/struct.RMatches.html\" title=\"struct std::str::RMatches\">RMatches</a>&lt;'a, P&gt;</code></h3><pre><code><div class=\"where\">impl&lt;'a, P&gt; <a class=\"trait\" href=\"iter/trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for <a class=\"struct\" href=\"str/struct.RMatches.html\" title=\"struct std::str::RMatches\">RMatches</a>&lt;'a, P&gt;<div class=\"where\">where\n    P: <a class=\"trait\" href=\"str/pattern/trait.Pattern.html\" title=\"trait std::str::pattern::Pattern\">Pattern</a>&lt;'a&gt;,\n    &lt;P as <a class=\"trait\" href=\"str/pattern/trait.Pattern.html\" title=\"trait std::str::pattern::Pattern\">Pattern</a>&lt;'a&gt;&gt;::<a class=\"associatedtype\" href=\"str/pattern/trait.Pattern.html#associatedtype.Searcher\" title=\"type std::str::pattern::Pattern::Searcher\">Searcher</a>: <a class=\"trait\" href=\"str/pattern/trait.ReverseSearcher.html\" title=\"trait std::str::pattern::ReverseSearcher\">ReverseSearcher</a>&lt;'a&gt;,</div></div><div class=\"where\">    type <a href=\"iter/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = &amp;'a <a class=\"primitive\" href=\"primitive.str.html\">str</a>;</div>","RSplit<'a, P>":"<h3>Notable traits for <code><a class=\"struct\" href=\"str/struct.RSplit.html\" title=\"struct std::str::RSplit\">RSplit</a>&lt;'a, P&gt;</code></h3><pre><code><div class=\"where\">impl&lt;'a, P&gt; <a class=\"trait\" href=\"iter/trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for <a class=\"struct\" href=\"str/struct.RSplit.html\" title=\"struct std::str::RSplit\">RSplit</a>&lt;'a, P&gt;<div class=\"where\">where\n    P: <a class=\"trait\" href=\"str/pattern/trait.Pattern.html\" title=\"trait std::str::pattern::Pattern\">Pattern</a>&lt;'a&gt;,\n    &lt;P as <a class=\"trait\" href=\"str/pattern/trait.Pattern.html\" title=\"trait std::str::pattern::Pattern\">Pattern</a>&lt;'a&gt;&gt;::<a class=\"associatedtype\" href=\"str/pattern/trait.Pattern.html#associatedtype.Searcher\" title=\"type std::str::pattern::Pattern::Searcher\">Searcher</a>: <a class=\"trait\" href=\"str/pattern/trait.ReverseSearcher.html\" title=\"trait std::str::pattern::ReverseSearcher\">ReverseSearcher</a>&lt;'a&gt;,</div></div><div class=\"where\">    type <a href=\"iter/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = &amp;'a <a class=\"primitive\" href=\"primitive.str.html\">str</a>;</div>","RSplitN<'a, P>":"<h3>Notable traits for <code><a class=\"struct\" href=\"str/struct.RSplitN.html\" title=\"struct std::str::RSplitN\">RSplitN</a>&lt;'a, P&gt;</code></h3><pre><code><div class=\"where\">impl&lt;'a, P&gt; <a class=\"trait\" href=\"iter/trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for <a class=\"struct\" href=\"str/struct.RSplitN.html\" title=\"struct std::str::RSplitN\">RSplitN</a>&lt;'a, P&gt;<div class=\"where\">where\n    P: <a class=\"trait\" href=\"str/pattern/trait.Pattern.html\" title=\"trait std::str::pattern::Pattern\">Pattern</a>&lt;'a&gt;,\n    &lt;P as <a class=\"trait\" href=\"str/pattern/trait.Pattern.html\" title=\"trait std::str::pattern::Pattern\">Pattern</a>&lt;'a&gt;&gt;::<a class=\"associatedtype\" href=\"str/pattern/trait.Pattern.html#associatedtype.Searcher\" title=\"type std::str::pattern::Pattern::Searcher\">Searcher</a>: <a class=\"trait\" href=\"str/pattern/trait.ReverseSearcher.html\" title=\"trait std::str::pattern::ReverseSearcher\">ReverseSearcher</a>&lt;'a&gt;,</div></div><div class=\"where\">    type <a href=\"iter/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = &amp;'a <a class=\"primitive\" href=\"primitive.str.html\">str</a>;</div>","RSplitTerminator<'a, P>":"<h3>Notable traits for <code><a class=\"struct\" href=\"str/struct.RSplitTerminator.html\" title=\"struct std::str::RSplitTerminator\">RSplitTerminator</a>&lt;'a, P&gt;</code></h3><pre><code><div class=\"where\">impl&lt;'a, P&gt; <a class=\"trait\" href=\"iter/trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for <a class=\"struct\" href=\"str/struct.RSplitTerminator.html\" title=\"struct std::str::RSplitTerminator\">RSplitTerminator</a>&lt;'a, P&gt;<div class=\"where\">where\n    P: <a class=\"trait\" href=\"str/pattern/trait.Pattern.html\" title=\"trait std::str::pattern::Pattern\">Pattern</a>&lt;'a&gt;,\n    &lt;P as <a class=\"trait\" href=\"str/pattern/trait.Pattern.html\" title=\"trait std::str::pattern::Pattern\">Pattern</a>&lt;'a&gt;&gt;::<a class=\"associatedtype\" href=\"str/pattern/trait.Pattern.html#associatedtype.Searcher\" title=\"type std::str::pattern::Pattern::Searcher\">Searcher</a>: <a class=\"trait\" href=\"str/pattern/trait.ReverseSearcher.html\" title=\"trait std::str::pattern::ReverseSearcher\">ReverseSearcher</a>&lt;'a&gt;,</div></div><div class=\"where\">    type <a href=\"iter/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = &amp;'a <a class=\"primitive\" href=\"primitive.str.html\">str</a>;</div>","Split<'a, P>":"<h3>Notable traits for <code><a class=\"struct\" href=\"str/struct.Split.html\" title=\"struct std::str::Split\">Split</a>&lt;'a, P&gt;</code></h3><pre><code><div class=\"where\">impl&lt;'a, P&gt; <a class=\"trait\" href=\"iter/trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for <a class=\"struct\" href=\"str/struct.Split.html\" title=\"struct std::str::Split\">Split</a>&lt;'a, P&gt;<div class=\"where\">where\n    P: <a class=\"trait\" href=\"str/pattern/trait.Pattern.html\" title=\"trait std::str::pattern::Pattern\">Pattern</a>&lt;'a&gt;,</div></div><div class=\"where\">    type <a href=\"iter/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = &amp;'a <a class=\"primitive\" href=\"primitive.str.html\">str</a>;</div>","SplitAsciiWhitespace<'_>":"<h3>Notable traits for <code><a class=\"struct\" href=\"str/struct.SplitAsciiWhitespace.html\" title=\"struct std::str::SplitAsciiWhitespace\">SplitAsciiWhitespace</a>&lt;'a&gt;</code></h3><pre><code><div class=\"where\">impl&lt;'a&gt; <a class=\"trait\" href=\"iter/trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for <a class=\"struct\" href=\"str/struct.SplitAsciiWhitespace.html\" title=\"struct std::str::SplitAsciiWhitespace\">SplitAsciiWhitespace</a>&lt;'a&gt;</div><div class=\"where\">    type <a href=\"iter/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = &amp;'a <a class=\"primitive\" href=\"primitive.str.html\">str</a>;</div>","SplitInclusive<'a, P>":"<h3>Notable traits for <code><a class=\"struct\" href=\"str/struct.SplitInclusive.html\" title=\"struct std::str::SplitInclusive\">SplitInclusive</a>&lt;'a, P&gt;</code></h3><pre><code><div class=\"where\">impl&lt;'a, P&gt; <a class=\"trait\" href=\"iter/trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for <a class=\"struct\" href=\"str/struct.SplitInclusive.html\" title=\"struct std::str::SplitInclusive\">SplitInclusive</a>&lt;'a, P&gt;<div class=\"where\">where\n    P: <a class=\"trait\" href=\"str/pattern/trait.Pattern.html\" title=\"trait std::str::pattern::Pattern\">Pattern</a>&lt;'a&gt;,</div></div><div class=\"where\">    type <a href=\"iter/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = &amp;'a <a class=\"primitive\" href=\"primitive.str.html\">str</a>;</div>","SplitN<'a, P>":"<h3>Notable traits for <code><a class=\"struct\" href=\"str/struct.SplitN.html\" title=\"struct std::str::SplitN\">SplitN</a>&lt;'a, P&gt;</code></h3><pre><code><div class=\"where\">impl&lt;'a, P&gt; <a class=\"trait\" href=\"iter/trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for <a class=\"struct\" href=\"str/struct.SplitN.html\" title=\"struct std::str::SplitN\">SplitN</a>&lt;'a, P&gt;<div class=\"where\">where\n    P: <a class=\"trait\" href=\"str/pattern/trait.Pattern.html\" title=\"trait std::str::pattern::Pattern\">Pattern</a>&lt;'a&gt;,</div></div><div class=\"where\">    type <a href=\"iter/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = &amp;'a <a class=\"primitive\" href=\"primitive.str.html\">str</a>;</div>","SplitTerminator<'a, P>":"<h3>Notable traits for <code><a class=\"struct\" href=\"str/struct.SplitTerminator.html\" title=\"struct std::str::SplitTerminator\">SplitTerminator</a>&lt;'a, P&gt;</code></h3><pre><code><div class=\"where\">impl&lt;'a, P&gt; <a class=\"trait\" href=\"iter/trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for <a class=\"struct\" href=\"str/struct.SplitTerminator.html\" title=\"struct std::str::SplitTerminator\">SplitTerminator</a>&lt;'a, P&gt;<div class=\"where\">where\n    P: <a class=\"trait\" href=\"str/pattern/trait.Pattern.html\" title=\"trait std::str::pattern::Pattern\">Pattern</a>&lt;'a&gt;,</div></div><div class=\"where\">    type <a href=\"iter/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = &amp;'a <a class=\"primitive\" href=\"primitive.str.html\">str</a>;</div>","SplitWhitespace<'_>":"<h3>Notable traits for <code><a class=\"struct\" href=\"str/struct.SplitWhitespace.html\" title=\"struct std::str::SplitWhitespace\">SplitWhitespace</a>&lt;'a&gt;</code></h3><pre><code><div class=\"where\">impl&lt;'a&gt; <a class=\"trait\" href=\"iter/trait.Iterator.html\" title=\"trait std::iter::Iterator\">Iterator</a> for <a class=\"struct\" href=\"str/struct.SplitWhitespace.html\" title=\"struct std::str::SplitWhitespace\">SplitWhitespace</a>&lt;'a&gt;</div><div class=\"where\">    type <a href=\"iter/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = &amp;'a <a class=\"primitive\" href=\"primitive.str.html\">str</a>;</div>","Vec<u8>":"<h3>Notable traits for <code><a class=\"struct\" href=\"vec/struct.Vec.html\" title=\"struct std::vec::Vec\">Vec</a>&lt;<a class=\"primitive\" href=\"primitive.u8.html\">u8</a>, A&gt;</code></h3><pre><code><div class=\"where\">impl&lt;A: <a class=\"trait\" href=\"alloc/trait.Allocator.html\" title=\"trait std::alloc::Allocator\">Allocator</a>&gt; <a class=\"trait\" href=\"io/trait.Write.html\" title=\"trait std::io::Write\">Write</a> for <a class=\"struct\" href=\"vec/struct.Vec.html\" title=\"struct std::vec::Vec\">Vec</a>&lt;<a class=\"primitive\" href=\"primitive.u8.html\">u8</a>, A&gt;</div>"}</script></section></div></main></body></html>