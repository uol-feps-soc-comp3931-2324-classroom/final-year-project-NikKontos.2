searchState.loadedDescShard("core", 5, "For each packed 8-bit integer maps the value to the number …\nCompute the approximate reciprocal of packed …\nCompute the approximate reciprocal of packed …\nRotate the bits in each packed 32-bit integer in a to the …\nRotate the bits in each packed 64-bit integer in a to the …\nRotate the bits in each packed 32-bit integer in a to the …\nRotate the bits in each packed 64-bit integer in a to the …\nRotate the bits in each packed 32-bit integer in a to the …\nRotate the bits in each packed 64-bit integer in a to the …\nRotate the bits in each packed 32-bit integer in a to the …\nRotate the bits in each packed 64-bit integer in a to the …\nRound packed double-precision (64-bit) floating-point …\nRound packed single-precision (32-bit) floating-point …\nRound packed double-precision (64-bit) floating-point …\nRound packed single-precision (32-bit) floating-point …\nCompute the approximate reciprocal square root of packed …\nCompute the approximate reciprocal square root of packed …\nScale the packed double-precision (64-bit) floating-point …\nScale the packed single-precision (32-bit) floating-point …\nScale the packed double-precision (64-bit) floating-point …\nScale the packed single-precision (32-bit) floating-point …\nBroadcast the low packed 16-bit integer from a to all …\nBroadcast 32-bit integer a to all elements of dst using …\nBroadcast 64-bit integer a to all elements of dst using …\nBroadcast 8-bit integer a to all elements of dst using …\nConcatenate packed 16-bit integers in a and b producing an …\nConcatenate packed 32-bit integers in a and b producing an …\nConcatenate packed 64-bit integers in a and b producing an …\nConcatenate packed 16-bit integers in a and b producing an …\nConcatenate packed 32-bit integers in a and b producing an …\nConcatenate packed 64-bit integers in a and b producing an …\nConcatenate packed 16-bit integers in b and a producing an …\nConcatenate packed 32-bit integers in b and a producing an …\nConcatenate packed 64-bit integers in b and a producing an …\nConcatenate packed 16-bit integers in b and a producing an …\nConcatenate packed 32-bit integers in b and a producing an …\nConcatenate packed 64-bit integers in b and a producing an …\nShuffle 32-bit integers in a within 128-bit lanes using …\nShuffle packed 8-bit integers in a according to shuffle …\nShuffle 128-bits (composed of 4 single-precision (32-bit) …\nShuffle 128-bits (composed of 2 double-precision (64-bit) …\nShuffle 128-bits (composed of 4 32-bit integers) selected …\nShuffle 128-bits (composed of 2 64-bit integers) selected …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle single-precision (32-bit) floating-point elements …\nShuffle 16-bit integers in the high 64 bits of 128-bit …\nShuffle 16-bit integers in the low 64 bits of 128-bit …\nShift packed 16-bit integers in a left by count while …\nShift packed 32-bit integers in a left by count while …\nShift packed 64-bit integers in a left by count while …\nShift packed 16-bit integers in a left by imm8 while …\nShift packed 32-bit integers in a left by imm8 while …\nShift packed 64-bit integers in a left by imm8 while …\nShift packed 16-bit integers in a left by the amount …\nShift packed 32-bit integers in a left by the amount …\nShift packed 64-bit integers in a left by the amount …\nCompute the square root of packed double-precision …\nCompute the square root of packed single-precision …\nCompute the square root of packed double-precision …\nCompute the square root of packed single-precision …\nShift packed 16-bit integers in a right by count while …\nShift packed 32-bit integers in a right by count while …\nShift packed 64-bit integers in a right by count while …\nShift packed 16-bit integers in a right by imm8 while …\nShift packed 32-bit integers in a right by imm8 while …\nShift packed 64-bit integers in a right by imm8 while …\nShift packed 16-bit integers in a right by the amount …\nShift packed 32-bit integers in a right by the amount …\nShift packed 64-bit integers in a right by the amount …\nShift packed 16-bit integers in a right by count while …\nShift packed 32-bit integers in a right by count while …\nShift packed 64-bit integers in a right by count while …\nShift packed 16-bit integers in a right by imm8 while …\nShift packed 32-bit integers in a right by imm8 while …\nShift packed 64-bit integers in a right by imm8 while …\nShift packed 16-bit integers in a right by the amount …\nShift packed 32-bit integers in a right by the amount …\nShift packed 64-bit integers in a right by the amount …\nSubtract packed 16-bit integers in b from packed 16-bit …\nSubtract packed 32-bit integers in b from packed 32-bit …\nSubtract packed 64-bit integers in b from packed 64-bit …\nSubtract packed 8-bit integers in b from packed 8-bit …\nSubtract packed double-precision (64-bit) floating-point …\nSubtract packed single-precision (32-bit) floating-point …\nSubtract packed double-precision (64-bit) floating-point …\nSubtract packed single-precision (32-bit) floating-point …\nSubtract packed signed 16-bit integers in b from packed …\nSubtract packed signed 8-bit integers in b from packed …\nSubtract packed unsigned 16-bit integers in b from packed …\nSubtract packed unsigned 8-bit integers in b from packed …\nBitwise ternary logic that provides the capability to …\nBitwise ternary logic that provides the capability to …\nUnpack and interleave 16-bit integers from the high half …\nUnpack and interleave 32-bit integers from the high half …\nUnpack and interleave 64-bit integers from the high half …\nUnpack and interleave 8-bit integers from the high half of …\nUnpack and interleave double-precision (64-bit) …\nUnpack and interleave single-precision (32-bit) …\nUnpack and interleave 16-bit integers from the low half of …\nUnpack and interleave 32-bit integers from the low half of …\nUnpack and interleave 64-bit integers from the low half of …\nUnpack and interleave 8-bit integers from the low half of …\nUnpack and interleave double-precision (64-bit) …\nUnpack and interleave single-precision (32-bit) …\nCompute the bitwise XOR of packed 32-bit integers in a and …\nCompute the bitwise XOR of packed 64-bit integers in a and …\nCompare packed signed 16-bit integers in a and b, and …\nCompare packed signed 32-bit integers in a and b, and …\nCompare packed signed 64-bit integers in a and b, and …\nCompare packed signed 8-bit integers in a and b, and store …\nCompare packed unsigned 16-bit integers in a and b, and …\nCompare packed unsigned 32-bit integers in a and b, and …\nCompare packed unsigned 64-bit integers in a and b, and …\nCompare packed unsigned 8-bit integers in a and b, and …\nCompare packed double-precision (64-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nCompare packed double-precision (64-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nCompare packed signed 16-bit integers in a and b, and …\nCompare packed signed 32-bit integers in a and b, and …\nCompare packed signed 64-bit integers in a and b, and …\nCompare packed signed 8-bit integers in a and b, and store …\nCompare packed unsigned 16-bit integers in a and b, and …\nCompare packed unsigned 32-bit integers in a and b, and …\nCompare packed unsigned 64-bit integers in a and b, and …\nCompare packed unsigned 8-bit integers in a and b, and …\nCompare packed double-precision (64-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nCompare packed double-precision (64-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nDuplicate even-indexed double-precision (64-bit) …\nDuplicate odd-indexed single-precision (32-bit) …\nDuplicate even-indexed single-precision (32-bit) …\nSet each bit of mask register k based on the most …\nSet each bit of mask register k based on the most …\nSet each packed 16-bit integer in dst to all ones or all …\nSet each packed 8-bit integer in dst to all ones or all …\nMultiply the low signed 32-bit integers from each packed …\nMultiply the low unsigned 32-bit integers from each packed …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply the packed signed 16-bit integers in a and b, …\nMultiply the packed unsigned 16-bit integers in a and b, …\nMultiply packed signed 16-bit integers in a and b, …\nMultiply the packed 16-bit integers in a and b, producing …\nMultiply the packed 32-bit integers in a and b, producing …\nMultiplies elements in packed 64-bit integer vectors a and …\nFor each 64-bit element in b, select 8 unaligned bytes …\nCompute the bitwise OR of packed 32-bit integers in a and …\nCompute the bitwise OR of packed 64-bit integers in a and …\nCompute the bitwise OR of 512 bits (representing integer …\nConvert packed signed 16-bit integers from a and b to …\nConvert packed signed 32-bit integers from a and b to …\nConvert packed signed 16-bit integers from a and b to …\nConvert packed signed 32-bit integers from a and b to …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle single-precision (32-bit) floating-point elements …\nShuffle 32-bit integers in a across lanes using the …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle single-precision (32-bit) floating-point elements …\nShuffle 16-bit integers in a and b across lanes using the …\nShuffle 32-bit integers in a and b across lanes using the …\nShuffle 64-bit integers in a and b across lanes using the …\nShuffle 8-bit integers in a and b across lanes using the …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle single-precision (32-bit) floating-point elements …\nShuffle 64-bit integers in a within 256-bit lanes using …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle 16-bit integers in a across lanes using the …\nShuffle 32-bit integers in a across lanes using the …\nShuffle 64-bit integers in a across lanes using the …\nShuffle 8-bit integers in a across lanes using the …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle single-precision (32-bit) floating-point elements …\nFor each packed 16-bit integer maps the value to the …\nFor each packed 32-bit integer maps the value to the …\nFor each packed 64-bit integer maps the value to the …\nFor each packed 8-bit integer maps the value to the number …\nCompute the approximate reciprocal of packed …\nCompute the approximate reciprocal of packed …\nReduce the packed 32-bit integers in a by addition. …\nReduce the packed 64-bit integers in a by addition. …\nReduce the packed double-precision (64-bit) floating-point …\nReduce the packed single-precision (32-bit) floating-point …\nReduce the packed 32-bit integers in a by bitwise AND. …\nReduce the packed 64-bit integers in a by bitwise AND. …\nReduce the packed signed 32-bit integers in a by maximum. …\nReduce the packed signed 64-bit integers in a by maximum. …\nReduce the packed unsigned 32-bit integers in a by …\nReduce the packed unsigned 64-bit integers in a by …\nReduce the packed double-precision (64-bit) floating-point …\nReduce the packed single-precision (32-bit) floating-point …\nReduce the packed signed 32-bit integers in a by minimum. …\nReduce the packed signed 64-bit integers in a by minimum. …\nReduce the packed unsigned 32-bit integers in a by …\nReduce the packed unsigned 64-bit integers in a by …\nReduce the packed double-precision (64-bit) floating-point …\nReduce the packed single-precision (32-bit) floating-point …\nReduce the packed 32-bit integers in a by multiplication. …\nReduce the packed 64-bit integers in a by multiplication. …\nReduce the packed double-precision (64-bit) floating-point …\nReduce the packed single-precision (32-bit) floating-point …\nReduce the packed 32-bit integers in a by bitwise OR. …\nReduce the packed 64-bit integers in a by bitwise OR. …\nRotate the bits in each packed 32-bit integer in a to the …\nRotate the bits in each packed 64-bit integer in a to the …\nRotate the bits in each packed 32-bit integer in a to the …\nRotate the bits in each packed 64-bit integer in a to the …\nRotate the bits in each packed 32-bit integer in a to the …\nRotate the bits in each packed 64-bit integer in a to the …\nRotate the bits in each packed 32-bit integer in a to the …\nRotate the bits in each packed 64-bit integer in a to the …\nRound packed double-precision (64-bit) floating-point …\nRound packed single-precision (32-bit) floating-point …\nRound packed double-precision (64-bit) floating-point …\nRound packed single-precision (32-bit) floating-point …\nCompute the approximate reciprocal square root of packed …\nCompute the approximate reciprocal square root of packed …\nCompute the absolute differences of packed unsigned 8-bit …\nScale the packed double-precision (64-bit) floating-point …\nScale the packed single-precision (32-bit) floating-point …\nScale the packed double-precision (64-bit) floating-point …\nScale the packed single-precision (32-bit) floating-point …\nBroadcast the low packed 16-bit integer from a to all …\nBroadcast 32-bit integer <code>a</code> to all elements of <code>dst</code>.\nBroadcast 64-bit integer <code>a</code> to all elements of <code>dst</code>.\nBroadcast 8-bit integer a to all elements of dst.\nBroadcast 64-bit float <code>a</code> to all elements of <code>dst</code>.\nBroadcast 32-bit float <code>a</code> to all elements of <code>dst</code>.\nSet packed 32-bit integers in dst with the repeated 4 …\nSet packed 64-bit integers in dst with the repeated 4 …\nSet packed double-precision (64-bit) floating-point …\nSet packed single-precision (32-bit) floating-point …\nSet packed 16-bit integers in dst with the supplied values.\nSets packed 32-bit integers in <code>dst</code> with the supplied …\nSet packed 64-bit integers in dst with the supplied values.\nSet packed 8-bit integers in dst with the supplied values.\nSet packed double-precision (64-bit) floating-point …\nSets packed 32-bit integers in <code>dst</code> with the supplied …\nSet packed 32-bit integers in dst with the repeated 4 …\nSet packed 64-bit integers in dst with the repeated 4 …\nSet packed double-precision (64-bit) floating-point …\nSet packed single-precision (32-bit) floating-point …\nSets packed 32-bit integers in <code>dst</code> with the supplied …\nSet packed 64-bit integers in dst with the supplied values …\nSet packed double-precision (64-bit) floating-point …\nSets packed 32-bit integers in <code>dst</code> with the supplied …\nReturn vector of type <code>__m512</code> with all elements set to zero.\nReturn vector of type <code>__m512i</code> with all elements set to …\nReturns vector of type <code>__m512d</code> with all elements set to …\nReturns vector of type <code>__m512</code> with all elements set to …\nReturns vector of type <code>__m512i</code> with all elements set to …\nConcatenate packed 16-bit integers in a and b producing an …\nConcatenate packed 32-bit integers in a and b producing an …\nConcatenate packed 64-bit integers in a and b producing an …\nConcatenate packed 16-bit integers in a and b producing an …\nConcatenate packed 32-bit integers in a and b producing an …\nConcatenate packed 64-bit integers in a and b producing an …\nConcatenate packed 16-bit integers in b and a producing an …\nConcatenate packed 32-bit integers in b and a producing an …\nConcatenate packed 64-bit integers in b and a producing an …\nConcatenate packed 16-bit integers in b and a producing an …\nConcatenate packed 32-bit integers in b and a producing an …\nConcatenate packed 64-bit integers in b and a producing an …\nShuffle single-precision (32-bit) floating-point elements …\nShuffle packed 8-bit integers in a according to shuffle …\nShuffle 128-bits (composed of 4 single-precision (32-bit) …\nShuffle 128-bits (composed of 2 double-precision (64-bit) …\nShuffle 128-bits (composed of 4 32-bit integers) selected …\nShuffle 128-bits (composed of 2 64-bit integers) selected …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle single-precision (32-bit) floating-point elements …\nShuffle 16-bit integers in the high 64 bits of 128-bit …\nShuffle 16-bit integers in the low 64 bits of 128-bit …\nShift packed 16-bit integers in a left by count while …\nShift packed 32-bit integers in a left by count while …\nShift packed 64-bit integers in a left by count while …\nShift packed 16-bit integers in a left by imm8 while …\nShift packed 32-bit integers in a left by imm8 while …\nShift packed 64-bit integers in a left by imm8 while …\nShift packed 16-bit integers in a left by the amount …\nShift packed 32-bit integers in a left by the amount …\nShift packed 64-bit integers in a left by the amount …\nCompute the square root of packed double-precision …\nCompute the square root of packed single-precision …\nCompute the square root of packed double-precision …\nCompute the square root of packed single-precision …\nShift packed 16-bit integers in a right by count while …\nShift packed 32-bit integers in a right by count while …\nShift packed 64-bit integers in a right by count while …\nShift packed 16-bit integers in a right by imm8 while …\nShift packed 32-bit integers in a right by imm8 while …\nShift packed 64-bit integers in a right by imm8 while …\nShift packed 16-bit integers in a right by the amount …\nShift packed 32-bit integers in a right by the amount …\nShift packed 64-bit integers in a right by the amount …\nShift packed 16-bit integers in a right by count while …\nShift packed 32-bit integers in a right by count while …\nShift packed 64-bit integers in a right by count while …\nShift packed 16-bit integers in a right by imm8 while …\nShift packed 32-bit integers in a right by imm8 while …\nShift packed 64-bit integers in a right by imm8 while …\nShift packed 16-bit integers in a right by the amount …\nShift packed 32-bit integers in a right by the amount …\nShift packed 64-bit integers in a right by the amount …\nStore 512-bits (composed of 16 packed 32-bit integers) …\nStore 512-bits (composed of 8 packed 64-bit integers) from …\nStore 512-bits (composed of 8 packed double-precision …\nStore 512-bits of integer data from a into memory. …\nStore 512-bits of integer data from a into memory. …\nStore 512-bits (composed of 32 packed 16-bit integers) …\nStore 512-bits (composed of 16 packed 32-bit integers) …\nStore 512-bits (composed of 8 packed 64-bit integers) from …\nStore 512-bits (composed of 64 packed 8-bit integers) from …\nStores 512-bits (composed of 8 packed double-precision …\nStores 512-bits (composed of 16 packed single-precision …\nStore 512-bits of integer data from a into memory. …\nStore 512-bits (composed of 8 packed double-precision …\nStore 512-bits (composed of 16 packed single-precision …\nStore 512-bits of integer data from a into memory using a …\nSubtract packed 16-bit integers in b from packed 16-bit …\nSubtract packed 32-bit integers in b from packed 32-bit …\nSubtract packed 64-bit integers in b from packed 64-bit …\nSubtract packed 8-bit integers in b from packed 8-bit …\nSubtract packed double-precision (64-bit) floating-point …\nSubtract packed single-precision (32-bit) floating-point …\nSubtract packed double-precision (64-bit) floating-point …\nSubtract packed single-precision (32-bit) floating-point …\nSubtract packed signed 16-bit integers in b from packed …\nSubtract packed signed 8-bit integers in b from packed …\nSubtract packed unsigned 16-bit integers in b from packed …\nSubtract packed unsigned 8-bit integers in b from packed …\nBitwise ternary logic that provides the capability to …\nBitwise ternary logic that provides the capability to …\nCompute the bitwise AND of packed 16-bit integers in a and …\nCompute the bitwise AND of packed 32-bit integers in a and …\nCompute the bitwise AND of packed 64-bit integers in a and …\nCompute the bitwise AND of packed 8-bit integers in a and …\nCompute the bitwise NAND of packed 16-bit integers in a …\nCompute the bitwise NAND of packed 32-bit integers in a …\nCompute the bitwise NAND of packed 64-bit integers in a …\nCompute the bitwise NAND of packed 8-bit integers in a and …\nReturn vector of type __m512 with indeterminate elements. …\nReturn vector of type __m512i with indeterminate elements. …\nReturns vector of type <code>__m512d</code> with indeterminate elements.\nReturns vector of type <code>__m512</code> with indeterminate elements. …\nUnpack and interleave 16-bit integers from the high half …\nUnpack and interleave 32-bit integers from the high half …\nUnpack and interleave 64-bit integers from the high half …\nUnpack and interleave 8-bit integers from the high half of …\nUnpack and interleave double-precision (64-bit) …\nUnpack and interleave single-precision (32-bit) …\nUnpack and interleave 16-bit integers from the low half of …\nUnpack and interleave 32-bit integers from the low half of …\nUnpack and interleave 64-bit integers from the low half of …\nUnpack and interleave 8-bit integers from the low half of …\nUnpack and interleave double-precision (64-bit) …\nUnpack and interleave single-precision (32-bit) …\nCompute the bitwise XOR of packed 32-bit integers in a and …\nCompute the bitwise XOR of packed 64-bit integers in a and …\nCompute the bitwise XOR of 512 bits (representing integer …\nCast vector of type __m128d to type __m512d; the upper 384 …\nCast vector of type __m256d to type __m512d; the upper 256 …\nCast vector of type __m128 to type __m512; the upper 384 …\nCast vector of type __m256 to type __m512; the upper 256 …\nCast vector of type __m128i to type __m512i; the upper 384 …\nCast vector of type __m256i to type __m512i; the upper 256 …\nComputes the absolute value of each of the packed 16-bit …\nComputes the absolute value of each of the packed 32-bit …\nComputes the absolute value of packed 8-bit signed …\nAdds packed 16-bit integers in <code>a</code> and <code>b</code>.\nAdds packed 32-bit integers in <code>a</code> and <code>b</code>.\nAdds packed 64-bit integers in <code>a</code> and <code>b</code>.\nAdds packed 8-bit integers in <code>a</code> and <code>b</code>.\nAdds packed double-precision (64-bit) floating-point …\nAdds __m128 vectors.\nAdd the lower double-precision (64-bit) floating-point …\nAdd the lower single-precision (32-bit) floating-point …\nReturns a new vector with the low element of <code>a</code> replaced by …\nAdds the first component of <code>a</code> and <code>b</code>, the other components …\nAdds packed 16-bit integers in <code>a</code> and <code>b</code> using saturation.\nAdds packed 8-bit integers in <code>a</code> and <code>b</code> using saturation.\nAdds packed unsigned 16-bit integers in <code>a</code> and <code>b</code> using …\nAdds packed unsigned 8-bit integers in <code>a</code> and <code>b</code> using …\nAlternatively add and subtract packed double-precision …\nAlternatively add and subtract packed single-precision …\nPerforms one round of an AES decryption flow on data …\nPerforms the last round of an AES decryption flow on data …\nPerforms one round of an AES encryption flow on data …\nPerforms the last round of an AES encryption flow on data …\nPerforms the <code>InvMixColumns</code> transformation on <code>a</code>.\nAssist in expanding the AES cipher key.\nConcatenate a and b into a 32-byte immediate result, shift …\nConcatenate a and b into a 32-byte immediate result, shift …\nConcatenate 16-byte blocks in <code>a</code> and <code>b</code> into a 32-byte …\nComputes the bitwise AND of packed double-precision …\nBitwise AND of packed single-precision (32-bit) …\nComputes the bitwise AND of 128 bits (representing integer …\nComputes the bitwise NOT of <code>a</code> and then AND with <code>b</code>.\nBitwise AND-NOT of packed single-precision (32-bit) …\nComputes the bitwise NOT of 128 bits (representing integer …\nAverages packed unsigned 16-bit integers in <code>a</code> and <code>b</code>.\nAverages packed unsigned 8-bit integers in <code>a</code> and <code>b</code>.\nConsiders the input <code>b</code> as packed 64-bit integers and <code>c</code> as …\nBlend packed 16-bit integers from <code>a</code> and <code>b</code> using the mask …\nBlends packed 32-bit integers from <code>a</code> and <code>b</code> using control …\nBlend packed double-precision (64-bit) floating-point …\nBlend packed single-precision (32-bit) floating-point …\nBlend packed 8-bit integers from <code>a</code> and <code>b</code> using <code>mask</code>\nBlend packed double-precision (64-bit) floating-point …\nBlend packed single-precision (32-bit) floating-point …\nBroadcasts a single-precision (32-bit) floating-point …\nBroadcasts the low packed 8-bit integer from <code>a</code> to all …\nBroadcasts the low packed 32-bit integer from <code>a</code> to all …\nBroadcast the low 8-bits from input mask k to all 64-bit …\nBroadcast the low 16-bits from input mask k to all 32-bit …\nBroadcasts the low packed 64-bit integer from <code>a</code> to all …\nBroadcasts the low double-precision (64-bit) …\nBroadcasts the low single-precision (32-bit) …\nBroadcasts the low packed 16-bit integer from a to all …\nShifts <code>a</code> left by <code>IMM8</code> bytes while shifting in zeros.\nShifts <code>a</code> right by <code>IMM8</code> bytes while shifting in zeros.\nCasts a 128-bit floating-point vector of <code>[2 x double]</code> into …\nCasts a 128-bit floating-point vector of <code>[2 x double]</code> into …\nCasts a 128-bit floating-point vector of <code>[4 x float]</code> into …\nCasts a 128-bit floating-point vector of <code>[4 x float]</code> into …\nCasts a 128-bit integer vector into a 128-bit …\nCasts a 128-bit integer vector into a 128-bit …\nRound the packed double-precision (64-bit) floating-point …\nRound the packed single-precision (32-bit) floating-point …\nRound the lower double-precision (64-bit) floating-point …\nRound the lower single-precision (32-bit) floating-point …\nInvalidates and flushes the cache line that contains <code>p</code> …\nPerforms a carry-less multiplication of two 64-bit …\nCompare packed signed 16-bit integers in a and b based on …\nCompare packed signed 32-bit integers in a and b based on …\nCompare packed signed 64-bit integers in a and b based on …\nCompare packed signed 8-bit integers in a and b based on …\nCompare packed unsigned 16-bit integers in a and b based …\nCompare packed unsigned 32-bit integers in a and b based …\nCompare packed unsigned 64-bit integers in a and b based …\nCompare packed unsigned 8-bit integers in a and b based on …\nCompares packed double-precision (64-bit) floating-point …\nCompare packed double-precision (64-bit) floating-point …\nCompares packed single-precision (32-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nCompare the lower double-precision (64-bit) floating-point …\nCompare the lower single-precision (32-bit) floating-point …\nCompares the lower double-precision (64-bit) …\nCompare the lower double-precision (64-bit) floating-point …\nCompares the lower single-precision (32-bit) …\nCompare the lower single-precision (32-bit) floating-point …\nCompares packed 16-bit integers in <code>a</code> and <code>b</code> for equality.\nCompare packed signed 16-bit integers in a and b for …\nCompares packed 32-bit integers in <code>a</code> and <code>b</code> for equality.\nCompare packed 32-bit integers in a and b for equality, …\nCompares packed 64-bit integers in <code>a</code> and <code>b</code> for equality\nCompare packed 64-bit integers in a and b for equality, …\nCompares packed 8-bit integers in <code>a</code> and <code>b</code> for equality.\nCompare packed signed 8-bit integers in a and b for …\nCompare packed unsigned 16-bit integers in a and b for …\nCompare packed unsigned 32-bit integers in a and b for …\nCompare packed unsigned 64-bit integers in a and b for …\nCompare packed unsigned 8-bit integers in a and b for …\nCompares corresponding elements in <code>a</code> and <code>b</code> for equality.\nCompares each of the four floats in <code>a</code> to the corresponding …\nReturns a new vector with the low element of <code>a</code> replaced by …\nCompares the lowest <code>f32</code> of both inputs for equality. The …\nCompares packed strings in <code>a</code> and <code>b</code> with lengths <code>la</code> and <code>lb</code> …\nCompares packed strings in <code>a</code> and <code>b</code> with lengths <code>la</code> and <code>lb</code> …\nCompares packed strings <code>a</code> and <code>b</code> with lengths <code>la</code> and <code>lb</code> …\nCompares packed strings in <code>a</code> and <code>b</code> with lengths <code>la</code> and <code>lb</code> …\nCompares packed strings in <code>a</code> and <code>b</code> with lengths <code>la</code> and <code>lb</code> …\nCompares packed strings in <code>a</code> and <code>b</code> with lengths <code>la</code> and <code>lb</code> …\nCompares packed strings in <code>a</code> and <code>b</code> with lengths <code>la</code> and <code>lb</code> …\nCompare packed signed 16-bit integers in a and b for …\nCompare packed signed 32-bit integers in a and b for …\nCompare packed signed 64-bit integers in a and b for …\nCompare packed signed 8-bit integers in a and b for …\nCompare packed unsigned 16-bit integers in a and b for …\nCompare packed unsigned 32-bit integers in a and b for …\nCompare packed unsigned 64-bit integers in a and b for …\nCompare packed unsigned 8-bit integers in a and b for …\nCompares corresponding elements in <code>a</code> and <code>b</code> for …\nCompares each of the four floats in <code>a</code> to the corresponding …\nReturns a new vector with the low element of <code>a</code> replaced by …\nCompares the lowest <code>f32</code> of both inputs for greater than or …\nCompares packed 16-bit integers in <code>a</code> and <code>b</code> for …\nCompare packed signed 16-bit integers in a and b for …\nCompares packed 32-bit integers in <code>a</code> and <code>b</code> for …\nCompare packed signed 32-bit integers in a and b for …\nCompares packed 64-bit integers in <code>a</code> and <code>b</code> for …\nCompare packed signed 64-bit integers in a and b for …\nCompares packed 8-bit integers in <code>a</code> and <code>b</code> for greater-than.\nCompare packed signed 8-bit integers in a and b for …\nCompare packed unsigned 16-bit integers in a and b for …\nCompare packed unsigned 32-bit integers in a and b for …\nCompare packed unsigned 64-bit integers in a and b for …\nCompare packed unsigned 8-bit integers in a and b for …\nCompares corresponding elements in <code>a</code> and <code>b</code> for …\nCompares each of the four floats in <code>a</code> to the corresponding …\nReturns a new vector with the low element of <code>a</code> replaced by …\nCompares the lowest <code>f32</code> of both inputs for greater than. …\nCompares packed strings with implicit lengths in <code>a</code> and <code>b</code> …\nCompares packed strings with implicit lengths in <code>a</code> and <code>b</code> …\nCompares packed strings with implicit lengths in <code>a</code> and <code>b</code> …\nCompares packed strings with implicit lengths in <code>a</code> and <code>b</code> …\nCompares packed strings with implicit lengths in <code>a</code> and <code>b</code> …\nCompares packed strings with implicit lengths in <code>a</code> and <code>b</code> …\nCompares packed strings with implicit lengths in <code>a</code> and <code>b</code> …\nCompare packed signed 16-bit integers in a and b for …\nCompare packed signed 32-bit integers in a and b for …\nCompare packed signed 64-bit integers in a and b for …\nCompare packed signed 8-bit integers in a and b for …\nCompare packed unsigned 16-bit integers in a and b for …\nCompare packed unsigned 32-bit integers in a and b for …\nCompare packed unsigned 64-bit integers in a and b for …\nCompare packed unsigned 8-bit integers in a and b for …\nCompares corresponding elements in <code>a</code> and <code>b</code> for …\nCompares each of the four floats in <code>a</code> to the corresponding …\nReturns a new vector with the low element of <code>a</code> replaced by …\nCompares the lowest <code>f32</code> of both inputs for less than or …\nCompares packed 16-bit integers in <code>a</code> and <code>b</code> for less-than.\nCompare packed signed 16-bit integers in a and b for …\nCompares packed 32-bit integers in <code>a</code> and <code>b</code> for less-than.\nCompare packed signed 32-bit integers in a and b for …\nCompare packed signed 64-bit integers in a and b for …\nCompares packed 8-bit integers in <code>a</code> and <code>b</code> for less-than.\nCompare packed signed 8-bit integers in a and b for …\nCompare packed unsigned 16-bit integers in a and b for …\nCompare packed unsigned 32-bit integers in a and b for …\nCompare packed unsigned 64-bit integers in a and b for …\nCompare packed unsigned 8-bit integers in a and b for …\nCompares corresponding elements in <code>a</code> and <code>b</code> for less-than.\nCompares each of the four floats in <code>a</code> to the corresponding …\nReturns a new vector with the low element of <code>a</code> replaced by …\nCompares the lowest <code>f32</code> of both inputs for less than. The …\nCompare packed signed 16-bit integers in a and b for …\nCompare packed 32-bit integers in a and b for not-equal, …\nCompare packed signed 64-bit integers in a and b for …\nCompare packed signed 8-bit integers in a and b for …\nCompare packed unsigned 16-bit integers in a and b for …\nCompare packed unsigned 32-bit integers in a and b for …\nCompare packed unsigned 64-bit integers in a and b for …\nCompare packed unsigned 8-bit integers in a and b for …\nCompares corresponding elements in <code>a</code> and <code>b</code> for not-equal.\nCompares each of the four floats in <code>a</code> to the corresponding …\nReturns a new vector with the low element of <code>a</code> replaced by …\nCompares the lowest <code>f32</code> of both inputs for inequality. The …\nCompares corresponding elements in <code>a</code> and <code>b</code> for …\nCompares each of the four floats in <code>a</code> to the corresponding …\nReturns a new vector with the low element of <code>a</code> replaced by …\nCompares the lowest <code>f32</code> of both inputs for …\nCompares corresponding elements in <code>a</code> and <code>b</code> for …\nCompares each of the four floats in <code>a</code> to the corresponding …\nReturns a new vector with the low element of <code>a</code> replaced by …\nCompares the lowest <code>f32</code> of both inputs for …\nCompares corresponding elements in <code>a</code> and <code>b</code> for …\nCompares each of the four floats in <code>a</code> to the corresponding …\nReturns a new vector with the low element of <code>a</code> replaced by …\nCompares the lowest <code>f32</code> of both inputs for …\nCompares corresponding elements in <code>a</code> and <code>b</code> for …\nCompares each of the four floats in <code>a</code> to the corresponding …\nReturns a new vector with the low element of <code>a</code> replaced by …\nCompares the lowest <code>f32</code> of both inputs for not-less-than. …\nCompares corresponding elements in <code>a</code> and <code>b</code> to see if …\nCompares each of the four floats in <code>a</code> to the corresponding …\nReturns a new vector with the low element of <code>a</code> replaced by …\nChecks if the lowest <code>f32</code> of both inputs are ordered. The …\nCompares corresponding elements in <code>a</code> and <code>b</code> to see if …\nCompares each of the four floats in <code>a</code> to the corresponding …\nReturns a new vector with the low element of <code>a</code> replaced by …\nChecks if the lowest <code>f32</code> of both inputs are unordered. The …\nCompare the lower double-precision (64-bit) floating-point …\nCompare the lower single-precision (32-bit) floating-point …\nCompares the lower element of <code>a</code> and <code>b</code> for equality.\nCompares two 32-bit floats from the low-order bits of <code>a</code> …\nCompares the lower element of <code>a</code> and <code>b</code> for …\nCompares two 32-bit floats from the low-order bits of <code>a</code> …\nCompares the lower element of <code>a</code> and <code>b</code> for greater-than.\nCompares two 32-bit floats from the low-order bits of <code>a</code> …\nCompares the lower element of <code>a</code> and <code>b</code> for …\nCompares two 32-bit floats from the low-order bits of <code>a</code> …\nCompares the lower element of <code>a</code> and <code>b</code> for less-than.\nCompares two 32-bit floats from the low-order bits of <code>a</code> …\nCompares the lower element of <code>a</code> and <code>b</code> for not-equal.\nCompares two 32-bit floats from the low-order bits of <code>a</code> …\nTest each 32-bit element of a for equality with all other …\nTest each 64-bit element of a for equality with all other …\nStarting with the initial value in <code>crc</code>, return the …\nStarting with the initial value in <code>crc</code>, return the …\nStarting with the initial value in <code>crc</code>, return the …\nConvert the signed 32-bit integer b to a single-precision …\nConvert the lower single-precision (32-bit) floating-point …\nConvert the lower double-precision (64-bit) floating-point …\nConvert the lower double-precision (64-bit) floating-point …\nConvert the lower double-precision (64-bit) floating-point …\nConvert the signed 32-bit integer b to a single-precision …\nConvert the lower single-precision (32-bit) floating-point …\nConvert the lower single-precision (32-bit) floating-point …\nConvert the lower single-precision (32-bit) floating-point …\nConvert the lower single-precision (32-bit) floating-point …\nConvert the unsigned 32-bit integer b to a …\nAlias for <code>_mm_cvtsi32_ss</code>.\nAlias for <code>_mm_cvtss_si32</code>.\nSign extend packed 16-bit integers in <code>a</code> to packed 32-bit …\nSign extend packed 16-bit integers in <code>a</code> to packed 64-bit …\nConvert packed 16-bit integers in a to packed 8-bit …\nConvert packed 32-bit integers in a to packed 16-bit …\nSign extend packed 32-bit integers in <code>a</code> to packed 64-bit …\nConvert packed 32-bit integers in a to packed 8-bit …\nConverts the lower two packed 32-bit integers in <code>a</code> to …\nConverts packed 32-bit integers in <code>a</code> to packed …\nConvert packed 64-bit integers in a to packed 16-bit …\nConvert packed 64-bit integers in a to packed 32-bit …\nConvert packed 64-bit integers in a to packed 8-bit …\nSign extend packed 8-bit integers in <code>a</code> to packed 16-bit …\nSign extend packed 8-bit integers in <code>a</code> to packed 32-bit …\nSign extend packed 8-bit integers in the low 8 bytes of <code>a</code> …\nZeroes extend packed unsigned 16-bit integers in <code>a</code> to …\nZeroes extend packed unsigned 16-bit integers in <code>a</code> to …\nZeroes extend packed unsigned 32-bit integers in <code>a</code> to …\nConvert packed unsigned 32-bit integers in a to packed …\nZeroes extend packed unsigned 8-bit integers in <code>a</code> to …\nZeroes extend packed unsigned 8-bit integers in <code>a</code> to …\nZeroes extend packed unsigned 8-bit integers in <code>a</code> to …\nConvert the signed 32-bit integer b to a double-precision …\nConvert the signed 32-bit integer b to a single-precision …\nConvert packed single-precision (32-bit) floating-point …\nConverts packed double-precision (64-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConverts packed double-precision (64-bit) floating-point …\nConverts the 4 x 16-bit half-precision float values in the …\nConverts packed single-precision (32-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConverts packed single-precision (32-bit) floating-point …\nConverts the 4 x 32-bit float values in the 128-bit vector …\nReturns the lower double-precision (64-bit) floating-point …\nConvert the lower double-precision (64-bit) floating-point …\nConverts the lower double-precision (64-bit) …\nConverts the lower double-precision (64-bit) …\nConvert the lower double-precision (64-bit) floating-point …\nConvert packed signed 16-bit integers in a to packed 8-bit …\nConvert packed signed 32-bit integers in a to packed …\nConvert packed signed 32-bit integers in a to packed 8-bit …\nConvert packed signed 64-bit integers in a to packed …\nConvert packed signed 64-bit integers in a to packed …\nConvert packed signed 64-bit integers in a to packed 8-bit …\nReturns the lowest element of <code>a</code>.\nReturns <code>a</code> with its lower element replaced by <code>b</code> after …\nReturns a vector whose lowest element is <code>a</code> and all higher …\nConverts a 32 bit integer to a 32 bit float. The result …\nExtracts the lowest 32 bit float from the input vector.\nConvert the lower single-precision (32-bit) floating-point …\nConverts the lower single-precision (32-bit) …\nConverts the lowest 32 bit float in the input vector to a …\nConvert the lower single-precision (32-bit) floating-point …\nConvert the lower double-precision (64-bit) floating-point …\nConvert the lower double-precision (64-bit) floating-point …\nConvert the lower double-precision (64-bit) floating-point …\nConvert the lower single-precision (32-bit) floating-point …\nConvert the lower single-precision (32-bit) floating-point …\nConvert the lower single-precision (32-bit) floating-point …\nAlias for <code>_mm_cvttss_si32</code>.\nConverts packed double-precision (64-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConverts packed single-precision (32-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert the lower double-precision (64-bit) floating-point …\nConverts the lower double-precision (64-bit) …\nConvert the lower double-precision (64-bit) floating-point …\nConvert the lower single-precision (32-bit) floating-point …\nConverts the lowest 32 bit float in the input vector to a …\nConvert the lower single-precision (32-bit) floating-point …\nConvert the unsigned 32-bit integer b to a …\nConvert the unsigned 32-bit integer b to a …\nConvert packed unsigned 16-bit integers in a to packed …\nConvert packed unsigned 32-bit integers in a to packed …\nConvert packed unsigned 32-bit integers in a to packed …\nConvert packed unsigned 64-bit integers in a to packed …\nConvert packed unsigned 64-bit integers in a to packed …\nConvert packed unsigned 64-bit integers in a to packed …\nCompute the sum of absolute differences (SADs) of …\nDivide packed double-precision (64-bit) floating-point …\nDivides __m128 vectors.\nDivide the lower double-precision (64-bit) floating-point …\nDivide the lower single-precision (32-bit) floating-point …\nReturns a new vector with the low element of <code>a</code> replaced by …\nDivides the first component of <code>b</code> by <code>a</code>, the other …\nReturns the dot product of two __m128d vectors.\nReturns the dot product of two __m128 vectors.\nCompute dot-product of BF16 (16-bit) floating-point pairs …\nMultiply groups of 4 adjacent pairs of unsigned 8-bit …\nMultiply groups of 4 adjacent pairs of unsigned 8-bit …\nMultiply groups of 2 adjacent pairs of signed 16-bit …\nMultiply groups of 2 adjacent pairs of signed 16-bit …\nReturns the <code>imm8</code> element of <code>a</code>.\nExtracts an 32-bit integer from <code>a</code> selected with <code>IMM8</code>\nExtracts an 8-bit integer from <code>a</code>, selected with <code>IMM8</code>. …\nExtracts a single-precision (32-bit) floating-point …\nExtracts the bit range specified by <code>y</code> from the lower 64 …\nFix up packed double-precision (64-bit) floating-point …\nFix up packed single-precision (32-bit) floating-point …\nFix up the lower double-precision (64-bit) floating-point …\nFix up the lower single-precision (32-bit) floating-point …\nFix up the lower double-precision (64-bit) floating-point …\nFix up the lower single-precision (32-bit) floating-point …\nRound the packed double-precision (64-bit) floating-point …\nRound the packed single-precision (32-bit) floating-point …\nRound the lower double-precision (64-bit) floating-point …\nRound the lower single-precision (32-bit) floating-point …\nMultiplies packed double-precision (64-bit) floating-point …\nMultiplies packed single-precision (32-bit) floating-point …\nMultiply the lower double-precision (64-bit) …\nMultiply the lower single-precision (32-bit) …\nMultiplies the lower double-precision (64-bit) …\nMultiplies the lower single-precision (32-bit) …\nMultiplies packed double-precision (64-bit) floating-point …\nMultiplies packed single-precision (32-bit) floating-point …\nMultiplies packed double-precision (64-bit) floating-point …\nMultiplies packed single-precision (32-bit) floating-point …\nMultiply the lower double-precision (64-bit) …\nMultiply the lower single-precision (32-bit) …\nMultiplies the lower double-precision (64-bit) …\nMultiplies the lower single-precision (32-bit) …\nMultiplies packed double-precision (64-bit) floating-point …\nMultiplies packed single-precision (32-bit) floating-point …\nMultiplies packed double-precision (64-bit) floating-point …\nMultiplies packed single-precision (32-bit) floating-point …\nMultiply the lower double-precision (64-bit) …\nMultiply the lower single-precision (32-bit) …\nMultiplies the lower double-precision (64-bit) …\nMultiplies the lower single-precision (32-bit) …\nMultiplies packed double-precision (64-bit) floating-point …\nMultiplies packed single-precision (32-bit) floating-point …\nMultiply the lower double-precision (64-bit) …\nMultiply the lower single-precision (32-bit) …\nMultiplies the lower double-precision (64-bit) …\nMultiplies the lower single-precision (32-bit) …\nGets the unsigned 32-bit value of the MXCSR control and …\nConvert the exponent of each packed double-precision …\nConvert the exponent of each packed single-precision …\nConvert the exponent of the lower double-precision …\nConvert the exponent of the lower single-precision …\nConvert the exponent of the lower double-precision …\nConvert the exponent of the lower single-precision …\nNormalize the mantissas of packed double-precision …\nNormalize the mantissas of packed single-precision …\nNormalize the mantissas of the lower double-precision …\nNormalize the mantissas of the lower single-precision …\nNormalize the mantissas of the lower double-precision …\nNormalize the mantissas of the lower single-precision …\nPerforms an affine transformation on the packed bytes in x.\nPerforms an affine transformation on the inverted packed …\nPerforms a multiplication in GF(2^8) on the packed bytes. …\nHorizontally adds the adjacent pairs of values contained …\nHorizontally adds the adjacent pairs of values contained …\nHorizontally adds adjacent pairs of double-precision …\nHorizontally adds adjacent pairs of single-precision …\nHorizontally adds the adjacent pairs of values contained …\nHorizontally subtract the adjacent pairs of values …\nHorizontally subtract the adjacent pairs of values …\nHorizontally subtract adjacent pairs of double-precision …\nHorizontally adds adjacent pairs of single-precision …\nHorizontally subtract the adjacent pairs of values …\nReturns values from <code>slice</code> at offsets determined by …\nReturns values from <code>slice</code> at offsets determined by …\nReturns values from <code>slice</code> at offsets determined by …\nReturns values from <code>slice</code> at offsets determined by …\nReturns values from <code>slice</code> at offsets determined by …\nReturns values from <code>slice</code> at offsets determined by …\nReturns values from <code>slice</code> at offsets determined by …\nReturns values from <code>slice</code> at offsets determined by …\nReturns a new vector where the <code>imm8</code> element of <code>a</code> is …\nReturns a copy of <code>a</code> with the 32-bit integer from <code>i</code> …\nReturns a copy of <code>a</code> with the 8-bit integer from <code>i</code> inserted …\nSelect a single value in <code>b</code> to store at some position in <code>a</code>, …\nInserts the <code>[length:0]</code> bits of <code>y</code> into <code>x</code> at <code>index</code>.\nLoads 128-bits of integer data from unaligned memory. This …\nPerforms a serializing operation on all load-from-memory …\nLoads a double-precision (64-bit) floating-point element …\nConstruct a <code>__m128</code> by duplicating the value read from <code>p</code> …\nLoad 128-bits (composed of 4 packed 32-bit integers) from …\nLoad 128-bits (composed of 2 packed 64-bit integers) from …\nLoads 128-bits (composed of 2 packed double-precision …\nLoads a double-precision (64-bit) floating-point element …\nLoads four <code>f32</code> values from <em>aligned</em> memory into a <code>__m128</code>. …\nAlias for <code>_mm_load1_ps</code>\nLoads a 64-bit double-precision value to the low element …\nLoads 128-bits of integer data from memory into a new …\nConstruct a <code>__m128</code> with the lowest element read from <code>p</code> and …\nLoads a double-precision (64-bit) floating-point element …\nLoads a double-precision value into the high-order bits of …\nLoads 64-bit integer from memory into first element of …\nLoads a double-precision value into the low-order bits of …\nLoads 2 double-precision (64-bit) floating-point elements …\nLoads four <code>f32</code> values from aligned memory into a <code>__m128</code> in …\nLoad 128-bits (composed of 8 packed 16-bit integers) from …\nLoad 128-bits (composed of 4 packed 32-bit integers) from …\nLoad 128-bits (composed of 2 packed 64-bit integers) from …\nLoad 128-bits (composed of 16 packed 8-bit integers) from …\nLoads 128-bits (composed of 2 packed double-precision …\nLoads four <code>f32</code> values from memory into a <code>__m128</code>. There are …\nLoads 128-bits of integer data from memory into a new …\nLoads unaligned 64-bits of integer data from memory into …\nCounts the number of leading zero bits in each packed …\nCounts the number of leading zero bits in each packed …\nMultiply packed unsigned 52-bit integers in each 64-bit …\nMultiply packed unsigned 52-bit integers in each 64-bit …\nMultiplies and then horizontally add signed 16 bit …\nMultiplies corresponding pairs of packed 8-bit unsigned …\nShuffle 16-bit integers in a and b across lanes using the …\nShuffle 32-bit integers in a and b across lanes using the …\nShuffle 64-bit integers in a and b across lanes using the …\nShuffle 8-bit integers in a and b across lanes using the …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle single-precision (32-bit) floating-point elements …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply the lower double-precision (64-bit) …\nMultiply the lower single-precision (32-bit) …\nMultiply the lower double-precision (64-bit) …\nMultiply the lower single-precision (32-bit) …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply the lower double-precision (64-bit) …\nMultiply the lower single-precision (32-bit) …\nMultiply the lower double-precision (64-bit) …\nMultiply the lower single-precision (32-bit) …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply the lower double-precision (64-bit) …\nMultiply the lower single-precision (32-bit) …\nMultiply the lower double-precision (64-bit) …\nMultiply the lower single-precision (32-bit) …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply the lower double-precision (64-bit) …\nMultiply the lower single-precision (32-bit) …\nMultiply the lower double-precision (64-bit) …\nMultiply the lower single-precision (32-bit) …\nCompute the absolute value of packed signed 16-bit …\nCompute the absolute value of packed signed 32-bit …\nCompute the absolute value of packed signed 8-bit integers …\nAdd packed 16-bit integers in a and b, and store the …\nAdd packed 32-bit integers in a and b, and store the …\nAdd packed 64-bit integers in a and b, and store the …\nAdd packed 8-bit integers in a and b, and store the …\nAdd packed double-precision (64-bit) floating-point …\nAdd packed single-precision (32-bit) floating-point …\nAdd the lower double-precision (64-bit) floating-point …\nAdd the lower single-precision (32-bit) floating-point …\nAdd the lower double-precision (64-bit) floating-point …\nAdd the lower single-precision (32-bit) floating-point …\nAdd packed signed 16-bit integers in a and b using …\nAdd packed signed 8-bit integers in a and b using …\nAdd packed unsigned 16-bit integers in a and b using …\nAdd packed unsigned 8-bit integers in a and b using …\nConcatenate a and b into a 32-byte immediate result, shift …\nConcatenate a and b into a 32-byte immediate result, shift …\nConcatenate pairs of 16-byte blocks in a and b into a …\nPerforms element-by-element bitwise AND between packed …\nCompute the bitwise AND of packed 64-bit integers in a and …\nCompute the bitwise NOT of packed 32-bit integers in a and …\nCompute the bitwise NOT of packed 64-bit integers in a and …\nAverage packed unsigned 16-bit integers in a and b, and …\nAverage packed unsigned 8-bit integers in a and b, and …\nConsiders the input <code>b</code> as packed 64-bit integers and <code>c</code> as …\nBlend packed 16-bit integers from a and b using control …\nBlend packed 32-bit integers from a and b using control …\nBlend packed 64-bit integers from a and b using control …\nBlend packed 8-bit integers from a and b using control …\nBlend packed double-precision (64-bit) floating-point …\nBlend packed single-precision (32-bit) floating-point …\nBroadcast the low packed 8-bit integer from a to all …\nBroadcast the low packed 32-bit integer from a to all …\nBroadcast the low packed 64-bit integer from a to all …\nBroadcast the low single-precision (32-bit) floating-point …\nBroadcast the low packed 16-bit integer from a to all …\nCompare packed signed 16-bit integers in a and b based on …\nCompare packed signed 32-bit integers in a and b based on …\nCompare packed signed 64-bit integers in a and b based on …\nCompare packed signed 8-bit integers in a and b based on …\nCompare packed unsigned 16-bit integers in a and b based …\nCompare packed unsigned 32-bit integers in a and b based …\nCompare packed unsigned 64-bit integers in a and b based …\nCompare packed unsigned 8-bit integers in a and b based on …\nCompare packed double-precision (64-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nCompare the lower double-precision (64-bit) floating-point …\nCompare the lower single-precision (32-bit) floating-point …\nCompare the lower double-precision (64-bit) floating-point …\nCompare the lower single-precision (32-bit) floating-point …\nCompare packed signed 16-bit integers in a and b for …\nCompare packed 32-bit integers in a and b for equality, …\nCompare packed 64-bit integers in a and b for equality, …\nCompare packed signed 8-bit integers in a and b for …\nCompare packed unsigned 16-bit integers in a and b for …\nCompare packed unsigned 32-bit integers in a and b for …\nCompare packed unsigned 64-bit integers in a and b for …\nCompare packed unsigned 8-bit integers in a and b for …\nCompare packed signed 16-bit integers in a and b for …\nCompare packed signed 32-bit integers in a and b for …\nCompare packed signed 64-bit integers in a and b for …\nCompare packed signed 8-bit integers in a and b for …\nCompare packed unsigned 16-bit integers in a and b for …\nCompare packed unsigned 32-bit integers in a and b for …\nCompare packed unsigned 64-bit integers in a and b for …\nCompare packed unsigned 8-bit integers in a and b for …\nCompare packed signed 16-bit integers in a and b for …\nCompare packed signed 32-bit integers in a and b for …\nCompare packed signed 64-bit integers in a and b for …\nCompare packed signed 8-bit integers in a and b for …\nCompare packed unsigned 16-bit integers in a and b for …\nCompare packed unsigned 32-bit integers in a and b for …\nCompare packed unsigned 64-bit integers in a and b for …\nCompare packed unsigned 8-bit integers in a and b for …\nCompare packed signed 16-bit integers in a and b for …\nCompare packed signed 32-bit integers in a and b for …\nCompare packed signed 64-bit integers in a and b for …\nCompare packed signed 8-bit integers in a and b for …\nCompare packed unsigned 16-bit integers in a and b for …\nCompare packed unsigned 32-bit integers in a and b for …\nCompare packed unsigned 64-bit integers in a and b for …\nCompare packed unsigned 8-bit integers in a and b for …\nCompare packed signed 16-bit integers in a and b for …\nCompare packed signed 32-bit integers in a and b for …\nCompare packed signed 64-bit integers in a and b for …\nCompare packed signed 8-bit integers in a and b for …\nCompare packed unsigned 16-bit integers in a and b for …\nCompare packed unsigned 32-bit integers in a and b for …\nCompare packed unsigned 64-bit integers in a and b for …\nCompare packed unsigned 8-bit integers in a and b for …\nCompare packed signed 16-bit integers in a and b for …\nCompare packed 32-bit integers in a and b for not-equal, …\nCompare packed signed 64-bit integers in a and b for …\nCompare packed signed 8-bit integers in a and b for …\nCompare packed unsigned 16-bit integers in a and b for …\nCompare packed unsigned 32-bit integers in a and b for …\nCompare packed unsigned 64-bit integers in a and b for …\nCompare packed unsigned 8-bit integers in a and b for …\nContiguously store the active 16-bit integers in a (those …\nContiguously store the active 32-bit integers in a (those …\nContiguously store the active 64-bit integers in a (those …\nContiguously store the active 8-bit integers in a (those …\nContiguously store the active double-precision (64-bit) …\nContiguously store the active single-precision (32-bit) …\nContiguously store the active 16-bit integers in a (those …\nContiguously store the active 32-bit integers in a (those …\nContiguously store the active 64-bit integers in a (those …\nContiguously store the active 8-bit integers in a (those …\nContiguously store the active double-precision (64-bit) …\nContiguously store the active single-precision (32-bit) …\nTest each 32-bit element of a for equality with all other …\nTest each 64-bit element of a for equality with all other …\nConvert packed single-precision (32-bit) floating-point …\nConvert the lower double-precision (64-bit) floating-point …\nConvert the lower single-precision (32-bit) floating-point …\nSign extend packed 16-bit integers in a to packed 32-bit …\nSign extend packed 16-bit integers in a to packed 64-bit …\nConvert packed 16-bit integers in a to packed 8-bit …\nConvert packed 16-bit integers in a to packed 8-bit …\nConvert packed 32-bit integers in a to packed 16-bit …\nSign extend packed 32-bit integers in a to packed 64-bit …\nConvert packed 32-bit integers in a to packed 8-bit …\nConvert packed signed 32-bit integers in a to packed …\nConvert packed signed 32-bit integers in a to packed …\nConvert packed 32-bit integers in a to packed 16-bit …\nConvert packed 32-bit integers in a to packed 8-bit …\nConvert packed 64-bit integers in a to packed 16-bit …\nConvert packed 64-bit integers in a to packed 32-bit …\nConvert packed 64-bit integers in a to packed 8-bit …\nConvert packed 64-bit integers in a to packed 16-bit …\nConvert packed 64-bit integers in a to packed 32-bit …\nConvert packed 64-bit integers in a to packed 8-bit …\nSign extend packed 8-bit integers in a to packed 16-bit …\nSign extend packed 8-bit integers in a to packed 32-bit …\nSign extend packed 8-bit integers in the low 2 bytes of a …\nZero extend packed unsigned 16-bit integers in a to packed …\nZero extend packed unsigned 16-bit integers in the low 4 …\nZero extend packed unsigned 32-bit integers in a to packed …\nConvert packed unsigned 32-bit integers in a to packed …\nZero extend packed unsigned 8-bit integers in a to packed …\nZero extend packed unsigned 8-bit integers in the low 4 …\nZero extend packed unsigned 8-bit integers in the low 2 …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed half-precision (16-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert the lower double-precision (64-bit) floating-point …\nConvert packed signed 16-bit integers in a to packed 8-bit …\nConvert packed signed 16-bit integers in a to packed 8-bit …\nConvert packed signed 32-bit integers in a to packed …\nConvert packed signed 32-bit integers in a to packed 8-bit …\nConvert packed signed 32-bit integers in a to packed …\nConvert packed signed 32-bit integers in a to packed 8-bit …\nConvert packed signed 64-bit integers in a to packed …\nConvert packed signed 64-bit integers in a to packed …\nConvert packed signed 64-bit integers in a to packed 8-bit …\nConvert packed signed 64-bit integers in a to packed …\nConvert packed signed 64-bit integers in a to packed …\nConvert packed signed 64-bit integers in a to packed 8-bit …\nConvert the lower single-precision (32-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed double-precision (32-bit) floating-point …\nConvert packed unsigned 16-bit integers in a to packed …\nConvert packed unsigned 16-bit integers in a to packed …\nConvert packed unsigned 32-bit integers in a to packed …\nConvert packed unsigned 32-bit integers in a to packed …\nConvert packed unsigned 32-bit integers in a to packed …\nConvert packed unsigned 32-bit integers in a to packed …\nConvert packed unsigned 64-bit integers in a to packed …\nConvert packed unsigned 64-bit integers in a to packed …\nConvert packed unsigned 64-bit integers in a to packed …\nConvert packed unsigned 64-bit integers in a to packed …\nConvert packed unsigned 64-bit integers in a to packed …\nConvert packed unsigned 64-bit integers in a to packed …\nCompute the sum of absolute differences (SADs) of …\nDivide packed double-precision (64-bit) floating-point …\nDivide packed single-precision (32-bit) floating-point …\nDivide the lower double-precision (64-bit) floating-point …\nDivide the lower single-precision (32-bit) floating-point …\nDivide the lower double-precision (64-bit) floating-point …\nDivide the lower single-precision (32-bit) floating-point …\nCompute dot-product of BF16 (16-bit) floating-point pairs …\nMultiply groups of 4 adjacent pairs of unsigned 8-bit …\nMultiply groups of 4 adjacent pairs of unsigned 8-bit …\nMultiply groups of 2 adjacent pairs of signed 16-bit …\nMultiply groups of 2 adjacent pairs of signed 16-bit …\nLoad contiguous active 16-bit integers from a (those with …\nLoad contiguous active 32-bit integers from a (those with …\nLoad contiguous active 64-bit integers from a (those with …\nLoad contiguous active 8-bit integers from a (those with …\nLoad contiguous active double-precision (64-bit) …\nLoad contiguous active single-precision (32-bit) …\nLoad contiguous active 16-bit integers from unaligned …\nLoad contiguous active 32-bit integers from unaligned …\nLoad contiguous active 64-bit integers from unaligned …\nLoad contiguous active 8-bit integers from unaligned …\nLoad contiguous active double-precision (64-bit) …\nLoad contiguous active single-precision (32-bit) …\nFix up packed double-precision (64-bit) floating-point …\nFix up packed single-precision (32-bit) floating-point …\nFix up the lower double-precision (64-bit) floating-point …\nFix up the lower single-precision (32-bit) floating-point …\nFix up the lower double-precision (64-bit) floating-point …\nFix up the lower single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply the lower double-precision (64-bit) …\nMultiply the lower single-precision (32-bit) …\nMultiply the lower double-precision (64-bit) …\nMultiply the lower single-precision (32-bit) …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply the lower double-precision (64-bit) …\nMultiply the lower single-precision (32-bit) …\nMultiply the lower double-precision (64-bit) …\nMultiply the lower single-precision (32-bit) …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply the lower double-precision (64-bit) …\nMultiply the lower single-precision (32-bit) …\nMultiply the lower double-precision (64-bit) …\nMultiply the lower single-precision (32-bit) …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply the lower double-precision (64-bit) …\nMultiply the lower single-precision (32-bit) …\nMultiply the lower double-precision (64-bit) …\nMultiply the lower single-precision (32-bit) …\nConvert the exponent of each packed double-precision …\nConvert the exponent of each packed single-precision …\nConvert the exponent of the lower double-precision …\nConvert the exponent of the lower single-precision …\nConvert the exponent of the lower double-precision …\nConvert the exponent of the lower single-precision …\nNormalize the mantissas of packed double-precision …\nNormalize the mantissas of packed single-precision …\nNormalize the mantissas of the lower double-precision …\nNormalize the mantissas of the lower single-precision …\nNormalize the mantissas of the lower double-precision …\nNormalize the mantissas of the lower single-precision …\nPerforms an affine transformation on the packed bytes in x.\nPerforms an affine transformation on the inverted packed …\nPerforms a multiplication in GF(2^8) on the packed bytes. …\nReturns values from <code>slice</code> at offsets determined by …\nReturns values from <code>slice</code> at offsets determined by …\nReturns values from <code>slice</code> at offsets determined by …\nReturns values from <code>slice</code> at offsets determined by …\nReturns values from <code>slice</code> at offsets determined by …\nReturns values from <code>slice</code> at offsets determined by …\nReturns values from <code>slice</code> at offsets determined by …\nReturns values from <code>slice</code> at offsets determined by …\nLoad packed 32-bit integers from memory into dst using …\nLoad packed 64-bit integers from memory into dst using …\nLoad packed double-precision (64-bit) floating-point …\nLoad packed single-precision (32-bit) floating-point …\nLoad packed 16-bit integers from memory into dst using …\nLoad packed 32-bit integers from memory into dst using …\nLoad packed 64-bit integers from memory into dst using …\nLoad packed 8-bit integers from memory into dst using …\nLoad packed double-precision (64-bit) floating-point …\nLoad packed single-precision (32-bit) floating-point …\nCounts the number of leading zero bits in each packed …\nCounts the number of leading zero bits in each packed …\nMultiply packed signed 16-bit integers in a and b, …\nMultiply packed unsigned 8-bit integers in a by packed …\nCompare packed signed 16-bit integers in a and b, and …\nCompare packed signed 32-bit integers in a and b, and …\nCompare packed signed 64-bit integers in a and b, and …\nCompare packed signed 8-bit integers in a and b, and store …\nCompare packed unsigned 16-bit integers in a and b, and …\nCompare packed unsigned 32-bit integers in a and b, and …\nCompare packed unsigned 64-bit integers in a and b, and …\nCompare packed unsigned 8-bit integers in a and b, and …\nCompare packed double-precision (64-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nCompare the lower double-precision (64-bit) floating-point …\nCompare the lower single-precision (32-bit) floating-point …\nCompare the lower double-precision (64-bit) floating-point …\nCompare the lower single-precision (32-bit) floating-point …\nCompare packed signed 16-bit integers in a and b, and …\nCompare packed signed 32-bit integers in a and b, and …\nCompare packed signed 8-bit integers in a and b, and store …\nCompare packed unsigned 16-bit integers in a and b, and …\nCompare packed unsigned 32-bit integers in a and b, and …\nCompare packed unsigned 64-bit integers in a and b, and …\nCompare packed unsigned 8-bit integers in a and b, and …\nCompare packed double-precision (64-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nCompare the lower double-precision (64-bit) floating-point …\nCompare the lower single-precision (32-bit) floating-point …\nCompare the lower double-precision (64-bit) floating-point …\nCompare the lower single-precision (32-bit) floating-point …\nMove packed 16-bit integers from a into dst using …\nMove packed 32-bit integers from a to dst using writemask …\nMove packed 64-bit integers from a to dst using writemask …\nMove packed 8-bit integers from a into dst using writemask …\nMove packed double-precision (64-bit) floating-point …\nMove packed single-precision (32-bit) floating-point …\nMove the lower double-precision (64-bit) floating-point …\nMove the lower single-precision (32-bit) floating-point …\nDuplicate even-indexed double-precision (64-bit) …\nDuplicate odd-indexed single-precision (32-bit) …\nDuplicate even-indexed single-precision (32-bit) …\nMultiply the low signed 32-bit integers from each packed …\nMultiply the low unsigned 32-bit integers from each packed …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply the lower double-precision (64-bit) …\nMultiply the lower single-precision (32-bit) …\nMultiply the lower double-precision (64-bit) …\nMultiply the lower single-precision (32-bit) …\nMultiply the packed signed 16-bit integers in a and b, …\nMultiply the packed unsigned 16-bit integers in a and b, …\nMultiply packed signed 16-bit integers in a and b, …\nMultiply the packed 16-bit integers in a and b, producing …\nMultiply the packed 32-bit integers in a and b, producing …\nFor each 64-bit element in b, select 8 unaligned bytes …\nCompute the bitwise OR of packed 32-bit integers in a and …\nCompute the bitwise OR of packed 64-bit integers in a and …\nConvert packed signed 16-bit integers from a and b to …\nConvert packed signed 32-bit integers from a and b to …\nConvert packed signed 16-bit integers from a and b to …\nConvert packed signed 32-bit integers from a and b to …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle single-precision (32-bit) floating-point elements …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle single-precision (32-bit) floating-point elements …\nShuffle 16-bit integers in a and b across lanes using the …\nShuffle 32-bit integers in a and b across lanes using the …\nShuffle 64-bit integers in a and b across lanes using the …\nShuffle 8-bit integers in a and b across lanes using the …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle single-precision (32-bit) floating-point elements …\nShuffle 16-bit integers in a across lanes using the …\nShuffle 8-bit integers in a across lanes using the …\nFor each packed 16-bit integer maps the value to the …\nFor each packed 32-bit integer maps the value to the …\nFor each packed 64-bit integer maps the value to the …\nFor each packed 8-bit integer maps the value to the number …\nCompute the approximate reciprocal of packed …\nCompute the approximate reciprocal of packed …\nCompute the approximate reciprocal of the lower …\nCompute the approximate reciprocal of the lower …\nRotate the bits in each packed 32-bit integer in a to the …\nRotate the bits in each packed 64-bit integer in a to the …\nRotate the bits in each packed 32-bit integer in a to the …\nRotate the bits in each packed 64-bit integer in a to the …\nRotate the bits in each packed 32-bit integer in a to the …\nRotate the bits in each packed 64-bit integer in a to the …\nRotate the bits in each packed 32-bit integer in a to the …\nRotate the bits in each packed 64-bit integer in a to the …\nRound packed double-precision (64-bit) floating-point …\nRound packed single-precision (32-bit) floating-point …\nRound the lower double-precision (64-bit) floating-point …\nRound the lower single-precision (32-bit) floating-point …\nRound the lower double-precision (64-bit) floating-point …\nRound the lower single-precision (32-bit) floating-point …\nCompute the approximate reciprocal square root of packed …\nCompute the approximate reciprocal square root of packed …\nCompute the approximate reciprocal square root of the …\nCompute the approximate reciprocal square root of the …\nScale the packed double-precision (64-bit) floating-point …\nScale the packed single-precision (32-bit) floating-point …\nScale the packed double-precision (64-bit) floating-point …\nScale the packed single-precision (32-bit) floating-point …\nScale the packed double-precision (64-bit) floating-point …\nScale the packed single-precision (32-bit) floating-point …\nBroadcast 16-bit integer a to all elements of dst using …\nBroadcast 32-bit integer a to all elements of dst using …\nBroadcast 64-bit integer a to all elements of dst using …\nBroadcast 8-bit integer a to all elements of dst using …\nConcatenate packed 16-bit integers in a and b producing an …\nConcatenate packed 32-bit integers in a and b producing an …\nConcatenate packed 64-bit integers in a and b producing an …\nConcatenate packed 16-bit integers in a and b producing an …\nConcatenate packed 32-bit integers in a and b producing an …\nConcatenate packed 64-bit integers in a and b producing an …\nConcatenate packed 16-bit integers in b and a producing an …\nConcatenate packed 32-bit integers in b and a producing an …\nConcatenate packed 64-bit integers in b and a producing an …\nConcatenate packed 16-bit integers in b and a producing an …\nConcatenate packed 32-bit integers in b and a producing an …\nConcatenate packed 64-bit integers in b and a producing an …\nShuffle 32-bit integers in a within 128-bit lanes using …\nShuffle 8-bit integers in a within 128-bit lanes using the …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle single-precision (32-bit) floating-point elements …\nShuffle 16-bit integers in the high 64 bits of 128-bit …\nShuffle 16-bit integers in the low 64 bits of 128-bit …\nShift packed 16-bit integers in a left by count while …\nShift packed 32-bit integers in a left by count while …\nShift packed 64-bit integers in a left by count while …\nShift packed 16-bit integers in a left by imm8 while …\nShift packed 32-bit integers in a left by imm8 while …\nShift packed 64-bit integers in a left by imm8 while …\nShift packed 16-bit integers in a left by the amount …\nShift packed 32-bit integers in a left by the amount …\nShift packed 64-bit integers in a left by the amount …\nCompute the square root of packed double-precision …\nCompute the square root of packed single-precision …\nCompute the square root of the lower double-precision …\nCompute the square root of the lower single-precision …\nCompute the square root of the lower double-precision …\nCompute the square root of the lower single-precision …\nShift packed 16-bit integers in a right by count while …\nShift packed 32-bit integers in a right by count while …\nShift packed 64-bit integers in a right by count while …\nShift packed 16-bit integers in a right by imm8 while …\nShift packed 32-bit integers in a right by imm8 while …\nShift packed 64-bit integers in a right by imm8 while …\nShift packed 16-bit integers in a right by the amount …\nShift packed 32-bit integers in a right by the amount …\nShift packed 64-bit integers in a right by the amount …\nShift packed 16-bit integers in a right by count while …\nShift packed 32-bit integers in a right by count while …\nShift packed 64-bit integers in a right by count while …\nShift packed 16-bit integers in a right by imm8 while …\nShift packed 32-bit integers in a right by imm8 while …\nShift packed 64-bit integers in a right by imm8 while …\nShift packed 16-bit integers in a right by the amount …\nShift packed 32-bit integers in a right by the amount …\nShift packed 64-bit integers in a right by the amount …\nStore packed 32-bit integers from a into memory using …\nStore packed 64-bit integers from a into memory using …\nStore packed double-precision (64-bit) floating-point …\nStore packed single-precision (32-bit) floating-point …\nStore packed 16-bit integers from a into memory using …\nStore packed 32-bit integers from a into memory using …\nStore packed 64-bit integers from a into memory using …\nStore packed 8-bit integers from a into memory using …\nStore packed double-precision (64-bit) floating-point …\nStore packed single-precision (32-bit) floating-point …\nSubtract packed 16-bit integers in b from packed 16-bit …\nSubtract packed 32-bit integers in b from packed 32-bit …\nSubtract packed 64-bit integers in b from packed 64-bit …\nSubtract packed 8-bit integers in b from packed 8-bit …\nSubtract packed double-precision (64-bit) floating-point …\nSubtract packed single-precision (32-bit) floating-point …\nSubtract the lower double-precision (64-bit) …\nSubtract the lower single-precision (32-bit) …\nSubtract the lower double-precision (64-bit) …\nSubtract the lower single-precision (32-bit) …\nSubtract packed signed 16-bit integers in b from packed …\nSubtract packed signed 8-bit integers in b from packed …\nSubtract packed unsigned 16-bit integers in b from packed …\nSubtract packed unsigned 8-bit integers in b from packed …\nBitwise ternary logic that provides the capability to …\nBitwise ternary logic that provides the capability to …\nCompute the bitwise AND of packed 16-bit integers in a and …\nCompute the bitwise AND of packed 32-bit integers in a and …\nCompute the bitwise AND of packed 64-bit integers in a and …\nCompute the bitwise AND of packed 8-bit integers in a and …\nCompute the bitwise NAND of packed 16-bit integers in a …\nCompute the bitwise NAND of packed 32-bit integers in a …\nCompute the bitwise NAND of packed 64-bit integers in a …\nCompute the bitwise NAND of packed 8-bit integers in a and …\nUnpack and interleave 16-bit integers from the high half …\nUnpack and interleave 32-bit integers from the high half …\nUnpack and interleave 64-bit integers from the high half …\nUnpack and interleave 8-bit integers from the high half of …\nUnpack and interleave double-precision (64-bit) …\nUnpack and interleave single-precision (32-bit) …\nUnpack and interleave 16-bit integers from the low half of …\nUnpack and interleave 32-bit integers from the low half of …\nUnpack and interleave 64-bit integers from the low half of …\nUnpack and interleave 8-bit integers from the low half of …\nUnpack and interleave double-precision (64-bit) …\nUnpack and interleave single-precision (32-bit) …\nCompute the bitwise XOR of packed 32-bit integers in a and …\nCompute the bitwise XOR of packed 64-bit integers in a and …\nLoads packed 32-bit integers from memory pointed by …\nLoads packed 64-bit integers from memory pointed by …\nLoads packed double-precision (64-bit) floating-point …\nLoads packed single-precision (32-bit) floating-point …\nConditionally store 8-bit integer elements from <code>a</code> into …\nStores packed 32-bit integers from <code>a</code> into memory pointed …\nStores packed 64-bit integers from <code>a</code> into memory pointed …\nStores packed double-precision (64-bit) floating-point …\nStores packed single-precision (32-bit) floating-point …\nCompute the absolute value of packed signed 16-bit …\nCompute the absolute value of packed signed 32-bit …\nCompute the absolute value of packed signed 8-bit integers …\nAdd packed 16-bit integers in a and b, and store the …\nAdd packed 32-bit integers in a and b, and store the …\nAdd packed 64-bit integers in a and b, and store the …\nAdd packed 8-bit integers in a and b, and store the …\nAdd packed double-precision (64-bit) floating-point …\nAdd packed single-precision (32-bit) floating-point …\nAdd the lower double-precision (64-bit) floating-point …\nAdd the lower single-precision (32-bit) floating-point …\nAdd the lower double-precision (64-bit) floating-point …\nAdd the lower single-precision (32-bit) floating-point …\nAdd packed signed 16-bit integers in a and b using …\nAdd packed signed 8-bit integers in a and b using …\nAdd packed unsigned 16-bit integers in a and b using …\nAdd packed unsigned 8-bit integers in a and b using …\nConcatenate a and b into a 32-byte immediate result, shift …\nConcatenate a and b into a 32-byte immediate result, shift …\nConcatenate pairs of 16-byte blocks in a and b into a …\nCompute the bitwise AND of packed 32-bit integers in a and …\nCompute the bitwise AND of packed 64-bit integers in a and …\nCompute the bitwise NOT of packed 32-bit integers in a and …\nCompute the bitwise NOT of packed 64-bit integers in a and …\nAverage packed unsigned 16-bit integers in a and b, and …\nAverage packed unsigned 8-bit integers in a and b, and …\nBroadcast the low packed 8-bit integer from a to all …\nBroadcast the low packed 32-bit integer from a to all …\nBroadcast the low packed 64-bit integer from a to all …\nBroadcast the low single-precision (32-bit) floating-point …\nBroadcast the low packed 16-bit integer from a to all …\nContiguously store the active 16-bit integers in a (those …\nContiguously store the active 32-bit integers in a (those …\nContiguously store the active 64-bit integers in a (those …\nContiguously store the active 8-bit integers in a (those …\nContiguously store the active double-precision (64-bit) …\nContiguously store the active single-precision (32-bit) …\nTest each 32-bit element of a for equality with all other …\nTest each 64-bit element of a for equality with all other …\nConvert packed single-precision (32-bit) floating-point …\nConvert the lower double-precision (64-bit) floating-point …\nConvert the lower single-precision (32-bit) floating-point …\nSign extend packed 16-bit integers in a to packed 32-bit …\nSign extend packed 16-bit integers in a to packed 64-bit …\nConvert packed 16-bit integers in a to packed 8-bit …\nConvert packed 32-bit integers in a to packed 16-bit …\nSign extend packed 32-bit integers in a to packed 64-bit …\nConvert packed 32-bit integers in a to packed 8-bit …\nConvert packed signed 32-bit integers in a to packed …\nConvert packed signed 32-bit integers in a to packed …\nConvert packed 64-bit integers in a to packed 16-bit …\nConvert packed 64-bit integers in a to packed 32-bit …\nConvert packed 64-bit integers in a to packed 8-bit …\nSign extend packed 8-bit integers in a to packed 16-bit …\nSign extend packed 8-bit integers in a to packed 32-bit …\nSign extend packed 8-bit integers in the low 2 bytes of a …\nZero extend packed unsigned 16-bit integers in a to packed …\nZero extend packed unsigned 16-bit integers in the low 4 …\nZero extend packed unsigned 32-bit integers in a to packed …\nConvert packed unsigned 32-bit integers in a to packed …\nZero extend packed unsigned 8-bit integers in a to packed …\nZero extend packed unsigned 8-bit integers in th elow 4 …\nZero extend packed unsigned 8-bit integers in the low 2 …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed half-precision (16-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert the lower double-precision (64-bit) floating-point …\nConvert packed signed 16-bit integers in a to packed 8-bit …\nConvert packed signed 32-bit integers in a to packed …\nConvert packed signed 32-bit integers in a to packed 8-bit …\nConvert packed signed 64-bit integers in a to packed …\nConvert packed signed 64-bit integers in a to packed …\nConvert packed signed 64-bit integers in a to packed 8-bit …\nConvert the lower single-precision (32-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed double-precision (32-bit) floating-point …\nConvert packed unsigned 16-bit integers in a to packed …\nConvert packed unsigned 32-bit integers in a to packed …\nConvert packed unsigned 32-bit integers in a to packed …\nConvert packed unsigned 64-bit integers in a to packed …\nConvert packed unsigned 64-bit integers in a to packed …\nConvert packed unsigned 64-bit integers in a to packed …\nCompute the sum of absolute differences (SADs) of …\nDivide packed double-precision (64-bit) floating-point …\nDivide packed single-precision (32-bit) floating-point …\nDivide the lower double-precision (64-bit) floating-point …\nDivide the lower single-precision (32-bit) floating-point …\nDivide the lower double-precision (64-bit) floating-point …\nDivide the lower single-precision (32-bit) floating-point …\nCompute dot-product of BF16 (16-bit) floating-point pairs …\nMultiply groups of 4 adjacent pairs of unsigned 8-bit …\nMultiply groups of 4 adjacent pairs of unsigned 8-bit …\nMultiply groups of 2 adjacent pairs of signed 16-bit …\nMultiply groups of 2 adjacent pairs of signed 16-bit …\nLoad contiguous active 16-bit integers from a (those with …\nLoad contiguous active 32-bit integers from a (those with …\nLoad contiguous active 64-bit integers from a (those with …\nLoad contiguous active 8-bit integers from a (those with …\nLoad contiguous active double-precision (64-bit) …\nLoad contiguous active single-precision (32-bit) …\nLoad contiguous active 16-bit integers from unaligned …\nLoad contiguous active 32-bit integers from unaligned …\nLoad contiguous active 64-bit integers from unaligned …\nLoad contiguous active 8-bit integers from unaligned …\nLoad contiguous active double-precision (64-bit) …\nLoad contiguous active single-precision (32-bit) …\nFix up packed double-precision (64-bit) floating-point …\nFix up packed single-precision (32-bit) floating-point …\nFix up the lower double-precision (64-bit) floating-point …\nFix up the lower single-precision (32-bit) floating-point …\nFix up the lower double-precision (64-bit) floating-point …\nFix up the lower single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply the lower double-precision (64-bit) …\nMultiply the lower single-precision (32-bit) …\nMultiply the lower double-precision (64-bit) …\nMultiply the lower single-precision (32-bit) …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply the lower double-precision (64-bit) …\nMultiply the lower single-precision (32-bit) …\nMultiply the lower double-precision (64-bit) …\nMultiply the lower single-precision (32-bit) …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply the lower double-precision (64-bit) …\nMultiply the lower single-precision (32-bit) …\nMultiply the lower double-precision (64-bit) …\nMultiply the lower single-precision (32-bit) …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply the lower double-precision (64-bit) …\nMultiply the lower single-precision (32-bit) …\nMultiply the lower double-precision (64-bit) …\nMultiply the lower single-precision (32-bit) …\nConvert the exponent of each packed double-precision …\nConvert the exponent of each packed single-precision …\nConvert the exponent of the lower double-precision …\nConvert the exponent of the lower single-precision …\nConvert the exponent of the lower double-precision …\nConvert the exponent of the lower single-precision …\nNormalize the mantissas of packed double-precision …\nNormalize the mantissas of packed single-precision …\nNormalize the mantissas of the lower double-precision …\nNormalize the mantissas of the lower single-precision …\nNormalize the mantissas of the lower double-precision …\nNormalize the mantissas of the lower single-precision …\nPerforms an affine transformation on the packed bytes in x.\nPerforms an affine transformation on the inverted packed …\nPerforms a multiplication in GF(2^8) on the packed bytes. …\nLoad packed 32-bit integers from memory into dst using …\nLoad packed 64-bit integers from memory into dst using …\nLoad packed double-precision (64-bit) floating-point …\nLoad packed single-precision (32-bit) floating-point …\nLoad packed 16-bit integers from memory into dst using …\nLoad packed 32-bit integers from memory into dst using …\nLoad packed 64-bit integers from memory into dst using …\nLoad packed 8-bit integers from memory into dst using …\nLoad packed double-precision (64-bit) floating-point …\nLoad packed single-precision (32-bit) floating-point …\nCounts the number of leading zero bits in each packed …\nCounts the number of leading zero bits in each packed …\nMultiply packed signed 16-bit integers in a and b, …\nMultiply packed unsigned 8-bit integers in a by packed …\nCompare packed signed 16-bit integers in a and b, and …\nCompare packed signed 32-bit integers in a and b, and …\nCompare packed signed 64-bit integers in a and b, and …\nCompare packed signed 8-bit integers in a and b, and store …\nCompare packed unsigned 16-bit integers in a and b, and …\nCompare packed unsigned 32-bit integers in a and b, and …\nCompare packed unsigned 64-bit integers in a and b, and …\nCompare packed unsigned 8-bit integers in a and b, and …\nCompare packed double-precision (64-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nCompare the lower double-precision (64-bit) floating-point …\nCompare the lower single-precision (32-bit) floating-point …\nCompare the lower double-precision (64-bit) floating-point …\nCompare the lower single-precision (32-bit) floating-point …\nCompare packed signed 16-bit integers in a and b, and …\nCompare packed signed 32-bit integers in a and b, and …\nCompare packed signed 8-bit integers in a and b, and store …\nCompare packed unsigned 16-bit integers in a and b, and …\nCompare packed unsigned 32-bit integers in a and b, and …\nCompare packed unsigned 64-bit integers in a and b, and …\nCompare packed unsigned 8-bit integers in a and b, and …\nCompare packed double-precision (64-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nCompare the lower double-precision (64-bit) floating-point …\nCompare the lower single-precision (32-bit) floating-point …\nCompare the lower double-precision (64-bit) floating-point …\nCompare the lower single-precision (32-bit) floating-point …\nMove packed 16-bit integers from a into dst using zeromask …\nMove packed 32-bit integers from a into dst using zeromask …\nMove packed 64-bit integers from a into dst using zeromask …\nMove packed 8-bit integers from a into dst using zeromask …\nMove packed double-precision (64-bit) floating-point …\nMove packed single-precision (32-bit) floating-point …\nMove the lower double-precision (64-bit) floating-point …\nMove the lower single-precision (32-bit) floating-point …\nDuplicate even-indexed double-precision (64-bit) …\nDuplicate odd-indexed single-precision (32-bit) …\nDuplicate even-indexed single-precision (32-bit) …\nMultiply the low signed 32-bit integers from each packed …\nMultiply the low unsigned 32-bit integers from each packed …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply the lower double-precision (64-bit) …\nMultiply the lower single-precision (32-bit) …\nMultiply the lower double-precision (64-bit) …\nMultiply the lower single-precision (32-bit) …\nMultiply the packed signed 16-bit integers in a and b, …\nMultiply the packed unsigned 16-bit integers in a and b, …\nMultiply packed signed 16-bit integers in a and b, …\nMultiply the packed 16-bit integers in a and b, producing …\nMultiply the packed 32-bit integers in a and b, producing …\nFor each 64-bit element in b, select 8 unaligned bytes …\nCompute the bitwise OR of packed 32-bit integers in a and …\nCompute the bitwise OR of packed 64-bit integers in a and …\nConvert packed signed 16-bit integers from a and b to …\nConvert packed signed 32-bit integers from a and b to …\nConvert packed signed 16-bit integers from a and b to …\nConvert packed signed 32-bit integers from a and b to …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle single-precision (32-bit) floating-point elements …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle single-precision (32-bit) floating-point elements …\nShuffle 16-bit integers in a and b across lanes using the …\nShuffle 32-bit integers in a and b across lanes using the …\nShuffle 64-bit integers in a and b across lanes using the …\nShuffle 8-bit integers in a and b across lanes using the …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle single-precision (32-bit) floating-point elements …\nShuffle 16-bit integers in a across lanes using the …\nShuffle 8-bit integers in a across lanes using the …\nFor each packed 16-bit integer maps the value to the …\nFor each packed 32-bit integer maps the value to the …\nFor each packed 64-bit integer maps the value to the …\nFor each packed 8-bit integer maps the value to the number …\nCompute the approximate reciprocal of packed …\nCompute the approximate reciprocal of packed …\nCompute the approximate reciprocal of the lower …\nCompute the approximate reciprocal of the lower …\nRotate the bits in each packed 32-bit integer in a to the …\nRotate the bits in each packed 64-bit integer in a to the …\nRotate the bits in each packed 32-bit integer in a to the …\nRotate the bits in each packed 64-bit integer in a to the …\nRotate the bits in each packed 32-bit integer in a to the …\nRotate the bits in each packed 64-bit integer in a to the …\nRotate the bits in each packed 32-bit integer in a to the …\nRotate the bits in each packed 64-bit integer in a to the …\nRound packed double-precision (64-bit) floating-point …\nRound packed single-precision (32-bit) floating-point …\nRound the lower double-precision (64-bit) floating-point …\nRound the lower single-precision (32-bit) floating-point …\nRound the lower double-precision (64-bit) floating-point …\nRound the lower single-precision (32-bit) floating-point …\nCompute the approximate reciprocal square root of packed …\nCompute the approximate reciprocal square root of packed …\nCompute the approximate reciprocal square root of the …\nCompute the approximate reciprocal square root of the …\nScale the packed double-precision (64-bit) floating-point …\nScale the packed single-precision (32-bit) floating-point …\nScale the packed double-precision (64-bit) floating-point …\nScale the packed single-precision (32-bit) floating-point …\nScale the packed double-precision (64-bit) floating-point …\nScale the packed single-precision (32-bit) floating-point …\nBroadcast the low packed 16-bit integer from a to all …\nBroadcast 32-bit integer a to all elements of dst using …\nBroadcast 64-bit integer a to all elements of dst using …\nBroadcast 8-bit integer a to all elements of dst using …\nConcatenate packed 16-bit integers in a and b producing an …\nConcatenate packed 32-bit integers in a and b producing an …\nConcatenate packed 64-bit integers in a and b producing an …\nConcatenate packed 16-bit integers in a and b producing an …\nConcatenate packed 32-bit integers in a and b producing an …\nConcatenate packed 64-bit integers in a and b producing an …\nConcatenate packed 16-bit integers in b and a producing an …\nConcatenate packed 32-bit integers in b and a producing an …\nConcatenate packed 64-bit integers in b and a producing an …\nConcatenate packed 16-bit integers in b and a producing an …\nConcatenate packed 32-bit integers in b and a producing an …\nConcatenate packed 64-bit integers in b and a producing an …\nShuffle 32-bit integers in a within 128-bit lanes using …\nShuffle packed 8-bit integers in a according to shuffle …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle single-precision (32-bit) floating-point elements …\nShuffle 16-bit integers in the high 64 bits of 128-bit …\nShuffle 16-bit integers in the low 64 bits of 128-bit …\nShift packed 16-bit integers in a left by count while …\nShift packed 32-bit integers in a left by count while …\nShift packed 64-bit integers in a left by count while …\nShift packed 16-bit integers in a left by imm8 while …\nShift packed 32-bit integers in a left by imm8 while …\nShift packed 64-bit integers in a left by imm8 while …\nShift packed 16-bit integers in a left by the amount …\nShift packed 32-bit integers in a left by the amount …\nShift packed 64-bit integers in a left by the amount …\nCompute the square root of packed double-precision …\nCompute the square root of packed single-precision …\nCompute the square root of the lower double-precision …\nCompute the square root of the lower single-precision …\nCompute the square root of the lower double-precision …\nCompute the square root of the lower single-precision …\nShift packed 16-bit integers in a right by count while …\nShift packed 32-bit integers in a right by count while …\nShift packed 64-bit integers in a right by count while …\nShift packed 16-bit integers in a right by imm8 while …\nShift packed 32-bit integers in a right by imm8 while …\nShift packed 64-bit integers in a right by imm8 while …\nShift packed 16-bit integers in a right by the amount …\nShift packed 32-bit integers in a right by the amount …\nShift packed 64-bit integers in a right by the amount …\nShift packed 16-bit integers in a right by count while …\nShift packed 32-bit integers in a right by count while …\nShift packed 64-bit integers in a right by count while …\nShift packed 16-bit integers in a right by imm8 while …\nShift packed 32-bit integers in a right by imm8 while …\nShift packed 64-bit integers in a right by imm8 while …\nShift packed 16-bit integers in a right by the amount …\nShift packed 32-bit integers in a right by the amount …\nShift packed 64-bit integers in a right by the amount …\nSubtract packed 16-bit integers in b from packed 16-bit …\nSubtract packed 32-bit integers in b from packed 32-bit …\nSubtract packed 64-bit integers in b from packed 64-bit …\nSubtract packed 8-bit integers in b from packed 8-bit …\nSubtract packed double-precision (64-bit) floating-point …\nSubtract packed single-precision (32-bit) floating-point …\nSubtract the lower double-precision (64-bit) …\nSubtract the lower single-precision (32-bit) …\nSubtract the lower double-precision (64-bit) …\nSubtract the lower single-precision (32-bit) …\nSubtract packed signed 16-bit integers in b from packed …\nSubtract packed signed 8-bit integers in b from packed …\nSubtract packed unsigned 16-bit integers in b from packed …\nSubtract packed unsigned 8-bit integers in b from packed …\nBitwise ternary logic that provides the capability to …\nBitwise ternary logic that provides the capability to …\nUnpack and interleave 16-bit integers from the high half …\nUnpack and interleave 32-bit integers from the high half …\nUnpack and interleave 64-bit integers from the high half …\nUnpack and interleave 8-bit integers from the high half of …\nUnpack and interleave double-precision (64-bit) …\nUnpack and interleave single-precision (32-bit) …\nUnpack and interleave 16-bit integers from the low half of …\nUnpack and interleave 32-bit integers from the low half of …\nUnpack and interleave 64-bit integers from the low half of …\nUnpack and interleave 8-bit integers from the low half of …\nUnpack and interleave double-precision (64-bit) …\nUnpack and interleave single-precision (32-bit) …\nCompute the bitwise XOR of packed 32-bit integers in a and …\nCompute the bitwise XOR of packed 64-bit integers in a and …\nCompares packed 16-bit integers in <code>a</code> and <code>b</code>, and returns …\nCompares packed 32-bit integers in <code>a</code> and <code>b</code>, and returns …\nCompare packed signed 64-bit integers in a and b, and …\nCompares packed 8-bit integers in <code>a</code> and <code>b</code> and returns …\nCompares packed unsigned 16-bit integers in <code>a</code> and <code>b</code>, and …\nCompares packed unsigned 32-bit integers in <code>a</code> and <code>b</code>, and …\nCompare packed unsigned 64-bit integers in a and b, and …\nCompares packed unsigned 8-bit integers in <code>a</code> and <code>b</code>, and …\nReturns a new vector with the maximum values from …\nCompares packed single-precision (32-bit) floating-point …\nCompare the lower double-precision (64-bit) floating-point …\nCompare the lower single-precision (32-bit) floating-point …\nReturns a new vector with the low element of <code>a</code> replaced by …\nCompares the first single-precision (32-bit) …\nPerforms a serializing operation on all load-from-memory …\nCompares packed 16-bit integers in <code>a</code> and <code>b</code>, and returns …\nCompares packed 32-bit integers in <code>a</code> and <code>b</code>, and returns …\nCompares packed 8-bit integers in <code>a</code> and <code>b</code> and returns …\nCompares packed unsigned 16-bit integers in <code>a</code> and <code>b</code>, and …\nCompares packed unsigned 32-bit integers in <code>a</code> and <code>b</code>, and …\nCompare packed unsigned 64-bit integers in a and b, and …\nCompares packed unsigned 8-bit integers in <code>a</code> and <code>b</code>, and …\nReturns a new vector with the minimum values from …\nCompares packed single-precision (32-bit) floating-point …\nCompare the lower double-precision (64-bit) floating-point …\nCompare the lower single-precision (32-bit) floating-point …\nReturns a new vector with the low element of <code>a</code> replaced by …\nCompares the first single-precision (32-bit) …\nFinds the minimum unsigned 16-bit element in the 128-bit __…\nReturns a vector where the low element is extracted from <code>a</code> …\nConstructs a 128-bit floating-point vector of <code>[2 x double]</code>…\nReturns a <code>__m128</code> with the first component from <code>b</code> and the …\nDuplicate the low double-precision (64-bit) floating-point …\nDuplicate odd-indexed single-precision (32-bit) …\nCombine higher half of <code>a</code> and <code>b</code>. The higher half of <code>b</code> …\nDuplicate even-indexed single-precision (32-bit) …\nCombine lower half of <code>a</code> and <code>b</code>. The lower half of <code>b</code> …\nReturns a mask of the most significant bit of each element …\nReturns a mask of the most significant bit of each element …\nReturns a mask of the most significant bit of each element …\nSet each bit of mask register k based on the most …\nSet each bit of mask register k based on the most …\nSet each packed 16-bit integer in dst to all ones or all …\nSet each packed 8-bit integer in dst to all ones or all …\nSubtracts 8-bit unsigned integer values and computes the …\nMultiplies the low 32-bit integers from each packed 64-bit …\nMultiplies the low unsigned 32-bit integers from each …\nMultiplies packed double-precision (64-bit) floating-point …\nMultiplies __m128 vectors.\nMultiply the lower double-precision (64-bit) …\nMultiply the lower single-precision (32-bit) …\nReturns a new vector with the low element of <code>a</code> replaced by …\nMultiplies the first component of <code>a</code> and <code>b</code>, the other …\nMultiplies the packed 16-bit integers in <code>a</code> and <code>b</code>.\nMultiplies the packed unsigned 16-bit integers in <code>a</code> and <code>b</code>.\nMultiplies packed 16-bit signed integer values, truncate …\nMultiplies the packed 16-bit integers in <code>a</code> and <code>b</code>.\nMultiplies the packed 32-bit integers in <code>a</code> and <code>b</code>, …\nFor each 64-bit element in b, select 8 unaligned bytes …\nCompute the bitwise OR of packed 32-bit integers in a and …\nCompute the bitwise OR of packed 64-bit integers in a and …\nComputes the bitwise OR of <code>a</code> and <code>b</code>.\nBitwise OR of packed single-precision (32-bit) …\nComputes the bitwise OR of 128 bits (representing integer …\nConverts packed 16-bit integers from <code>a</code> and <code>b</code> to packed …\nConverts packed 32-bit integers from <code>a</code> and <code>b</code> to packed …\nConverts packed 16-bit integers from <code>a</code> and <code>b</code> to packed …\nConverts packed 32-bit integers from <code>a</code> and <code>b</code> to packed …\nProvides a hint to the processor that the code sequence is …\nShuffles double-precision (64-bit) floating-point elements …\nShuffles single-precision (32-bit) floating-point elements …\nShuffles double-precision (64-bit) floating-point elements …\nShuffles single-precision (32-bit) floating-point elements …\nShuffle 16-bit integers in a and b across lanes using the …\nShuffle 32-bit integers in a and b across lanes using the …\nShuffle 64-bit integers in a and b across lanes using the …\nShuffle 8-bit integers in a and b across lanes using the …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle single-precision (32-bit) floating-point elements …\nShuffle 16-bit integers in a across lanes using the …\nShuffle 8-bit integers in a across lanes using the …\nFor each packed 16-bit integer maps the value to the …\nFor each packed 32-bit integer maps the value to the …\nFor each packed 64-bit integer maps the value to the …\nFor each packed 8-bit integer maps the value to the number …\nFetch the cache line that contains address <code>p</code> using the …\nCompute the approximate reciprocal of packed …\nCompute the approximate reciprocal of packed …\nCompute the approximate reciprocal of the lower …\nCompute the approximate reciprocal of the lower …\nReturns the approximate reciprocal of packed …\nReturns the approximate reciprocal of the first …\nRotate the bits in each packed 32-bit integer in a to the …\nRotate the bits in each packed 64-bit integer in a to the …\nRotate the bits in each packed 32-bit integer in a to the …\nRotate the bits in each packed 64-bit integer in a to the …\nRotate the bits in each packed 32-bit integer in a to the …\nRotate the bits in each packed 64-bit integer in a to the …\nRotate the bits in each packed 32-bit integer in a to the …\nRotate the bits in each packed 64-bit integer in a to the …\nRound the packed double-precision (64-bit) floating-point …\nRound the packed single-precision (32-bit) floating-point …\nRound the lower double-precision (64-bit) floating-point …\nRound the lower single-precision (32-bit) floating-point …\nRound packed double-precision (64-bit) floating-point …\nRound packed single-precision (32-bit) floating-point …\nRound the lower double-precision (64-bit) floating-point …\nRound the lower single-precision (32-bit) floating-point …\nRound the lower double-precision (64-bit) floating-point …\nRound the lower single-precision (32-bit) floating-point …\nCompute the approximate reciprocal square root of the …\nCompute the approximate reciprocal square root of the …\nReturns the approximate reciprocal square root of packed …\nReturns the approximate reciprocal square root of the …\nSum the absolute differences of packed unsigned 8-bit …\nScale the packed double-precision (64-bit) floating-point …\nScale the packed single-precision (32-bit) floating-point …\nScale the packed double-precision (64-bit) floating-point …\nScale the packed single-precision (32-bit) floating-point …\nScale the packed double-precision (64-bit) floating-point …\nScale the packed single-precision (32-bit) floating-point …\nBroadcasts 16-bit integer <code>a</code> to all elements.\nBroadcasts 32-bit integer <code>a</code> to all elements.\nBroadcasts 64-bit integer <code>a</code> to all elements.\nBroadcasts 8-bit integer <code>a</code> to all elements.\nBroadcasts double-precision (64-bit) floating-point value …\nConstruct a <code>__m128</code> with all element set to <code>a</code>.\nSets packed 16-bit integers with the supplied values.\nSets packed 32-bit integers with the supplied values.\nSets packed 64-bit integers with the supplied values, from …\nSets packed 8-bit integers with the supplied values.\nSets packed double-precision (64-bit) floating-point …\nBroadcasts double-precision (64-bit) floating-point value …\nConstruct a <code>__m128</code> from four floating point values highest …\nAlias for <code>_mm_set1_ps</code>\nCopies double-precision (64-bit) floating-point element <code>a</code> …\nConstruct a <code>__m128</code> with the lowest element set to <code>a</code> and …\nSets the MXCSR register with the 32-bit unsigned integer …\nSets packed 16-bit integers with the supplied values in …\nSets packed 32-bit integers with the supplied values in …\nSets packed 8-bit integers with the supplied values in …\nSets packed double-precision (64-bit) floating-point …\nConstruct a <code>__m128</code> from four floating point values lowest …\nReturns packed double-precision (64-bit) floating-point …\nConstruct a <code>__m128</code> with all elements initialized to zero.\nReturns a vector with all elements set to zero.\nPerforms a serializing operation on all non-temporal (“…\nPerforms an intermediate calculation for the next four …\nPerforms the final calculation for the next four SHA1 …\nCalculate SHA1 state variable E after four rounds of …\nPerforms four rounds of SHA1 operation using an initial …\nPerforms an intermediate calculation for the next four …\nPerforms the final calculation for the next four SHA256 …\nPerforms 2 rounds of SHA256 operation using an initial …\nConcatenate packed 16-bit integers in a and b producing an …\nConcatenate packed 32-bit integers in a and b producing an …\nConcatenate packed 64-bit integers in a and b producing an …\nConcatenate packed 16-bit integers in a and b producing an …\nConcatenate packed 32-bit integers in a and b producing an …\nConcatenate packed 64-bit integers in a and b producing an …\nConcatenate packed 16-bit integers in b and a producing an …\nConcatenate packed 32-bit integers in b and a producing an …\nConcatenate packed 64-bit integers in b and a producing an …\nConcatenate packed 16-bit integers in b and a producing an …\nConcatenate packed 32-bit integers in b and a producing an …\nConcatenate packed 64-bit integers in b and a producing an …\nShuffles 32-bit integers in <code>a</code> using the control in <code>IMM8</code>.\nShuffles bytes from <code>a</code> according to the content of <code>b</code>.\nConstructs a 128-bit floating-point vector of <code>[2 x double]</code> …\nShuffles packed single-precision (32-bit) floating-point …\nShuffles 16-bit integers in the high 64 bits of <code>a</code> using …\nShuffles 16-bit integers in the low 64 bits of <code>a</code> using the …\nNegates packed 16-bit integers in <code>a</code> when the corresponding …\nNegates packed 32-bit integers in <code>a</code> when the corresponding …\nNegates packed 8-bit integers in <code>a</code> when the corresponding …\nShifts packed 16-bit integers in <code>a</code> left by <code>count</code> while …\nShifts packed 32-bit integers in <code>a</code> left by <code>count</code> while …\nShifts packed 64-bit integers in <code>a</code> left by <code>count</code> while …\nShifts packed 16-bit integers in <code>a</code> left by <code>IMM8</code> while …\nShifts packed 32-bit integers in <code>a</code> left by <code>IMM8</code> while …\nShifts packed 64-bit integers in <code>a</code> left by <code>IMM8</code> while …\nShifts <code>a</code> left by <code>IMM8</code> bytes while shifting in zeros.\nShift packed 16-bit integers in a left by the amount …\nShifts packed 32-bit integers in <code>a</code> left by the amount …\nShifts packed 64-bit integers in <code>a</code> left by the amount …\nReturns a new vector with the square root of each of the …\nReturns the square root of packed single-precision …\nCompute the square root of the lower double-precision …\nCompute the square root of the lower single-precision …\nReturns a new vector with the low element of <code>a</code> replaced by …\nReturns the square root of the first single-precision …\nShifts packed 16-bit integers in <code>a</code> right by <code>count</code> while …\nShifts packed 32-bit integers in <code>a</code> right by <code>count</code> while …\nShift packed 64-bit integers in a right by count while …\nShifts packed 16-bit integers in <code>a</code> right by <code>IMM8</code> while …\nShifts packed 32-bit integers in <code>a</code> right by <code>IMM8</code> while …\nShift packed 64-bit integers in a right by imm8 while …\nShift packed 16-bit integers in a right by the amount …\nShifts packed 32-bit integers in <code>a</code> right by the amount …\nShift packed 64-bit integers in a right by the amount …\nShifts packed 16-bit integers in <code>a</code> right by <code>count</code> while …\nShifts packed 32-bit integers in <code>a</code> right by <code>count</code> while …\nShifts packed 64-bit integers in <code>a</code> right by <code>count</code> while …\nShifts packed 16-bit integers in <code>a</code> right by <code>IMM8</code> while …\nShifts packed 32-bit integers in <code>a</code> right by <code>IMM8</code> while …\nShifts packed 64-bit integers in <code>a</code> right by <code>IMM8</code> while …\nShifts <code>a</code> right by <code>IMM8</code> bytes while shifting in zeros.\nShift packed 16-bit integers in a right by the amount …\nShifts packed 32-bit integers in <code>a</code> right by the amount …\nShifts packed 64-bit integers in <code>a</code> right by the amount …\nStores the lower double-precision (64-bit) floating-point …\nStores the lowest 32 bit float of <code>a</code> repeated four times …\nStore 128-bits (composed of 4 packed 32-bit integers) from …\nStore 128-bits (composed of 2 packed 64-bit integers) from …\nStores 128-bits (composed of 2 packed double-precision …\nStores the lower double-precision (64-bit) floating-point …\nStores four 32-bit floats into <em>aligned</em> memory.\nAlias for <code>_mm_store1_ps</code>\nStores the lower 64 bits of a 128-bit vector of …\nStores 128-bits of integer data from <code>a</code> into memory.\nStores the lowest 32 bit float of <code>a</code> into memory.\nStores the upper 64 bits of a 128-bit vector of …\nStores the lower 64-bit integer <code>a</code> to a memory location.\nStores the lower 64 bits of a 128-bit vector of …\nStores 2 double-precision (64-bit) floating-point elements …\nStores four 32-bit floats into <em>aligned</em> memory in reverse …\nStore 128-bits (composed of 8 packed 16-bit integers) from …\nStore 128-bits (composed of 4 packed 32-bit integers) from …\nStore 128-bits (composed of 2 packed 64-bit integers) from …\nStore 128-bits (composed of 16 packed 8-bit integers) from …\nStores 128-bits (composed of 2 packed double-precision …\nStores four 32-bit floats into memory. There are no …\nStores 128-bits of integer data from <code>a</code> into memory.\nStores a 128-bit floating point vector of <code>[2 x double]</code> to …\nStores <code>a</code> into the memory at <code>mem_addr</code> using a non-temporal …\nNon-temporal store of <code>a.0</code> into <code>p</code>.\nStores a 128-bit integer vector to a 128-bit aligned …\nStores a 32-bit integer value in the specified memory …\nNon-temporal store of <code>a.0</code> into <code>p</code>.\nSubtracts packed 16-bit integers in <code>b</code> from packed 16-bit …\nSubtract packed 32-bit integers in <code>b</code> from packed 32-bit …\nSubtract packed 64-bit integers in <code>b</code> from packed 64-bit …\nSubtracts packed 8-bit integers in <code>b</code> from packed 8-bit …\nSubtract packed double-precision (64-bit) floating-point …\nSubtracts __m128 vectors.\nSubtract the lower double-precision (64-bit) …\nSubtract the lower single-precision (32-bit) …\nReturns a new vector with the low element of <code>a</code> replaced by …\nSubtracts the first component of <code>b</code> from <code>a</code>, the other …\nSubtract packed 16-bit integers in <code>b</code> from packed 16-bit …\nSubtract packed 8-bit integers in <code>b</code> from packed 8-bit …\nSubtract packed unsigned 16-bit integers in <code>b</code> from packed …\nSubtract packed unsigned 8-bit integers in <code>b</code> from packed …\nBitwise ternary logic that provides the capability to …\nBitwise ternary logic that provides the capability to …\nTests whether the specified bits in <code>a</code> 128-bit integer …\nTests whether the specified bits in a 128-bit integer …\nCompute the bitwise AND of packed 16-bit integers in a and …\nCompute the bitwise AND of packed 32-bit integers in a and …\nCompute the bitwise AND of packed 64-bit integers in a and …\nCompute the bitwise AND of packed 8-bit integers in a and …\nTests whether the specified bits in a 128-bit integer …\nComputes the bitwise AND of 128 bits (representing …\nComputes the bitwise AND of 128 bits (representing …\nTests whether the specified bits in a 128-bit integer …\nCompute the bitwise NAND of packed 16-bit integers in a …\nCompute the bitwise NAND of packed 32-bit integers in a …\nCompute the bitwise NAND of packed 64-bit integers in a …\nCompute the bitwise NAND of packed 8-bit integers in a and …\nComputes the bitwise AND of 128 bits (representing …\nComputes the bitwise AND of 128 bits (representing …\nTests whether the specified bits in a 128-bit integer …\nComputes the bitwise AND of 128 bits (representing …\nComputes the bitwise AND of 128 bits (representing …\nTests whether the specified bits in a 128-bit integer …\nCounts the number of trailing least significant zero bits.\nCompares the lower element of <code>a</code> and <code>b</code> for equality.\nCompares two 32-bit floats from the low-order bits of <code>a</code> …\nCompares the lower element of <code>a</code> and <code>b</code> for …\nCompares two 32-bit floats from the low-order bits of <code>a</code> …\nCompares the lower element of <code>a</code> and <code>b</code> for greater-than.\nCompares two 32-bit floats from the low-order bits of <code>a</code> …\nCompares the lower element of <code>a</code> and <code>b</code> for …\nCompares two 32-bit floats from the low-order bits of <code>a</code> …\nCompares the lower element of <code>a</code> and <code>b</code> for less-than.\nCompares two 32-bit floats from the low-order bits of <code>a</code> …\nCompares the lower element of <code>a</code> and <code>b</code> for not-equal.\nCompares two 32-bit floats from the low-order bits of <code>a</code> …\nReturns vector of type __m128d with indeterminate elements.\nReturns vector of type __m128 with indeterminate elements. …\nReturns vector of type __m128i with indeterminate elements.\nUnpacks and interleave 16-bit integers from the high half …\nUnpacks and interleave 32-bit integers from the high half …\nUnpacks and interleave 64-bit integers from the high half …\nUnpacks and interleave 8-bit integers from the high half …\nThe resulting <code>__m128d</code> element is composed by the low-order …\nUnpacks and interleave single-precision (32-bit) …\nUnpacks and interleave 16-bit integers from the low half …\nUnpacks and interleave 32-bit integers from the low half …\nUnpacks and interleave 64-bit integers from the low half …\nUnpacks and interleave 8-bit integers from the low half of …\nThe resulting <code>__m128d</code> element is composed by the …\nUnpacks and interleave single-precision (32-bit) …\nCompute the bitwise XOR of packed 32-bit integers in a and …\nCompute the bitwise XOR of packed 64-bit integers in a and …\nComputes the bitwise XOR of <code>a</code> and <code>b</code>.\nBitwise exclusive OR of packed single-precision (32-bit) …\nComputes the bitwise XOR of 128 bits (representing integer …\nUnsigned multiply without affecting flags.\nScatter contiguous low order bits of <code>a</code> to the result at …\nGathers the bits of <code>x</code> specified by the <code>mask</code> into the …\nCounts the bits that are set.\nRead a hardware generated 16-bit random value and store …\nRead a hardware generated 32-bit random value and store …\nRead a 16-bit NIST SP800-90B and SP800-90C compliant …\nRead a 32-bit NIST SP800-90B and SP800-90C compliant …\nReads the current value of the processor’s time-stamp …\nStore 32-bit mask from a into memory.\nStore 64-bit mask from a into memory.\nAdds unsigned 32-bit integers <code>a</code> and <code>b</code> with unsigned 8-bit …\nClears all bits below the least significant zero of <code>x</code> and …\nClears all bits below the least significant zero of <code>x</code> and …\nCounts the number of trailing least significant zero bits.\nSets all bits below the least significant one of <code>x</code> and …\nSets all bits below the least significant one of <code>x</code> and …\nForces a restricted transactional memory (RTM) region to …\nRetrieves the parameter passed to <code>_xabort</code> when <code>_xbegin</code>’s …\nSpecifies the start of a restricted transactional memory …\nSpecifies the end of a restricted transactional memory …\nReads the contents of the extended control register <code>XCR</code> …\nPerforms a full or partial restore of the enabled …\nPerforms a full or partial restore of the enabled …\nPerforms a full or partial save of the enabled processor …\nPerforms a full or partial save of the enabled processor …\nPerforms a full or partial save of the enabled processor …\nPerforms a full or partial save of the enabled processor …\nCopies 64-bits from <code>val</code> to the extended control register (…\nQueries whether the processor is executing in a …\nEAX register.\nEBX register.\nECX register.\nEDX register.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nDoes the host support the <code>cpuid</code> instruction?\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nResult of the <code>cpuid</code> instruction.\nEqual (ordered, non-signaling)\nEqual (ordered, signaling)\nEqual (unordered, non-signaling)\nEqual (unordered, signaling)\nFalse (ordered, non-signaling)\nFalse (ordered, signaling)\nGreater-than-or-equal (ordered, non-signaling)\nGreater-than-or-equal (ordered, signaling)\nGreater-than (ordered, non-signaling)\nGreater-than (ordered, signaling)\nLess-than-or-equal (ordered, non-signaling)\nLess-than-or-equal (ordered, signaling)\nLess-than (ordered, non-signaling)\nLess-than (ordered, signaling)\nNot-equal (ordered, non-signaling)\nNot-equal (ordered, signaling)\nNot-equal (unordered, non-signaling)\nNot-equal (unordered, signaling)\nNot-greater-than-or-equal (unordered, non-signaling)\nNot-greater-than-or-equal (unordered, signaling)\nNot-greater-than (unordered, non-signaling)\nNot-greater-than (unordered, signaling)\nNot-less-than-or-equal (unordered, non-signaling)\nNot-less-than-or-equal (unordered, signaling)\nNot-less-than (unordered, non-signaling)\nNot-less-than (unordered, signaling)\nOrdered (non-signaling)\nOrdered (signaling)\nTrue (unordered, non-signaling)\nTrue (unordered, signaling)\nUnordered (non-signaling)\nUnordered (signaling)\nThe <code>_MM_CMPINT_ENUM</code> type used to specify comparison …\nEqual\nFalse\nLess-than-or-equal\nLess-than\nNot-equal\nNot less-than-or-equal\nNot less-than\nTrue\nSee <code>_mm_setcsr</code>\nSee <code>_mm_setcsr</code>\nSee <code>_mm_setcsr</code>\nSee <code>_mm_setcsr</code>\nSee <code>_MM_GET_EXCEPTION_STATE</code>\nSee <code>_mm_setcsr</code>\nSee <code>_mm_setcsr</code>\nSee <code>_MM_GET_FLUSH_ZERO_MODE</code>\nSee <code>_mm_setcsr</code>\nSee <code>_mm_setcsr</code>\nround up and do not suppress exceptions\nuse MXCSR.RC; see <code>vendor::_MM_SET_ROUNDING_MODE</code>\nround down and do not suppress exceptions\nuse MXCSR.RC and suppress exceptions; see …\nround to nearest and do not suppress exceptions\nsuppress exceptions\ndo not suppress exceptions\nuse MXCSR.RC and do not suppress exceptions; see …\nround to nearest\nround down\nround up\ntruncate\ntruncate and do not suppress exceptions\nSee <code>_mm_setcsr</code>\nSee <code>_mm_setcsr</code>\nSee <code>_mm_setcsr</code>\nSee <code>_mm_setcsr</code>\nSee <code>_mm_prefetch</code>.\nSee <code>_mm_prefetch</code>.\nSee <code>_mm_prefetch</code>.\nSee <code>_mm_prefetch</code>.\nSee <code>_mm_prefetch</code>.\nSee <code>_mm_prefetch</code>.\nThe <code>MM_MANTISSA_NORM_ENUM</code> type used to specify mantissa …\nThe <code>MM_MANTISSA_SIGN_ENUM</code> type used to specify mantissa …\ninterval [1, 2)\ninterval [0.5, 1)\ninterval [0.5, 2)\ninterval [0.75, 1.5)\nDEST = NaN if sign(SRC) = 1\nsign = sign(SRC)\nsign = 0\nSee <code>_mm_setcsr</code>\nSee <code>_mm_setcsr</code>\nSee <code>_mm_setcsr</code>\nSee <code>_mm_setcsr</code>\nSee <code>_MM_GET_EXCEPTION_MASK</code>\nSee <code>_mm_setcsr</code>\nSee <code>_mm_setcsr</code>\nThe <code>MM_PERM_ENUM</code> type used to specify shuffle operations …\nSee <code>_mm_setcsr</code>\nSee <code>_MM_GET_ROUNDING_MODE</code>\nSee <code>_mm_setcsr</code>\nSee <code>_mm_setcsr</code>\nSee <code>_mm_setcsr</code>\nSee <code>_mm_setcsr</code>\nSee <code>_mm_setcsr</code>\nSee <code>_mm_setcsr</code>\nSee <code>_mm_setcsr</code>\nA utility function for creating masks to use with Intel …\nTranspose the 4x4 matrix formed by 4 rows of __m128 in …\n<strong>Mask only</strong>: return the bit mask\nFor each character in <code>a</code>, find if it is in <code>b</code> <em>(Default)</em>\nThe strings defined by <code>a</code> and <code>b</code> are equal\nSearch for the defined substring in the target\nFor each character in <code>a</code>, determine if …\n<strong>Index only</strong>: return the least significant bit <em>(Default)</em>\nNegates results only before the end of the string\nDo not negate results before the end of the string\n<strong>Index only</strong>: return the most significant bit\nNegates results\nDo not negate results <em>(Default)</em>\nString contains signed 8-bit characters\nString contains unsigned 16-bit characters\nString contains unsigned 8-bit characters <em>(Default)</em>\n<strong>Mask only</strong>: return the byte mask\nString contains unsigned 16-bit characters\nTransaction abort due to the transaction using too much …\nTransaction abort due to a memory conflict with another …\nTransaction abort due to a debug trap.\nTransaction explicitly aborted with xabort. The parameter …\nTransaction abort in a inner nested transaction.\nTransaction retry is possible.\nTransaction successfully started.\n<code>XFEATURE_ENABLED_MASK</code> for <code>XCR</code>\nSee <code>__cpuid_count</code>.\nReturns the result of the <code>cpuid</code> instruction for a given …\nReturns the highest-supported <code>leaf</code> (<code>EAX</code>) and sub-leaf (<code>ECX</code>…")